
ministack.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000b9e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000ae4  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000003f  00800100  00800100  00000b98  2**0
                  ALLOC
  3 .fuse         00000003  00820000  00820000  00000b98  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .signature    00000003  00840000  00840000  00000b9b  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .comment      00000030  00000000  00000000  00000b9e  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000bd0  2**2
                  CONTENTS, READONLY
  7 .debug_aranges 000000e0  00000000  00000000  00000c10  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   000066a4  00000000  00000000  00000cf0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000012eb  00000000  00000000  00007394  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00000ac2  00000000  00000000  0000867f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  0000021c  00000000  00000000  00009144  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    0000291e  00000000  00000000  00009360  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00001ad7  00000000  00000000  0000bc7e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000110  00000000  00000000  0000d755  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	44 c0       	rjmp	.+136    	; 0x8a <__ctors_end>
   2:	00 00       	nop
   4:	5c c0       	rjmp	.+184    	; 0xbe <__bad_interrupt>
   6:	00 00       	nop
   8:	5a c0       	rjmp	.+180    	; 0xbe <__bad_interrupt>
   a:	00 00       	nop
   c:	58 c0       	rjmp	.+176    	; 0xbe <__bad_interrupt>
   e:	00 00       	nop
  10:	db c2       	rjmp	.+1462   	; 0x5c8 <__vector_4>
  12:	00 00       	nop
  14:	54 c0       	rjmp	.+168    	; 0xbe <__bad_interrupt>
  16:	00 00       	nop
  18:	52 c0       	rjmp	.+164    	; 0xbe <__bad_interrupt>
  1a:	00 00       	nop
  1c:	50 c0       	rjmp	.+160    	; 0xbe <__bad_interrupt>
  1e:	00 00       	nop
  20:	4e c0       	rjmp	.+156    	; 0xbe <__bad_interrupt>
  22:	00 00       	nop
  24:	4c c0       	rjmp	.+152    	; 0xbe <__bad_interrupt>
  26:	00 00       	nop
  28:	4a c0       	rjmp	.+148    	; 0xbe <__bad_interrupt>
  2a:	00 00       	nop
  2c:	48 c0       	rjmp	.+144    	; 0xbe <__bad_interrupt>
  2e:	00 00       	nop
  30:	46 c0       	rjmp	.+140    	; 0xbe <__bad_interrupt>
  32:	00 00       	nop
  34:	44 c0       	rjmp	.+136    	; 0xbe <__bad_interrupt>
  36:	00 00       	nop
  38:	42 c0       	rjmp	.+132    	; 0xbe <__bad_interrupt>
  3a:	00 00       	nop
  3c:	56 c0       	rjmp	.+172    	; 0xea <__vector_15>
  3e:	00 00       	nop
  40:	3e c0       	rjmp	.+124    	; 0xbe <__bad_interrupt>
  42:	00 00       	nop
  44:	3c c0       	rjmp	.+120    	; 0xbe <__bad_interrupt>
  46:	00 00       	nop
  48:	3a c0       	rjmp	.+116    	; 0xbe <__bad_interrupt>
  4a:	00 00       	nop
  4c:	38 c0       	rjmp	.+112    	; 0xbe <__bad_interrupt>
  4e:	00 00       	nop
  50:	36 c0       	rjmp	.+108    	; 0xbe <__bad_interrupt>
  52:	00 00       	nop
  54:	34 c0       	rjmp	.+104    	; 0xbe <__bad_interrupt>
  56:	00 00       	nop
  58:	32 c0       	rjmp	.+100    	; 0xbe <__bad_interrupt>
  5a:	00 00       	nop
  5c:	30 c0       	rjmp	.+96     	; 0xbe <__bad_interrupt>
  5e:	00 00       	nop
  60:	2e c0       	rjmp	.+92     	; 0xbe <__bad_interrupt>
  62:	00 00       	nop
  64:	2c c0       	rjmp	.+88     	; 0xbe <__bad_interrupt>
	...

00000068 <__trampolines_end>:
  68:	00 00       	nop
  6a:	1e 00       	.word	0x001e	; ????
  6c:	11 48       	sbci	r17, 0x81	; 129
  6e:	08 01       	movw	r0, r16
  70:	a6 12       	cpse	r10, r22
  72:	34 56       	subi	r19, 0x64	; 100
	...

00000088 <__ctors_start>:
  88:	7d 03       	fmul	r23, r21

0000008a <__ctors_end>:
  8a:	11 24       	eor	r1, r1
  8c:	1f be       	out	0x3f, r1	; 63
  8e:	cf ef       	ldi	r28, 0xFF	; 255
  90:	d8 e0       	ldi	r29, 0x08	; 8
  92:	de bf       	out	0x3e, r29	; 62
  94:	cd bf       	out	0x3d, r28	; 61

00000096 <__do_clear_bss>:
  96:	21 e0       	ldi	r18, 0x01	; 1
  98:	a0 e0       	ldi	r26, 0x00	; 0
  9a:	b1 e0       	ldi	r27, 0x01	; 1
  9c:	01 c0       	rjmp	.+2      	; 0xa0 <.do_clear_bss_start>

0000009e <.do_clear_bss_loop>:
  9e:	1d 92       	st	X+, r1

000000a0 <.do_clear_bss_start>:
  a0:	af 33       	cpi	r26, 0x3F	; 63
  a2:	b2 07       	cpc	r27, r18
  a4:	e1 f7       	brne	.-8      	; 0x9e <.do_clear_bss_loop>

000000a6 <__do_global_ctors>:
  a6:	10 e0       	ldi	r17, 0x00	; 0
  a8:	c5 e4       	ldi	r28, 0x45	; 69
  aa:	d0 e0       	ldi	r29, 0x00	; 0
  ac:	03 c0       	rjmp	.+6      	; 0xb4 <__do_global_ctors+0xe>
  ae:	21 97       	sbiw	r28, 0x01	; 1
  b0:	fe 01       	movw	r30, r28
  b2:	07 d5       	rcall	.+2574   	; 0xac2 <__tablejump2__>
  b4:	c4 34       	cpi	r28, 0x44	; 68
  b6:	d1 07       	cpc	r29, r17
  b8:	d1 f7       	brne	.-12     	; 0xae <__do_global_ctors+0x8>
  ba:	c7 d4       	rcall	.+2446   	; 0xa4a <main>
  bc:	11 c5       	rjmp	.+2594   	; 0xae0 <_exit>

000000be <__bad_interrupt>:
  be:	a0 cf       	rjmp	.-192    	; 0x0 <__vectors>

000000c0 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE6odReadEhh.isra.1>:
template <class T, int PDI, int PDO, class SpiSsHndlr>
uint8_t StackBase<T, PDI, PDO, SpiSsHndlr>::odRead(uint8_t channel, uint8_t address)
{
    uint8_t data;

    switch (channel)
  c0:	80 32       	cpi	r24, 0x20	; 32
  c2:	19 f0       	breq	.+6      	; 0xca <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE6odReadEhh.isra.1+0xa>
  c4:	80 34       	cpi	r24, 0x40	; 64
  c6:	31 f0       	breq	.+12     	; 0xd4 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE6odReadEhh.isra.1+0x14>
  c8:	0d c0       	rjmp	.+26     	; 0xe4 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE6odReadEhh.isra.1+0x24>
    {
    case IoLink::MC_CHNL_PAGE:  // Direct parameter page channel
        data = directParameter[address];
  ca:	e6 2f       	mov	r30, r22
  cc:	f0 e0       	ldi	r31, 0x00	; 0
  ce:	e5 5e       	subi	r30, 0xE5	; 229
  d0:	fe 4f       	sbci	r31, 0xFE	; 254
  d2:	06 c0       	rjmp	.+12     	; 0xe0 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE6odReadEhh.isra.1+0x20>
        break;

    case IoLink::MC_CHNL_DIAG:  // Diagnosis channel
        if (address > 6)
  d4:	67 30       	cpi	r22, 0x07	; 7
  d6:	38 f4       	brcc	.+14     	; 0xe6 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE6odReadEhh.isra.1+0x26>
            break;

        data = eventPage[address];
  d8:	e6 2f       	mov	r30, r22
  da:	f0 e0       	ldi	r31, 0x00	; 0
  dc:	ed 5e       	subi	r30, 0xED	; 237
  de:	fe 4f       	sbci	r31, 0xFE	; 254
  e0:	90 81       	ld	r25, Z
  e2:	01 c0       	rjmp	.+2      	; 0xe6 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE6odReadEhh.isra.1+0x26>
        break;

    default:            // SPDU and process data not handled
//        ASSERT(address == IoLink::MC_ADDR_ISDU_IDLE1 || address == IoLink::MC_ADDR_ISDU_IDLE2);
        data = 0;
  e4:	90 e0       	ldi	r25, 0x00	; 0
    }

    return data;
}
  e6:	89 2f       	mov	r24, r25
  e8:	08 95       	ret

000000ea <__vector_15>:
    }
}

// Interrupt on Timer0 compare match B
ISR(TIMER0_COMPB_vect)
{
  ea:	1f 92       	push	r1
  ec:	0f 92       	push	r0
  ee:	0f b6       	in	r0, 0x3f	; 63
  f0:	0f 92       	push	r0
  f2:	11 24       	eor	r1, r1
  f4:	2f 93       	push	r18
  f6:	3f 93       	push	r19
  f8:	8f 93       	push	r24
  fa:	9f 93       	push	r25
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::onTimer0CompBInterrupt()
{
    // decrement hiZ timer
    if (_hiZCounter >= 0 && --_hiZCounter < 0)
  fc:	80 91 07 01 	lds	r24, 0x0107
 100:	87 fd       	sbrc	r24, 7
 102:	1d c0       	rjmp	.+58     	; 0x13e <__vector_15+0x54>
 104:	81 50       	subi	r24, 0x01	; 1
 106:	80 93 07 01 	sts	0x0107, r24
 10a:	8f 3f       	cpi	r24, 0xFF	; 255
 10c:	c1 f4       	brne	.+48     	; 0x13e <__vector_15+0x54>
uint8_t StackBase<T, PDI, PDO, SpiSsHndlr>::driveModeBits() const
{
    switch (StackT::SIO_DRIVE_MODE)
    {
    case DRIVE_MODE_PUSH_PULL:
        return _sioLevel ? Phy::CTL_HS : Phy::CTL_LS;
 10e:	80 91 08 01 	lds	r24, 0x0108
 112:	80 fd       	sbrc	r24, 0
 114:	26 c0       	rjmp	.+76     	; 0x162 <__vector_15+0x78>
 116:	81 e0       	ldi	r24, 0x01	; 1
    bool driven = (hslsBits != 0);

    // we need to switch to IO-Link mode after 1ms to detect a wake-up
    if (driven)
    {
        _hiZCounter = -1;
 118:	9f ef       	ldi	r25, 0xFF	; 255
 11a:	90 93 07 01 	sts	0x0107, r25
    else if (wasDriven)  
    {
        _hiZCounter = 10;
    }

    wasDriven = driven;
 11e:	91 e0       	ldi	r25, 0x01	; 1
 120:	90 93 00 01 	sts	0x0100, r25
    uint8_t sioBit = (!driven && (_hiZCounter < 0)) 
        ? Phy::CTL_IOLINK_MODE 
        : Phy::CTL_SIO_MODE;

    return StackBase::registerWrite(Phy::REG_CTL, 
        StackT::PHY_CTL_SCT | StackT::PHY_CTL_MODE | sioBit | hslsBits);
 124:	84 60       	ori	r24, 0x04	; 4
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 126:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 128:	92 e8       	ldi	r25, 0x82	; 130
 12a:	9e bd       	out	0x2e, r25	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 12c:	0d b4       	in	r0, 0x2d	; 45
 12e:	07 fe       	sbrs	r0, 7
 130:	fd cf       	rjmp	.-6      	; 0x12c <__vector_15+0x42>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 132:	9e b5       	in	r25, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 134:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 136:	0d b4       	in	r0, 0x2d	; 45
 138:	07 fe       	sbrs	r0, 7
 13a:	fd cf       	rjmp	.-6      	; 0x136 <__vector_15+0x4c>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 13c:	2a 9a       	sbi	0x05, 2	; 5
    {
        stack().setSioActive();
    }

    // check if cycle timer elapsed
    if (_cycleTimer > 0 && --_cycleTimer == 0)
 13e:	20 91 0d 01 	lds	r18, 0x010D
 142:	30 91 0e 01 	lds	r19, 0x010E
 146:	80 91 12 01 	lds	r24, 0x0112
 14a:	21 15       	cp	r18, r1
 14c:	31 05       	cpc	r19, r1
 14e:	59 f0       	breq	.+22     	; 0x166 <__vector_15+0x7c>
 150:	21 50       	subi	r18, 0x01	; 1
 152:	31 09       	sbc	r19, r1
 154:	30 93 0e 01 	sts	0x010E, r19
 158:	20 93 0d 01 	sts	0x010D, r18
 15c:	23 2b       	or	r18, r19
 15e:	39 f0       	breq	.+14     	; 0x16e <__vector_15+0x84>
 160:	02 c0       	rjmp	.+4      	; 0x166 <__vector_15+0x7c>
uint8_t StackBase<T, PDI, PDO, SpiSsHndlr>::driveModeBits() const
{
    switch (StackT::SIO_DRIVE_MODE)
    {
    case DRIVE_MODE_PUSH_PULL:
        return _sioLevel ? Phy::CTL_HS : Phy::CTL_LS;
 162:	82 e0       	ldi	r24, 0x02	; 2
 164:	d9 cf       	rjmp	.-78     	; 0x118 <__vector_15+0x2e>
        }
    }
    else
    {
        // too late for user code
        _runUserCode = false;
 166:	8e 7f       	andi	r24, 0xFE	; 254
 168:	80 93 12 01 	sts	0x0112, r24
 16c:	33 c0       	rjmp	.+102    	; 0x1d4 <__vector_15+0xea>

    // check if cycle timer elapsed
    if (_cycleTimer > 0 && --_cycleTimer == 0)
    {
        // user code may run
        _runUserCode = true;
 16e:	81 60       	ori	r24, 0x01	; 1
 170:	80 93 12 01 	sts	0x0112, r24

        // restart cycle timer
        _cycleTimer = _cyclePeriod;
 174:	80 91 0b 01 	lds	r24, 0x010B
 178:	90 91 0c 01 	lds	r25, 0x010C
 17c:	90 93 0e 01 	sts	0x010E, r25
 180:	80 93 0d 01 	sts	0x010D, r24

        // advance the count of dead cycles
        if (_deadCycleCtr != 0xff)
 184:	80 91 06 01 	lds	r24, 0x0106
 188:	8f 3f       	cpi	r24, 0xFF	; 255
 18a:	19 f0       	breq	.+6      	; 0x192 <__vector_15+0xa8>
        {
            ++_deadCycleCtr;
 18c:	8f 5f       	subi	r24, 0xFF	; 255
 18e:	80 93 06 01 	sts	0x0106, r24
        }

        // check if we need to switch to SIO mode
        if (_fallbackCounter > 0 && --_fallbackCounter == 0)
 192:	80 91 11 01 	lds	r24, 0x0111
 196:	88 23       	and	r24, r24
 198:	29 f0       	breq	.+10     	; 0x1a4 <__vector_15+0xba>
 19a:	81 50       	subi	r24, 0x01	; 1
 19c:	80 93 11 01 	sts	0x0111, r24
 1a0:	88 23       	and	r24, r24
 1a2:	a9 f0       	breq	.+42     	; 0x1ce <__vector_15+0xe4>
        {
            _ddlMode = IoLink::DDL_MODE_IDLE;
        }

        // update LED register if necessary
        if (_savedLedRegister != _ledRegister)
 1a4:	80 91 10 01 	lds	r24, 0x0110
 1a8:	90 91 0f 01 	lds	r25, 0x010F
 1ac:	98 17       	cp	r25, r24
 1ae:	91 f0       	breq	.+36     	; 0x1d4 <__vector_15+0xea>
        {
            _savedLedRegister = _ledRegister;
 1b0:	80 93 0f 01 	sts	0x010F, r24
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 1b4:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 1b6:	96 e8       	ldi	r25, 0x86	; 134
 1b8:	9e bd       	out	0x2e, r25	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 1ba:	0d b4       	in	r0, 0x2d	; 45
 1bc:	07 fe       	sbrs	r0, 7
 1be:	fd cf       	rjmp	.-6      	; 0x1ba <__vector_15+0xd0>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 1c0:	9e b5       	in	r25, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 1c2:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 1c4:	0d b4       	in	r0, 0x2d	; 45
 1c6:	07 fe       	sbrs	r0, 7
 1c8:	fd cf       	rjmp	.-6      	; 0x1c4 <__vector_15+0xda>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 1ca:	2a 9a       	sbi	0x05, 2	; 5
 1cc:	03 c0       	rjmp	.+6      	; 0x1d4 <__vector_15+0xea>
        }

        // check if we need to switch to SIO mode
        if (_fallbackCounter > 0 && --_fallbackCounter == 0)
        {
            _ddlMode = IoLink::DDL_MODE_IDLE;
 1ce:	10 92 01 01 	sts	0x0101, r1
 1d2:	e8 cf       	rjmp	.-48     	; 0x1a4 <__vector_15+0xba>
    StackMultiByte::instance.onTimer0CompBInterrupt();
}
 1d4:	9f 91       	pop	r25
 1d6:	8f 91       	pop	r24
 1d8:	3f 91       	pop	r19
 1da:	2f 91       	pop	r18
 1dc:	0f 90       	pop	r0
 1de:	0f be       	out	0x3f, r0	; 63
 1e0:	0f 90       	pop	r0
 1e2:	1f 90       	pop	r1
 1e4:	18 95       	reti

000001e6 <_ZN9PhyDriverI16DefaultSsHandlerE19registerAbortAccessEv>:

//------------------------------------------------------------------------------
template <class SpiSsHndlr> 
void PhyDriver<SpiSsHndlr>::registerAbortAccess()
{
    if (_ssHndlr.asserted())
 1e6:	2a 99       	sbic	0x05, 2	; 5
 1e8:	04 c0       	rjmp	.+8      	; 0x1f2 <_ZN9PhyDriverI16DefaultSsHandlerE19registerAbortAccessEv+0xc>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 1ea:	0d b4       	in	r0, 0x2d	; 45
 1ec:	07 fe       	sbrs	r0, 7
 1ee:	fd cf       	rjmp	.-6      	; 0x1ea <_ZN9PhyDriverI16DefaultSsHandlerE19registerAbortAccessEv+0x4>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 1f0:	2a 9a       	sbi	0x05, 2	; 5
 1f2:	08 95       	ret

000001f4 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE12configurePhyEv>:
    startCallbackTimer();
};

//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::configurePhy()
 1f4:	fc 01       	movw	r30, r24
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 1f6:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 1f8:	80 e8       	ldi	r24, 0x80	; 128
 1fa:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 1fc:	0d b4       	in	r0, 0x2d	; 45
 1fe:	07 fe       	sbrs	r0, 7
 200:	fd cf       	rjmp	.-6      	; 0x1fc <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE12configurePhyEv+0x8>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 202:	8c e0       	ldi	r24, 0x0C	; 12
 204:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 206:	0d b4       	in	r0, 0x2d	; 45
 208:	07 fe       	sbrs	r0, 7
 20a:	fd cf       	rjmp	.-6      	; 0x206 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE12configurePhyEv+0x12>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 20c:	82 e2       	ldi	r24, 0x22	; 34
 20e:	8e bd       	out	0x2e, r24	; 46
uint8_t StackBase<T, PDI, PDO, SpiSsHndlr>::driveModeBits() const
{
    switch (StackT::SIO_DRIVE_MODE)
    {
    case DRIVE_MODE_PUSH_PULL:
        return _sioLevel ? Phy::CTL_HS : Phy::CTL_LS;
 210:	87 81       	ldd	r24, Z+7	; 0x07
 212:	80 fd       	sbrc	r24, 0
 214:	02 c0       	rjmp	.+4      	; 0x21a <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE12configurePhyEv+0x26>
 216:	91 e0       	ldi	r25, 0x01	; 1
 218:	01 c0       	rjmp	.+2      	; 0x21c <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE12configurePhyEv+0x28>
 21a:	92 e0       	ldi	r25, 0x02	; 2
    
    // REG_CTL
    StackBase::registerWriteNext(StackT::PHY_CTL_SCT | 
                                 StackT::PHY_CTL_MODE | 
                                 Phy::CTL_SIO_MODE | 
                                 driveModeBits());
 21c:	94 60       	ori	r25, 0x04	; 4
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 21e:	0d b4       	in	r0, 0x2d	; 45
 220:	07 fe       	sbrs	r0, 7
 222:	fd cf       	rjmp	.-6      	; 0x21e <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE12configurePhyEv+0x2a>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 224:	9e bd       	out	0x2e, r25	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 226:	0d b4       	in	r0, 0x2d	; 45
 228:	07 fe       	sbrs	r0, 7
 22a:	fd cf       	rjmp	.-6      	; 0x226 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE12configurePhyEv+0x32>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 22c:	1e bc       	out	0x2e, r1	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 22e:	0d b4       	in	r0, 0x2d	; 45
 230:	07 fe       	sbrs	r0, 7
 232:	fd cf       	rjmp	.-6      	; 0x22e <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE12configurePhyEv+0x3a>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 234:	83 e0       	ldi	r24, 0x03	; 3
 236:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 238:	0d b4       	in	r0, 0x2d	; 45
 23a:	07 fe       	sbrs	r0, 7
 23c:	fd cf       	rjmp	.-6      	; 0x238 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE12configurePhyEv+0x44>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 23e:	1e bc       	out	0x2e, r1	; 46
    
    // REG_STATUS (HMT7742) / REG_TEMP (HMT7748) - (dummy write)
    Phy::registerWriteNext(0);        
    
    // LEDs
    StackBase::registerWriteNext(this->_ledRegister);        
 240:	87 85       	ldd	r24, Z+15	; 0x0f
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 242:	0d b4       	in	r0, 0x2d	; 45
 244:	07 fe       	sbrs	r0, 7
 246:	fd cf       	rjmp	.-6      	; 0x242 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE12configurePhyEv+0x4e>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 248:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 24a:	0d b4       	in	r0, 0x2d	; 45
 24c:	07 fe       	sbrs	r0, 7
 24e:	fd cf       	rjmp	.-6      	; 0x24a <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE12configurePhyEv+0x56>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 250:	2a 9a       	sbi	0x05, 2	; 5
#endif

    registerWriteDone();

    // set the stack to SIO mode to be in sync with the PHY.
    _ddlMode = IoLink::DDL_MODE_IDLE;
 252:	10 82       	st	Z, r1
 254:	08 95       	ret

00000256 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE18startCallbackTimerEh>:
}


//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::startCallbackTimer(uint8_t delay)
 256:	fc 01       	movw	r30, r24
{
    // reset dead cycle timer
    _deadCycleCtr = 0;
 258:	15 82       	std	Z+5, r1	; 0x05

    // disable timer
    TCCR0B = 0;
 25a:	15 bc       	out	0x25, r1	; 37
    TCNT0 = 0;
 25c:	16 bc       	out	0x26, r1	; 38

    // clear any outstanding interrupt requests
    TIFR0 |= _BV(OCF0B) | _BV(OCF0A) | _BV(TOV0);
 25e:	85 b3       	in	r24, 0x15	; 21
 260:	87 60       	ori	r24, 0x07	; 7
 262:	85 bb       	out	0x15, r24	; 21
    
    // check if we need to force recalculation of cycle period
    if (_cyclePeriod == 0)
 264:	82 85       	ldd	r24, Z+10	; 0x0a
 266:	93 85       	ldd	r25, Z+11	; 0x0b
 268:	00 97       	sbiw	r24, 0x00	; 0
 26a:	49 f5       	brne	.+82     	; 0x2be <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE18startCallbackTimerEh+0x68>
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::updateCyclePeriod()
{
    // get period
    uint8_t cycleParam = 0;
    if (_ddlMode == IoLink::DDL_MODE_OPERATE)
 26c:	20 81       	ld	r18, Z
 26e:	24 30       	cpi	r18, 0x04	; 4
 270:	21 f4       	brne	.+8      	; 0x27a <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE18startCallbackTimerEh+0x24>
     * 
     * \param address   Parameter index
     * \return          Read value
     * 
     */
    uint8_t             parameterRead(uint8_t address) const { return directParameter[address]; }
 272:	20 91 1c 01 	lds	r18, 0x011C
    if (_ddlMode == IoLink::DDL_MODE_OPERATE)
    {
        cycleParam = parameterRead(IoLink::PAGE_MASTER_CYCLE_TIME);
    }

    if (cycleParam == 0)
 276:	21 11       	cpse	r18, r1
 278:	02 c0       	rjmp	.+4      	; 0x27e <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE18startCallbackTimerEh+0x28>
     * 
     * \param address   Parameter index
     * \return          Read value
     * 
     */
    uint8_t             parameterRead(uint8_t address) const { return directParameter[address]; }
 27a:	20 91 1d 01 	lds	r18, 0x011D
        // MasterCycleTime hasn't been set yet => use MinCycleTime
        cycleParam = parameterRead(IoLink::PAGE_MIN_CYCLE_TIME);
    }

    // decode parameter into 1/10ms
    _cyclePeriod = DECODE_CYCLE_TIME(cycleParam);
 27e:	24 30       	cpi	r18, 0x04	; 4
 280:	e0 f0       	brcs	.+56     	; 0x2ba <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE18startCallbackTimerEh+0x64>
 282:	20 34       	cpi	r18, 0x40	; 64
 284:	18 f4       	brcc	.+6      	; 0x28c <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE18startCallbackTimerEh+0x36>
 286:	82 2f       	mov	r24, r18
 288:	90 e0       	ldi	r25, 0x00	; 0
 28a:	17 c0       	rjmp	.+46     	; 0x2ba <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE18startCallbackTimerEh+0x64>
 28c:	32 2f       	mov	r19, r18
 28e:	30 7c       	andi	r19, 0xC0	; 192
 290:	30 34       	cpi	r19, 0x40	; 64
 292:	49 f4       	brne	.+18     	; 0x2a6 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE18startCallbackTimerEh+0x50>
 294:	84 e0       	ldi	r24, 0x04	; 4
 296:	28 9f       	mul	r18, r24
 298:	90 01       	movw	r18, r0
 29a:	11 24       	eor	r1, r1
 29c:	33 27       	eor	r19, r19
 29e:	c9 01       	movw	r24, r18
 2a0:	80 5c       	subi	r24, 0xC0	; 192
 2a2:	9f 4f       	sbci	r25, 0xFF	; 255
 2a4:	0a c0       	rjmp	.+20     	; 0x2ba <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE18startCallbackTimerEh+0x64>
 2a6:	30 38       	cpi	r19, 0x80	; 128
 2a8:	41 f4       	brne	.+16     	; 0x2ba <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE18startCallbackTimerEh+0x64>
 2aa:	2f 73       	andi	r18, 0x3F	; 63
 2ac:	80 e1       	ldi	r24, 0x10	; 16
 2ae:	28 9f       	mul	r18, r24
 2b0:	90 01       	movw	r18, r0
 2b2:	11 24       	eor	r1, r1
 2b4:	c9 01       	movw	r24, r18
 2b6:	80 5c       	subi	r24, 0xC0	; 192
 2b8:	9e 4f       	sbci	r25, 0xFE	; 254
 2ba:	93 87       	std	Z+11, r25	; 0x0b
 2bc:	82 87       	std	Z+10, r24	; 0x0a
    {
        updateCyclePeriod();
    }

    // initialize cycle timer
    _cycleTimer = delay + 1;
 2be:	70 e0       	ldi	r23, 0x00	; 0
 2c0:	6f 5f       	subi	r22, 0xFF	; 255
 2c2:	7f 4f       	sbci	r23, 0xFF	; 255
 2c4:	75 87       	std	Z+13, r23	; 0x0d
 2c6:	64 87       	std	Z+12, r22	; 0x0c

    if (_cycleTimer > 0)
    {      
        // Timer/Counter0 Output Compare Match B Interrupt Enable
        TIMSK0 = _BV(OCIE0B);
 2c8:	84 e0       	ldi	r24, 0x04	; 4
 2ca:	80 93 6e 00 	sts	0x006E, r24

        // clear Timer on Compare Match A
        TCCR0A = _BV(WGM01);
 2ce:	82 e0       	ldi	r24, 0x02	; 2
 2d0:	84 bd       	out	0x24, r24	; 36

        // generate 0.1ms cycles
#if F_CPU < 20000000
        OCR0B = OCR0A = F_CPU / 80000;
 2d2:	94 e6       	ldi	r25, 0x64	; 100
 2d4:	97 bd       	out	0x27, r25	; 39
 2d6:	98 bd       	out	0x28, r25	; 40
        TCCR0B = _BV(CS01);             // pre-scaler clkIO/8
 2d8:	85 bd       	out	0x25, r24	; 37
 2da:	08 95       	ret

000002dc <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh>:

StackMultiByte StackMultiByte::instance;

//------------------------------------------------------------------------------
template <IoLink::DeviceDLMode DDL_MODE>
StackMultiByte::HandlerResult StackMultiByte::handleOperatingMode(uint8_t mc)
 2dc:	cf 93       	push	r28
 2de:	df 93       	push	r29
 2e0:	ec 01       	movw	r28, r24
 2e2:	96 2f       	mov	r25, r22
{
    // get access mode, channel and address from MC octet
    const uint8_t access  = mc & IoLink::MC_RW_MASK;
    const uint8_t channel = mc & IoLink::MC_CHANNEL_MASK;
 2e4:	86 2f       	mov	r24, r22
 2e6:	80 76       	andi	r24, 0x60	; 96
    const uint8_t address = mc & IoLink::MC_ADDRESS_MASK;
 2e8:	6f 71       	andi	r22, 0x1F	; 31
    const int8_t odCount = getOdOctetCount<DDL_MODE>();
    const uint8_t pdInSize = DDL_MODE == IoLink::DDL_MODE_OPERATE ? PD_IN_SIZE : 0;
    const uint8_t pdOutSize = DDL_MODE == IoLink::DDL_MODE_OPERATE ? PD_OUT_SIZE : 0;

    if (access == IoLink::MC_WRITE)
 2ea:	97 fd       	sbrc	r25, 7
 2ec:	49 c0       	rjmp	.+146    	; 0x380 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xa4>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 2ee:	0d b4       	in	r0, 0x2d	; 45
 2f0:	07 fe       	sbrs	r0, 7
 2f2:	fd cf       	rjmp	.-6      	; 0x2ee <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x12>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 2f4:	9e b5       	in	r25, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 2f6:	9e bd       	out	0x2e, r25	; 46
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
template <IoLink::DeviceDLMode DDL_MODE>
bool StackBase<T, PDI, PDO, SpiSsHndlr>::validateFrameType(uint8_t ckt)
{
    uint8_t frameType = (ckt & IoLink::CKT_TYPE_MASK);
 2f8:	90 7c       	andi	r25, 0xC0	; 192
                if (frameType == IoLink::CKT_TYPE_2)
                    return true;                                   // TYPE_2_1-2_5
            }
            else if ((StackT::REVISION_ID == IoLink::REVISION_ID_1_1) && (PD_OUT_SIZE + PD_IN_SIZE <= 4))
            {
                if (frameType == IoLink::CKT_TYPE_2)
 2fa:	90 38       	cpi	r25, 0x80	; 128
 2fc:	11 f0       	breq	.+4      	; 0x302 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x26>
    {
        // get checksum/type octet
        uint8_t ckt = registerReadNext();
        if (!validateFrameType<DDL_MODE>(ckt))
            return ResultIllegalMessageType;
 2fe:	83 e0       	ldi	r24, 0x03	; 3
 300:	7f c0       	rjmp	.+254    	; 0x400 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x124>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 302:	0d b4       	in	r0, 0x2d	; 45
 304:	07 fe       	sbrs	r0, 7
 306:	fd cf       	rjmp	.-6      	; 0x302 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x26>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 308:	9e b5       	in	r25, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 30a:	9e bd       	out	0x2e, r25	; 46

        // read process output data
        for (uint8_t i = 0; i < pdOutSize; ++i)
        {
            _processDataOut.buffer[i] = registerReadNext();
 30c:	9b 83       	std	Y+3, r25	; 0x03
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 30e:	0d b4       	in	r0, 0x2d	; 45
 310:	07 fe       	sbrs	r0, 7
 312:	fd cf       	rjmp	.-6      	; 0x30e <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x32>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 314:	2e b5       	in	r18, 0x2e	; 46
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 316:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 318:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 31a:	90 e9       	ldi	r25, 0x90	; 144
 31c:	9e bd       	out	0x2e, r25	; 46
 31e:	99 89       	ldd	r25, Y+17	; 0x11

//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::odWrite(uint8_t channel, uint8_t address, uint8_t data)
{
    if (channel == IoLink::MC_CHNL_PAGE)
 320:	80 32       	cpi	r24, 0x20	; 32
 322:	51 f4       	brne	.+20     	; 0x338 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x5c>
    {
        // store data for use in application
        _parameterWrite.address = address;
 324:	68 87       	std	Y+8, r22	; 0x08
        _parameterWrite.value = data;
 326:	29 87       	std	Y+9, r18	; 0x09
        _prmWriteAvailable = true;
 328:	89 2f       	mov	r24, r25
 32a:	82 60       	ori	r24, 0x02	; 2
 32c:	89 8b       	std	Y+17, r24	; 0x11
        odWrite(channel, address, od);

        // send PDin data
        for (uint8_t i = 0; i < pdInSize; ++i)
        {
            registerWriteNext(_processDataIn.isValid ? _processDataIn.buffer[i] : 0);
 32e:	8a 81       	ldd	r24, Y+2	; 0x02
 330:	88 23       	and	r24, r24
 332:	29 f0       	breq	.+10     	; 0x33e <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x62>
 334:	89 81       	ldd	r24, Y+1	; 0x01
 336:	03 c0       	rjmp	.+6      	; 0x33e <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x62>
    }
    else
    {
        _prmWriteAvailable = false;
 338:	89 2f       	mov	r24, r25
 33a:	8d 7f       	andi	r24, 0xFD	; 253
 33c:	f7 cf       	rjmp	.-18     	; 0x32c <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x50>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 33e:	0d b4       	in	r0, 0x2d	; 45
 340:	07 fe       	sbrs	r0, 7
 342:	fd cf       	rjmp	.-6      	; 0x33e <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x62>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 344:	8e bd       	out	0x2e, r24	; 46
        }

        // send the CKS octet, note the checksum field is set to 0
        registerWriteNext((pdInSize > 0 && _processDataIn.isValid) ? 
            IoLink::CKS_PD_VALID : IoLink::CKS_PD_INVALID);
 346:	8a 81       	ldd	r24, Y+2	; 0x02
 348:	81 11       	cpse	r24, r1
 34a:	02 c0       	rjmp	.+4      	; 0x350 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x74>
 34c:	80 e4       	ldi	r24, 0x40	; 64
 34e:	01 c0       	rjmp	.+2      	; 0x352 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x76>
 350:	80 e0       	ldi	r24, 0x00	; 0
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 352:	0d b4       	in	r0, 0x2d	; 45
 354:	07 fe       	sbrs	r0, 7
 356:	fd cf       	rjmp	.-6      	; 0x352 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x76>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 358:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 35a:	0d b4       	in	r0, 0x2d	; 45
 35c:	07 fe       	sbrs	r0, 7
 35e:	fd cf       	rjmp	.-6      	; 0x35a <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x7e>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 360:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 362:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 364:	83 e8       	ldi	r24, 0x83	; 131
 366:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 368:	0d b4       	in	r0, 0x2d	; 45
 36a:	07 fe       	sbrs	r0, 7
 36c:	fd cf       	rjmp	.-6      	; 0x368 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x8c>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 36e:	8e b5       	in	r24, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 370:	89 e0       	ldi	r24, 0x09	; 9
 372:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 374:	0d b4       	in	r0, 0x2d	; 45
 376:	07 fe       	sbrs	r0, 7
 378:	fd cf       	rjmp	.-6      	; 0x374 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x98>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 37a:	2a 9a       	sbi	0x05, 2	; 5
    {
        startCallbackTimer((octetCnt + 1) * 14 / 23 /* approx 230.4 / 10 */);
    }
    else // CFG_BD_38400
    {
        startCallbackTimer((octetCnt) * 14 / 4 /* approx. 38.4 / 10 */);
 37c:	67 e0       	ldi	r22, 0x07	; 7
 37e:	3d c0       	rjmp	.+122    	; 0x3fa <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x11e>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 380:	0d b4       	in	r0, 0x2d	; 45
 382:	07 fe       	sbrs	r0, 7
 384:	fd cf       	rjmp	.-6      	; 0x380 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xa4>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 386:	9e b5       	in	r25, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 388:	9e bd       	out	0x2e, r25	; 46
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
template <IoLink::DeviceDLMode DDL_MODE>
bool StackBase<T, PDI, PDO, SpiSsHndlr>::validateFrameType(uint8_t ckt)
{
    uint8_t frameType = (ckt & IoLink::CKT_TYPE_MASK);
 38a:	90 7c       	andi	r25, 0xC0	; 192
    else // IoLink::MC_READ
    {
        // get checksum/type octet
        uint8_t ckt = (pdOutSize > 0) ? registerReadNext() : registerReadLast();

        if (!validateFrameType<DDL_MODE>(ckt))
 38c:	90 38       	cpi	r25, 0x80	; 128
 38e:	09 f0       	breq	.+2      	; 0x392 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xb6>
 390:	b6 cf       	rjmp	.-148    	; 0x2fe <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x22>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 392:	0d b4       	in	r0, 0x2d	; 45
 394:	07 fe       	sbrs	r0, 7
 396:	fd cf       	rjmp	.-6      	; 0x392 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xb6>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 398:	9e b5       	in	r25, 0x2e	; 46
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 39a:	2a 9a       	sbi	0x05, 2	; 5
        {
            for (uint8_t i = 0; i < pdOutSize-1; ++i)
            {
                _processDataOut.buffer[i] = registerReadNext();
            }
            _processDataOut.buffer[pdOutSize-1] = registerReadLast();
 39c:	9b 83       	std	Y+3, r25	; 0x03
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 39e:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 3a0:	90 e9       	ldi	r25, 0x90	; 144
 3a2:	9e bd       	out	0x2e, r25	; 46

        // start sending the return data
        registerWriteBegin(REG_FR0);

        // send OD data
        registerWriteNext(odRead(channel, address));
 3a4:	8d de       	rcall	.-742    	; 0xc0 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE6odReadEhh.isra.1>
 3a6:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 3a8:	07 fe       	sbrs	r0, 7
 3aa:	fd cf       	rjmp	.-6      	; 0x3a6 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xca>
 3ac:	8e bd       	out	0x2e, r24	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 3ae:	8a 81       	ldd	r24, Y+2	; 0x02
        }

        // send PDin data
        for (uint8_t i = 0; i < pdInSize; ++i)
        {
            registerWriteNext(_processDataIn.isValid ? _processDataIn.buffer[i] : 0);
 3b0:	88 23       	and	r24, r24
 3b2:	11 f0       	breq	.+4      	; 0x3b8 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xdc>
 3b4:	89 81       	ldd	r24, Y+1	; 0x01
 3b6:	01 c0       	rjmp	.+2      	; 0x3ba <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xde>
 3b8:	80 e0       	ldi	r24, 0x00	; 0
 3ba:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 3bc:	07 fe       	sbrs	r0, 7
 3be:	fd cf       	rjmp	.-6      	; 0x3ba <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xde>
 3c0:	8e bd       	out	0x2e, r24	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 3c2:	8a 81       	ldd	r24, Y+2	; 0x02
        }

        // send the CKS octet, note the checksum field is set to 0
        registerWriteNext((pdInSize > 0 && _processDataIn.isValid) ? 
            IoLink::CKS_PD_VALID : IoLink::CKS_PD_INVALID);
 3c4:	81 11       	cpse	r24, r1
 3c6:	02 c0       	rjmp	.+4      	; 0x3cc <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xf0>
 3c8:	80 e4       	ldi	r24, 0x40	; 64
 3ca:	01 c0       	rjmp	.+2      	; 0x3ce <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xf2>
 3cc:	80 e0       	ldi	r24, 0x00	; 0
 3ce:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 3d0:	07 fe       	sbrs	r0, 7
 3d2:	fd cf       	rjmp	.-6      	; 0x3ce <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xf2>
 3d4:	8e bd       	out	0x2e, r24	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 3d6:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 3d8:	07 fe       	sbrs	r0, 7
 3da:	fd cf       	rjmp	.-6      	; 0x3d6 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xfa>
 3dc:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 3de:	2a 98       	cbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 3e0:	83 e8       	ldi	r24, 0x83	; 131
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 3e2:	8e bd       	out	0x2e, r24	; 46
 3e4:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 3e6:	07 fe       	sbrs	r0, 7
 3e8:	fd cf       	rjmp	.-6      	; 0x3e4 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x108>
 3ea:	8e b5       	in	r24, 0x2e	; 46
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 3ec:	8d e0       	ldi	r24, 0x0D	; 13
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 3ee:	8e bd       	out	0x2e, r24	; 46
 3f0:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 3f2:	07 fe       	sbrs	r0, 7
 3f4:	fd cf       	rjmp	.-6      	; 0x3f0 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x114>
 3f6:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 3f8:	6a e0       	ldi	r22, 0x0A	; 10
    {
        startCallbackTimer((octetCnt + 1) * 14 / 23 /* approx 230.4 / 10 */);
    }
    else // CFG_BD_38400
    {
        startCallbackTimer((octetCnt) * 14 / 4 /* approx. 38.4 / 10 */);
 3fa:	ce 01       	movw	r24, r28
 3fc:	2c df       	rcall	.-424    	; 0x256 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE18startCallbackTimerEh>
 3fe:	80 e0       	ldi	r24, 0x00	; 0
 400:	df 91       	pop	r29
        // if IDLE, enter STARTUP state
        _ddlMode = IoLink::DDL_MODE_STARTUP;
        setIoLinkListen();
    }

    return ResultSuccess;
 402:	cf 91       	pop	r28
}
 404:	08 95       	ret

00000406 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh>:
 406:	cf 93       	push	r28
 408:	df 93       	push	r29

StackMultiByte StackMultiByte::instance;

//------------------------------------------------------------------------------
template <IoLink::DeviceDLMode DDL_MODE>
StackMultiByte::HandlerResult StackMultiByte::handleOperatingMode(uint8_t mc)
 40a:	ec 01       	movw	r28, r24
 40c:	96 2f       	mov	r25, r22
{
    // get access mode, channel and address from MC octet
    const uint8_t access  = mc & IoLink::MC_RW_MASK;
    const uint8_t channel = mc & IoLink::MC_CHANNEL_MASK;
 40e:	86 2f       	mov	r24, r22
 410:	80 76       	andi	r24, 0x60	; 96
    const uint8_t address = mc & IoLink::MC_ADDRESS_MASK;
 412:	6f 71       	andi	r22, 0x1F	; 31
    const int8_t odCount = getOdOctetCount<DDL_MODE>();
    const uint8_t pdInSize = DDL_MODE == IoLink::DDL_MODE_OPERATE ? PD_IN_SIZE : 0;
    const uint8_t pdOutSize = DDL_MODE == IoLink::DDL_MODE_OPERATE ? PD_OUT_SIZE : 0;

    if (access == IoLink::MC_WRITE)
 414:	97 fd       	sbrc	r25, 7
 416:	32 c0       	rjmp	.+100    	; 0x47c <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x76>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 418:	0d b4       	in	r0, 0x2d	; 45
 41a:	07 fe       	sbrs	r0, 7
 41c:	fd cf       	rjmp	.-6      	; 0x418 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x12>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 41e:	9e b5       	in	r25, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 420:	9e bd       	out	0x2e, r25	; 46
 422:	90 7c       	andi	r25, 0xC0	; 192
    {
        // get checksum/type octet
        uint8_t ckt = registerReadNext();
        if (!validateFrameType<DDL_MODE>(ckt))
 424:	11 f0       	breq	.+4      	; 0x42a <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x24>
            return ResultIllegalMessageType;
 426:	83 e0       	ldi	r24, 0x03	; 3
 428:	52 c0       	rjmp	.+164    	; 0x4ce <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xc8>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 42a:	0d b4       	in	r0, 0x2d	; 45
 42c:	07 fe       	sbrs	r0, 7
 42e:	fd cf       	rjmp	.-6      	; 0x42a <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x24>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 430:	2e b5       	in	r18, 0x2e	; 46
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 432:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 434:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 436:	90 e9       	ldi	r25, 0x90	; 144
 438:	9e bd       	out	0x2e, r25	; 46
 43a:	99 89       	ldd	r25, Y+17	; 0x11

//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::odWrite(uint8_t channel, uint8_t address, uint8_t data)
{
    if (channel == IoLink::MC_CHNL_PAGE)
 43c:	80 32       	cpi	r24, 0x20	; 32
 43e:	21 f4       	brne	.+8      	; 0x448 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x42>
    {
        // store data for use in application
        _parameterWrite.address = address;
 440:	68 87       	std	Y+8, r22	; 0x08
        _parameterWrite.value = data;
 442:	29 87       	std	Y+9, r18	; 0x09
        _prmWriteAvailable = true;
 444:	92 60       	ori	r25, 0x02	; 2
 446:	01 c0       	rjmp	.+2      	; 0x44a <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x44>
    }
    else
    {
        _prmWriteAvailable = false;
 448:	9d 7f       	andi	r25, 0xFD	; 253
 44a:	99 8b       	std	Y+17, r25	; 0x11
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 44c:	0d b4       	in	r0, 0x2d	; 45
 44e:	07 fe       	sbrs	r0, 7
 450:	fd cf       	rjmp	.-6      	; 0x44c <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x46>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 452:	80 e4       	ldi	r24, 0x40	; 64
 454:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 456:	0d b4       	in	r0, 0x2d	; 45
 458:	07 fe       	sbrs	r0, 7
 45a:	fd cf       	rjmp	.-6      	; 0x456 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x50>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 45c:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 45e:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 460:	83 e8       	ldi	r24, 0x83	; 131
 462:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 464:	0d b4       	in	r0, 0x2d	; 45
 466:	07 fe       	sbrs	r0, 7
 468:	fd cf       	rjmp	.-6      	; 0x464 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x5e>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 46a:	8e b5       	in	r24, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 46c:	85 e0       	ldi	r24, 0x05	; 5
 46e:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 470:	0d b4       	in	r0, 0x2d	; 45
 472:	07 fe       	sbrs	r0, 7
 474:	fd cf       	rjmp	.-6      	; 0x470 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x6a>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 476:	2a 9a       	sbi	0x05, 2	; 5
    {
        startCallbackTimer((octetCnt + 1) * 14 / 23 /* approx 230.4 / 10 */);
    }
    else // CFG_BD_38400
    {
        startCallbackTimer((octetCnt) * 14 / 4 /* approx. 38.4 / 10 */);
 478:	63 e0       	ldi	r22, 0x03	; 3
 47a:	26 c0       	rjmp	.+76     	; 0x4c8 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xc2>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 47c:	0d b4       	in	r0, 0x2d	; 45
 47e:	07 fe       	sbrs	r0, 7
 480:	fd cf       	rjmp	.-6      	; 0x47c <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x76>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 482:	9e b5       	in	r25, 0x2e	; 46
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 484:	2a 9a       	sbi	0x05, 2	; 5
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
template <IoLink::DeviceDLMode DDL_MODE>
bool StackBase<T, PDI, PDO, SpiSsHndlr>::validateFrameType(uint8_t ckt)
{
    uint8_t frameType = (ckt & IoLink::CKT_TYPE_MASK);
 486:	90 7c       	andi	r25, 0xC0	; 192
        // see table A.8
    case IoLink::DDL_MODE_PREOPERATE:
        switch (StackT::MSEQ_CAPABILITY & IoLink::MSEQCAP_PREOP_MASK)
        {
        case IoLink::MSEQCAP_PREOP_CODE_0: 
            if (frameType == IoLink::CKT_TYPE_0) 
 488:	71 f6       	brne	.-100    	; 0x426 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x20>
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 48a:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 48c:	90 e9       	ldi	r25, 0x90	; 144
 48e:	9e bd       	out	0x2e, r25	; 46

        // start sending the return data
        registerWriteBegin(REG_FR0);

        // send OD data
        registerWriteNext(odRead(channel, address));
 490:	17 de       	rcall	.-978    	; 0xc0 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE6odReadEhh.isra.1>
 492:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 494:	07 fe       	sbrs	r0, 7
 496:	fd cf       	rjmp	.-6      	; 0x492 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x8c>
 498:	8e bd       	out	0x2e, r24	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 49a:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 49c:	07 fe       	sbrs	r0, 7
 49e:	fd cf       	rjmp	.-6      	; 0x49a <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x94>
 4a0:	80 e4       	ldi	r24, 0x40	; 64
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 4a2:	8e bd       	out	0x2e, r24	; 46
 4a4:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 4a6:	07 fe       	sbrs	r0, 7
 4a8:	fd cf       	rjmp	.-6      	; 0x4a4 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x9e>
 4aa:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 4ac:	2a 98       	cbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 4ae:	83 e8       	ldi	r24, 0x83	; 131
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 4b0:	8e bd       	out	0x2e, r24	; 46
 4b2:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 4b4:	07 fe       	sbrs	r0, 7
 4b6:	fd cf       	rjmp	.-6      	; 0x4b2 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xac>
 4b8:	8e b5       	in	r24, 0x2e	; 46
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 4ba:	89 e0       	ldi	r24, 0x09	; 9
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 4bc:	8e bd       	out	0x2e, r24	; 46
 4be:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 4c0:	07 fe       	sbrs	r0, 7
 4c2:	fd cf       	rjmp	.-6      	; 0x4be <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xb8>
 4c4:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 4c6:	67 e0       	ldi	r22, 0x07	; 7
    {
        startCallbackTimer((octetCnt + 1) * 14 / 23 /* approx 230.4 / 10 */);
    }
    else // CFG_BD_38400
    {
        startCallbackTimer((octetCnt) * 14 / 4 /* approx. 38.4 / 10 */);
 4c8:	ce 01       	movw	r24, r28
 4ca:	c5 de       	rcall	.-630    	; 0x256 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE18startCallbackTimerEh>
 4cc:	80 e0       	ldi	r24, 0x00	; 0
 4ce:	df 91       	pop	r29
        // if IDLE, enter STARTUP state
        _ddlMode = IoLink::DDL_MODE_STARTUP;
        setIoLinkListen();
    }

    return ResultSuccess;
 4d0:	cf 91       	pop	r28
}
 4d2:	08 95       	ret

000004d4 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh>:
 4d4:	cf 93       	push	r28
 4d6:	df 93       	push	r29

StackMultiByte StackMultiByte::instance;

//------------------------------------------------------------------------------
template <IoLink::DeviceDLMode DDL_MODE>
StackMultiByte::HandlerResult StackMultiByte::handleOperatingMode(uint8_t mc)
 4d8:	ec 01       	movw	r28, r24
 4da:	96 2f       	mov	r25, r22
{
    // get access mode, channel and address from MC octet
    const uint8_t access  = mc & IoLink::MC_RW_MASK;
    const uint8_t channel = mc & IoLink::MC_CHANNEL_MASK;
 4dc:	86 2f       	mov	r24, r22
 4de:	80 76       	andi	r24, 0x60	; 96
    const uint8_t address = mc & IoLink::MC_ADDRESS_MASK;
 4e0:	6f 71       	andi	r22, 0x1F	; 31
    const int8_t odCount = getOdOctetCount<DDL_MODE>();
    const uint8_t pdInSize = DDL_MODE == IoLink::DDL_MODE_OPERATE ? PD_IN_SIZE : 0;
    const uint8_t pdOutSize = DDL_MODE == IoLink::DDL_MODE_OPERATE ? PD_OUT_SIZE : 0;

    if (access == IoLink::MC_WRITE)
 4e2:	97 fd       	sbrc	r25, 7
 4e4:	34 c0       	rjmp	.+104    	; 0x54e <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x7a>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 4e6:	0d b4       	in	r0, 0x2d	; 45
 4e8:	07 fe       	sbrs	r0, 7
 4ea:	fd cf       	rjmp	.-6      	; 0x4e6 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x12>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 4ec:	9e b5       	in	r25, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 4ee:	9e bd       	out	0x2e, r25	; 46
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
template <IoLink::DeviceDLMode DDL_MODE>
bool StackBase<T, PDI, PDO, SpiSsHndlr>::validateFrameType(uint8_t ckt)
{
    uint8_t frameType = (ckt & IoLink::CKT_TYPE_MASK);
 4f0:	90 7c       	andi	r25, 0xC0	; 192
    {
        // get checksum/type octet
        uint8_t ckt = registerReadNext();
        if (!validateFrameType<DDL_MODE>(ckt))
 4f2:	11 f0       	breq	.+4      	; 0x4f8 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x24>
            return ResultIllegalMessageType;
 4f4:	83 e0       	ldi	r24, 0x03	; 3
 4f6:	65 c0       	rjmp	.+202    	; 0x5c2 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xee>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 4f8:	0d b4       	in	r0, 0x2d	; 45
 4fa:	07 fe       	sbrs	r0, 7
 4fc:	fd cf       	rjmp	.-6      	; 0x4f8 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x24>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 4fe:	2e b5       	in	r18, 0x2e	; 46
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 500:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 502:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 504:	90 e9       	ldi	r25, 0x90	; 144
 506:	9e bd       	out	0x2e, r25	; 46
 508:	99 89       	ldd	r25, Y+17	; 0x11

//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::odWrite(uint8_t channel, uint8_t address, uint8_t data)
{
    if (channel == IoLink::MC_CHNL_PAGE)
 50a:	80 32       	cpi	r24, 0x20	; 32
 50c:	29 f4       	brne	.+10     	; 0x518 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x44>
    {
        // store data for use in application
        _parameterWrite.address = address;
 50e:	68 87       	std	Y+8, r22	; 0x08
        _parameterWrite.value = data;
 510:	29 87       	std	Y+9, r18	; 0x09
        _prmWriteAvailable = true;
 512:	89 2f       	mov	r24, r25
 514:	82 60       	ori	r24, 0x02	; 2
 516:	02 c0       	rjmp	.+4      	; 0x51c <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x48>
    }
    else
    {
        _prmWriteAvailable = false;
 518:	89 2f       	mov	r24, r25
 51a:	8d 7f       	andi	r24, 0xFD	; 253
 51c:	89 8b       	std	Y+17, r24	; 0x11
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 51e:	0d b4       	in	r0, 0x2d	; 45
 520:	07 fe       	sbrs	r0, 7
 522:	fd cf       	rjmp	.-6      	; 0x51e <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x4a>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 524:	80 e4       	ldi	r24, 0x40	; 64
 526:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 528:	0d b4       	in	r0, 0x2d	; 45
 52a:	07 fe       	sbrs	r0, 7
 52c:	fd cf       	rjmp	.-6      	; 0x528 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x54>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 52e:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 530:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 532:	83 e8       	ldi	r24, 0x83	; 131
 534:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 536:	0d b4       	in	r0, 0x2d	; 45
 538:	07 fe       	sbrs	r0, 7
 53a:	fd cf       	rjmp	.-6      	; 0x536 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x62>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 53c:	8e b5       	in	r24, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 53e:	85 e0       	ldi	r24, 0x05	; 5
 540:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 542:	0d b4       	in	r0, 0x2d	; 45
 544:	07 fe       	sbrs	r0, 7
 546:	fd cf       	rjmp	.-6      	; 0x542 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x6e>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 548:	2a 9a       	sbi	0x05, 2	; 5
    {
        startCallbackTimer((octetCnt + 1) * 14 / 23 /* approx 230.4 / 10 */);
    }
    else // CFG_BD_38400
    {
        startCallbackTimer((octetCnt) * 14 / 4 /* approx. 38.4 / 10 */);
 54a:	63 e0       	ldi	r22, 0x03	; 3
 54c:	26 c0       	rjmp	.+76     	; 0x59a <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xc6>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 54e:	0d b4       	in	r0, 0x2d	; 45
 550:	07 fe       	sbrs	r0, 7
 552:	fd cf       	rjmp	.-6      	; 0x54e <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x7a>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 554:	9e b5       	in	r25, 0x2e	; 46
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 556:	2a 9a       	sbi	0x05, 2	; 5
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
template <IoLink::DeviceDLMode DDL_MODE>
bool StackBase<T, PDI, PDO, SpiSsHndlr>::validateFrameType(uint8_t ckt)
{
    uint8_t frameType = (ckt & IoLink::CKT_TYPE_MASK);
 558:	90 7c       	andi	r25, 0xC0	; 192
    switch (DDL_MODE)
    {
        // see table A.7
    case IoLink::DDL_MODE_IDLE:
    case IoLink::DDL_MODE_STARTUP:
        if (frameType == IoLink::CKT_TYPE_0) 
 55a:	61 f6       	brne	.-104    	; 0x4f4 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x20>
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 55c:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 55e:	90 e9       	ldi	r25, 0x90	; 144
 560:	9e bd       	out	0x2e, r25	; 46

        // start sending the return data
        registerWriteBegin(REG_FR0);

        // send OD data
        registerWriteNext(odRead(channel, address));
 562:	ae dd       	rcall	.-1188   	; 0xc0 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE6odReadEhh.isra.1>
 564:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 566:	07 fe       	sbrs	r0, 7
 568:	fd cf       	rjmp	.-6      	; 0x564 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x90>
 56a:	8e bd       	out	0x2e, r24	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 56c:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 56e:	07 fe       	sbrs	r0, 7
 570:	fd cf       	rjmp	.-6      	; 0x56c <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0x98>
 572:	80 e4       	ldi	r24, 0x40	; 64
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 574:	8e bd       	out	0x2e, r24	; 46
 576:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 578:	07 fe       	sbrs	r0, 7
 57a:	fd cf       	rjmp	.-6      	; 0x576 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xa2>
 57c:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 57e:	2a 98       	cbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 580:	83 e8       	ldi	r24, 0x83	; 131
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 582:	8e bd       	out	0x2e, r24	; 46
 584:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 586:	07 fe       	sbrs	r0, 7
 588:	fd cf       	rjmp	.-6      	; 0x584 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xb0>
 58a:	8e b5       	in	r24, 0x2e	; 46
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 58c:	89 e0       	ldi	r24, 0x09	; 9
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 58e:	8e bd       	out	0x2e, r24	; 46
 590:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 592:	07 fe       	sbrs	r0, 7
 594:	fd cf       	rjmp	.-6      	; 0x590 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xbc>
 596:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 598:	67 e0       	ldi	r22, 0x07	; 7
    {
        startCallbackTimer((octetCnt + 1) * 14 / 23 /* approx 230.4 / 10 */);
    }
    else // CFG_BD_38400
    {
        startCallbackTimer((octetCnt) * 14 / 4 /* approx. 38.4 / 10 */);
 59a:	ce 01       	movw	r24, r28
 59c:	5c de       	rcall	.-840    	; 0x256 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE18startCallbackTimerEh>
 59e:	88 81       	ld	r24, Y
 5a0:	82 30       	cpi	r24, 0x02	; 2

        // start user call-back timer after sending last byte 
        startCallbackTimerAfterReply(octetCount);
    }

    if ((DDL_MODE == IoLink::DDL_MODE_STARTUP || DDL_MODE == IoLink::DDL_MODE_IDLE) 
 5a2:	71 f0       	breq	.+28     	; 0x5c0 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xec>
 5a4:	82 e0       	ldi	r24, 0x02	; 2
 5a6:	88 83       	st	Y, r24
        && _ddlMode != IoLink::DDL_MODE_STARTUP)
    {
        // if IDLE, enter STARTUP state
        _ddlMode = IoLink::DDL_MODE_STARTUP;
 5a8:	2a 98       	cbi	0x05, 2	; 5
 5aa:	82 e8       	ldi	r24, 0x82	; 130
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 5ac:	8e bd       	out	0x2e, r24	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 5ae:	0d b4       	in	r0, 0x2d	; 45
 5b0:	07 fe       	sbrs	r0, 7
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 5b2:	fd cf       	rjmp	.-6      	; 0x5ae <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xda>
 5b4:	8e b5       	in	r24, 0x2e	; 46
 5b6:	1e bc       	out	0x2e, r1	; 46
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 5b8:	0d b4       	in	r0, 0x2d	; 45
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 5ba:	07 fe       	sbrs	r0, 7
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 5bc:	fd cf       	rjmp	.-6      	; 0x5b8 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh+0xe4>
 5be:	2a 9a       	sbi	0x05, 2	; 5
 5c0:	80 e0       	ldi	r24, 0x00	; 0
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 5c2:	df 91       	pop	r29
        setIoLinkListen();
    }

    return ResultSuccess;
 5c4:	cf 91       	pop	r28
}
 5c6:	08 95       	ret

000005c8 <__vector_4>:
 5c8:	1f 92       	push	r1
 5ca:	0f 92       	push	r0
 * Interrupt service routine for the PHY interrupt.
 *
 * We immediately forward the call to onPhyInterrupt().
 */
ISR(PCINT1_vect)
{
 5cc:	0f b6       	in	r0, 0x3f	; 63
 5ce:	0f 92       	push	r0
 5d0:	11 24       	eor	r1, r1
 5d2:	2f 93       	push	r18
 5d4:	3f 93       	push	r19
 5d6:	4f 93       	push	r20
 5d8:	5f 93       	push	r21
 5da:	6f 93       	push	r22
 5dc:	7f 93       	push	r23
 5de:	8f 93       	push	r24
 5e0:	9f 93       	push	r25
 5e2:	af 93       	push	r26
 5e4:	bf 93       	push	r27
 5e6:	ef 93       	push	r30
 5e8:	ff 93       	push	r31
    // 
    // (If INT isn't cleared after the handler, then the PHY state is probably
    //  out of sync with the one expected by the firmware. In that case, this
    //  ISR will never be called again. Looping the handler ensures we eventually
    //  resync before exiting the ISR)
    while (bit_is_set(PINC, PINC0))
 5ea:	30 9b       	sbis	0x06, 0	; 6
 5ec:	75 c0       	rjmp	.+234    	; 0x6d8 <__vector_4+0x110>
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 5ee:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 5f0:	80 e1       	ldi	r24, 0x10	; 16
 5f2:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 5f4:	0d b4       	in	r0, 0x2d	; 45
 5f6:	07 fe       	sbrs	r0, 7
 5f8:	fd cf       	rjmp	.-6      	; 0x5f4 <__vector_4+0x2c>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 5fa:	8e b5       	in	r24, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 5fc:	8e bd       	out	0x2e, r24	; 46
    // read the device status and start reading the frame register
    uint8_t status = registerReadBegin(REG_FR0);

    // test flags
    HandlerResult result;
    if (!(status & STATUS_RST))
 5fe:	87 ff       	sbrs	r24, 7
 600:	4a c0       	rjmp	.+148    	; 0x696 <__vector_4+0xce>
    {
        result = ResultPhyReset;
    }
    else if (!(status & STATUS_DAT))
 602:	82 ff       	sbrs	r24, 2
 604:	25 c0       	rjmp	.+74     	; 0x650 <__vector_4+0x88>
    {
        result = ResultNoData;
    }
    else if (status & STATUS_CHK)
 606:	83 fd       	sbrc	r24, 3
 608:	25 c0       	rjmp	.+74     	; 0x654 <__vector_4+0x8c>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 60a:	0d b4       	in	r0, 0x2d	; 45
 60c:	07 fe       	sbrs	r0, 7
 60e:	fd cf       	rjmp	.-6      	; 0x60a <__vector_4+0x42>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 610:	6e b5       	in	r22, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 612:	6e bd       	out	0x2e, r22	; 46
    {
        // get master sequence control octet
        const uint8_t mc = registerReadNext();

        // call appropriate state handler
        switch (_ddlMode)
 614:	80 91 01 01 	lds	r24, 0x0101
 618:	83 30       	cpi	r24, 0x03	; 3
 61a:	31 f0       	breq	.+12     	; 0x628 <__vector_4+0x60>
 61c:	84 30       	cpi	r24, 0x04	; 4
 61e:	41 f4       	brne	.+16     	; 0x630 <__vector_4+0x68>
        {
        case IoLink::DDL_MODE_OPERATE:    
            result = handleOperatingMode<IoLink::DDL_MODE_OPERATE>(mc); 
 620:	81 e0       	ldi	r24, 0x01	; 1
 622:	91 e0       	ldi	r25, 0x01	; 1
 624:	5b de       	rcall	.-842    	; 0x2dc <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh>
 626:	07 c0       	rjmp	.+14     	; 0x636 <__vector_4+0x6e>
 628:	81 e0       	ldi	r24, 0x01	; 1
            break;
        case IoLink::DDL_MODE_PREOPERATE:
            result = handleOperatingMode<IoLink::DDL_MODE_PREOPERATE>(mc);
 62a:	91 e0       	ldi	r25, 0x01	; 1
 62c:	ec de       	rcall	.-552    	; 0x406 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh>
 62e:	03 c0       	rjmp	.+6      	; 0x636 <__vector_4+0x6e>
 630:	81 e0       	ldi	r24, 0x01	; 1
 632:	91 e0       	ldi	r25, 0x01	; 1
            break;
        default:                  
            result = handleOperatingMode<IoLink::DDL_MODE_STARTUP>(mc); 
 634:	4f df       	rcall	.-354    	; 0x4d4 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li1ELi1E16DefaultSsHandlerE13HandlerResultEh>
 636:	82 30       	cpi	r24, 0x02	; 2
 638:	69 f0       	breq	.+26     	; 0x654 <__vector_4+0x8c>
 63a:	20 f4       	brcc	.+8      	; 0x644 <__vector_4+0x7c>
            break;
        }
    }

    // handle result codes
    switch (result)
 63c:	81 30       	cpi	r24, 0x01	; 1
 63e:	09 f0       	breq	.+2      	; 0x642 <__vector_4+0x7a>
 640:	48 c0       	rjmp	.+144    	; 0x6d2 <__vector_4+0x10a>
 642:	06 c0       	rjmp	.+12     	; 0x650 <__vector_4+0x88>
 644:	83 30       	cpi	r24, 0x03	; 3
 646:	a9 f0       	breq	.+42     	; 0x672 <__vector_4+0xaa>
 648:	84 30       	cpi	r24, 0x04	; 4
 64a:	09 f0       	breq	.+2      	; 0x64e <__vector_4+0x86>
 64c:	42 c0       	rjmp	.+132    	; 0x6d2 <__vector_4+0x10a>
 64e:	23 c0       	rjmp	.+70     	; 0x696 <__vector_4+0xce>
 650:	ca dd       	rcall	.-1132   	; 0x1e6 <_ZN9PhyDriverI16DefaultSsHandlerE19registerAbortAccessEv>
 652:	3f c0       	rjmp	.+126    	; 0x6d2 <__vector_4+0x10a>
 654:	c8 dd       	rcall	.-1136   	; 0x1e6 <_ZN9PhyDriverI16DefaultSsHandlerE19registerAbortAccessEv>
    case ResultSuccess:
        break;

    case ResultNoData:
        // terminate SPI access
        registerAbortAccess();
 656:	2a 98       	cbi	0x05, 2	; 5
 658:	83 e8       	ldi	r24, 0x83	; 131
 65a:	8e bd       	out	0x2e, r24	; 46
        break;

    case ResultChecksumError:
        // terminate SPI access
        registerAbortAccess();
 65c:	0d b4       	in	r0, 0x2d	; 45
 65e:	07 fe       	sbrs	r0, 7
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 660:	fd cf       	rjmp	.-6      	; 0x65c <__vector_4+0x94>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 662:	8e b5       	in	r24, 0x2e	; 46
 664:	82 e0       	ldi	r24, 0x02	; 2
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 666:	8e bd       	out	0x2e, r24	; 46
 668:	0d b4       	in	r0, 0x2d	; 45
 66a:	07 fe       	sbrs	r0, 7
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 66c:	fd cf       	rjmp	.-6      	; 0x668 <__vector_4+0xa0>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 66e:	2a 9a       	sbi	0x05, 2	; 5
 670:	30 c0       	rjmp	.+96     	; 0x6d2 <__vector_4+0x10a>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 672:	b9 dd       	rcall	.-1166   	; 0x1e6 <_ZN9PhyDriverI16DefaultSsHandlerE19registerAbortAccessEv>
 674:	2a 98       	cbi	0x05, 2	; 5
 676:	83 e8       	ldi	r24, 0x83	; 131
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 678:	8e bd       	out	0x2e, r24	; 46
 67a:	0d b4       	in	r0, 0x2d	; 45
        registerWrite(REG_LINK, LINK_END);
        break;

    case ResultIllegalMessageType:
        // terminate SPI access
        registerAbortAccess();
 67c:	07 fe       	sbrs	r0, 7
 67e:	fd cf       	rjmp	.-6      	; 0x67a <__vector_4+0xb2>
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 680:	8e b5       	in	r24, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 682:	82 e0       	ldi	r24, 0x02	; 2
 684:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 686:	0d b4       	in	r0, 0x2d	; 45
 688:	07 fe       	sbrs	r0, 7
 68a:	fd cf       	rjmp	.-6      	; 0x686 <__vector_4+0xbe>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 68c:	2a 9a       	sbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 68e:	82 e0       	ldi	r24, 0x02	; 2
 690:	80 93 01 01 	sts	0x0101, r24
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 694:	1e c0       	rjmp	.+60     	; 0x6d2 <__vector_4+0x10a>
 696:	a7 dd       	rcall	.-1202   	; 0x1e6 <_ZN9PhyDriverI16DefaultSsHandlerE19registerAbortAccessEv>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 698:	2a 98       	cbi	0x05, 2	; 5

        // bad data has been received, so decline to respond
        registerWrite(REG_LINK, LINK_END);

        // revert to startup mode
        _ddlMode = IoLink::DDL_MODE_STARTUP;
 69a:	83 e8       	ldi	r24, 0x83	; 131
 69c:	8e bd       	out	0x2e, r24	; 46
 69e:	0d b4       	in	r0, 0x2d	; 45
 6a0:	07 fe       	sbrs	r0, 7
        break;

    case ResultPhyReset:
        // terminate SPI access
        registerAbortAccess();
 6a2:	fd cf       	rjmp	.-6      	; 0x69e <__vector_4+0xd6>
 6a4:	8e b5       	in	r24, 0x2e	; 46
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 6a6:	82 e0       	ldi	r24, 0x02	; 2
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 6a8:	8e bd       	out	0x2e, r24	; 46
 6aa:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 6ac:	07 fe       	sbrs	r0, 7
 6ae:	fd cf       	rjmp	.-6      	; 0x6aa <__vector_4+0xe2>
 6b0:	2a 9a       	sbi	0x05, 2	; 5
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 6b2:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 6b4:	85 e8       	ldi	r24, 0x85	; 133
 6b6:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 6b8:	0d b4       	in	r0, 0x2d	; 45
 6ba:	07 fe       	sbrs	r0, 7
 6bc:	fd cf       	rjmp	.-6      	; 0x6b8 <__vector_4+0xf0>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 6be:	8e b5       	in	r24, 0x2e	; 46
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 6c0:	80 e8       	ldi	r24, 0x80	; 128
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 6c2:	8e bd       	out	0x2e, r24	; 46
 6c4:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 6c6:	07 fe       	sbrs	r0, 7
 6c8:	fd cf       	rjmp	.-6      	; 0x6c4 <__vector_4+0xfc>
 6ca:	2a 9a       	sbi	0x05, 2	; 5
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 6cc:	81 e0       	ldi	r24, 0x01	; 1
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 6ce:	91 e0       	ldi	r25, 0x01	; 1
 6d0:	91 dd       	rcall	.-1246   	; 0x1f4 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE12configurePhyEv>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 6d2:	82 e0       	ldi	r24, 0x02	; 2
 6d4:	8b bb       	out	0x1b, r24	; 27
 6d6:	89 cf       	rjmp	.-238    	; 0x5ea <__vector_4+0x22>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 6d8:	ff 91       	pop	r31
        // decline to respond
        registerWrite(REG_LINK, LINK_END);

        // reset the reset bit
        registerWrite(REG_STATUS, STATUS_RST);
        configurePhy(); // implicitly reverts to DDL_MODE_STARTUP
 6da:	ef 91       	pop	r30
 6dc:	bf 91       	pop	r27
 6de:	af 91       	pop	r26
 6e0:	9f 91       	pop	r25
    while (bit_is_set(PINC, PINC0))
    {
        StackMultiByte::instance.onPhyInterrupt();

        // clear interrupt
        PCIFR = _BV(PCIF1);
 6e2:	8f 91       	pop	r24
 6e4:	7f 91       	pop	r23
 6e6:	6f 91       	pop	r22
    }
}
 6e8:	5f 91       	pop	r21
 6ea:	4f 91       	pop	r20
 6ec:	3f 91       	pop	r19
 6ee:	2f 91       	pop	r18
 6f0:	0f 90       	pop	r0
 6f2:	0f be       	out	0x3f, r0	; 63
 6f4:	0f 90       	pop	r0
 6f6:	1f 90       	pop	r1
 6f8:	18 95       	reti

000006fa <_GLOBAL__sub_I_directParameter>:
 6fa:	e1 e0       	ldi	r30, 0x01	; 1
 6fc:	f1 e0       	ldi	r31, 0x01	; 1
 6fe:	10 82       	st	Z, r1
 700:	9f ef       	ldi	r25, 0xFF	; 255
 702:	95 83       	std	Z+5, r25	; 0x05
 704:	a8 e0       	ldi	r26, 0x08	; 8
 706:	b1 e0       	ldi	r27, 0x01	; 1
 708:	8c 91       	ld	r24, X
    , _ledRegister(0)
    , _fallbackCounter(0)
    , _runUserCode(false)
    , _sioLevel(true)
    , _prmWriteAvailable(false)
    , _flag(false)
 70a:	81 60       	ori	r24, 0x01	; 1
 70c:	8c 93       	st	X, r24
 70e:	13 86       	std	Z+11, r1	; 0x0b
 710:	12 86       	std	Z+10, r1	; 0x0a
 712:	15 86       	std	Z+13, r1	; 0x0d
 714:	14 86       	std	Z+12, r1	; 0x0c
 716:	96 87       	std	Z+14, r25	; 0x0e
 718:	17 86       	std	Z+15, r1	; 0x0f
 71a:	10 8a       	std	Z+16, r1	; 0x10
 71c:	a2 e1       	ldi	r26, 0x12	; 18
 71e:	b1 e0       	ldi	r27, 0x01	; 1
 720:	8c 91       	ld	r24, X
 722:	8c 7f       	andi	r24, 0xFC	; 252
 724:	8b 7f       	andi	r24, 0xFB	; 251
 726:	8c 93       	st	X, r24
{
    _parameterWrite.address = IoLink::PAGE_NO_PARAMETER;
 728:	90 87       	std	Z+8, r25	; 0x08
 72a:	08 95       	ret

0000072c <_ZN7DemoApp9configureEv>:

//------------------------------------------------------------------------------
void DemoApp::configure()
{
    // Configure a timer with 10ms cycle
    OCR2A   = F_CPU / 1024 / 100;
 72c:	8e e4       	ldi	r24, 0x4E	; 78
 72e:	80 93 b3 00 	sts	0x00B3, r24

    /* Start the timer
       WGM    = 3'b010  - clear timer on match
       COMxx  = 2'b0    - pins not used
       CS     = 3'b111   - divide by 1024 */
    TCCR2A = _BV(WGM21);
 732:	82 e0       	ldi	r24, 0x02	; 2
 734:	80 93 b0 00 	sts	0x00B0, r24
    TCCR2B = _BV(CS22) | _BV(CS21) | _BV(CS20);
 738:	87 e0       	ldi	r24, 0x07	; 7
 73a:	80 93 b1 00 	sts	0x00B1, r24

    // configure digital input
    DDRB &= ~_BV(DDB7);
 73e:	27 98       	cbi	0x04, 7	; 4
 740:	08 95       	ret

00000742 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE>:
    updateProcessInputData();
}

//------------------------------------------------------------------------------
void DemoApp::handleParameterWrite(const Stack::Parameter* param)
{
 742:	fb 01       	movw	r30, r22
    // (this is the location to intercept the write access if desired)
    bool commit = true;

    switch (param->address)
 744:	80 81       	ld	r24, Z
 746:	81 31       	cpi	r24, 0x11	; 17
 748:	09 f4       	brne	.+2      	; 0x74c <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xa>
 74a:	7a c0       	rjmp	.+244    	; 0x840 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xfe>
 74c:	91 81       	ldd	r25, Z+1	; 0x01
 74e:	82 31       	cpi	r24, 0x12	; 18
 750:	29 f0       	breq	.+10     	; 0x75c <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x1a>
 752:	80 31       	cpi	r24, 0x10	; 16
 754:	59 f4       	brne	.+22     	; 0x76c <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x2a>
    case IoLink::PAGE_DEVICE_SPECIFIC_1B:
    case IoLink::PAGE_DEVICE_SPECIFIC_1C:
    case IoLink::PAGE_DEVICE_SPECIFIC_1D:
    case IoLink::PAGE_DEVICE_SPECIFIC_1E:
    case IoLink::PAGE_DEVICE_SPECIFIC_1F:
        directParameter[address] = value;
 756:	90 93 2c 01 	sts	0x012C, r25
 75a:	08 c0       	rjmp	.+16     	; 0x76c <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x2a>
        // read-only access => ignore
        commit = false;
        break;

    case VendorParamPidMode:  // process input data selection
        switch (param->value)
 75c:	91 30       	cpi	r25, 0x01	; 1
 75e:	31 f4       	brne	.+12     	; 0x76c <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x2a>
        {
        case PidAnalogInput:
            // configure ADC
            ADMUX = _BV(REFS0) | 7; 
 760:	87 e4       	ldi	r24, 0x47	; 71
 762:	80 93 7c 00 	sts	0x007C, r24
            ADCSRA = _BV(ADPS0) | _BV(ADPS1) | _BV(ADPS2) | _BV(ADEN) | _BV(ADSC);
 766:	87 ec       	ldi	r24, 0xC7	; 199
 768:	80 93 7a 00 	sts	0x007A, r24
    }

    if (commit)
    {
        // commit to stack
        Stack::instance.parameterWrite(param->address, param->value);
 76c:	21 81       	ldd	r18, Z+1	; 0x01
 76e:	e0 81       	ld	r30, Z
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::parameterWrite(uint8_t address, uint8_t value)
{
    // write to direct parameter page channel
    switch (address)
 770:	ec 30       	cpi	r30, 0x0C	; 12
 772:	08 f0       	brcs	.+2      	; 0x776 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x34>
 774:	60 c0       	rjmp	.+192    	; 0x836 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xf4>
 776:	e9 30       	cpi	r30, 0x09	; 9
 778:	50 f0       	brcs	.+20     	; 0x78e <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x4c>

    case IoLink::PAGE_REVISION_ID:
    case IoLink::PAGE_DEVICE_ID_1:
    case IoLink::PAGE_DEVICE_ID_2:
    case IoLink::PAGE_DEVICE_ID_3:
        if (_ddlMode == IoLink::DDL_MODE_STARTUP)
 77a:	80 91 01 01 	lds	r24, 0x0101
 77e:	82 30       	cpi	r24, 0x02	; 2
 780:	09 f0       	breq	.+2      	; 0x784 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x42>
 782:	5e c0       	rjmp	.+188    	; 0x840 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xfe>
        {
            directParameter[address] = value;
 784:	f0 e0       	ldi	r31, 0x00	; 0
 786:	e5 5e       	subi	r30, 0xE5	; 229
 788:	fe 4f       	sbci	r31, 0xFE	; 254
 78a:	20 83       	st	Z, r18
 78c:	08 95       	ret
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::parameterWrite(uint8_t address, uint8_t value)
{
    // write to direct parameter page channel
    switch (address)
 78e:	e1 30       	cpi	r30, 0x01	; 1
 790:	69 f5       	brne	.+90     	; 0x7ec <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xaa>
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::updateCyclePeriod()
{
    // get period
    uint8_t cycleParam = 0;
    if (_ddlMode == IoLink::DDL_MODE_OPERATE)
 792:	80 91 01 01 	lds	r24, 0x0101
 796:	84 30       	cpi	r24, 0x04	; 4
 798:	21 f4       	brne	.+8      	; 0x7a2 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x60>
     * 
     * \param address   Parameter index
     * \return          Read value
     * 
     */
    uint8_t             parameterRead(uint8_t address) const { return directParameter[address]; }
 79a:	80 91 1c 01 	lds	r24, 0x011C
    if (_ddlMode == IoLink::DDL_MODE_OPERATE)
    {
        cycleParam = parameterRead(IoLink::PAGE_MASTER_CYCLE_TIME);
    }

    if (cycleParam == 0)
 79e:	81 11       	cpse	r24, r1
 7a0:	02 c0       	rjmp	.+4      	; 0x7a6 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x64>
     * 
     * \param address   Parameter index
     * \return          Read value
     * 
     */
    uint8_t             parameterRead(uint8_t address) const { return directParameter[address]; }
 7a2:	80 91 1d 01 	lds	r24, 0x011D
        // MasterCycleTime hasn't been set yet => use MinCycleTime
        cycleParam = parameterRead(IoLink::PAGE_MIN_CYCLE_TIME);
    }

    // decode parameter into 1/10ms
    _cyclePeriod = DECODE_CYCLE_TIME(cycleParam);
 7a6:	84 30       	cpi	r24, 0x04	; 4
 7a8:	d0 f0       	brcs	.+52     	; 0x7de <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x9c>
 7aa:	80 34       	cpi	r24, 0x40	; 64
 7ac:	10 f4       	brcc	.+4      	; 0x7b2 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x70>
 7ae:	90 e0       	ldi	r25, 0x00	; 0
 7b0:	18 c0       	rjmp	.+48     	; 0x7e2 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xa0>
 7b2:	98 2f       	mov	r25, r24
 7b4:	90 7c       	andi	r25, 0xC0	; 192
 7b6:	90 34       	cpi	r25, 0x40	; 64
 7b8:	41 f4       	brne	.+16     	; 0x7ca <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x88>
 7ba:	34 e0       	ldi	r19, 0x04	; 4
 7bc:	83 9f       	mul	r24, r19
 7be:	c0 01       	movw	r24, r0
 7c0:	11 24       	eor	r1, r1
 7c2:	99 27       	eor	r25, r25
 7c4:	80 5c       	subi	r24, 0xC0	; 192
 7c6:	9f 4f       	sbci	r25, 0xFF	; 255
 7c8:	0c c0       	rjmp	.+24     	; 0x7e2 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xa0>
 7ca:	90 38       	cpi	r25, 0x80	; 128
 7cc:	41 f4       	brne	.+16     	; 0x7de <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x9c>
 7ce:	8f 73       	andi	r24, 0x3F	; 63
 7d0:	30 e1       	ldi	r19, 0x10	; 16
 7d2:	83 9f       	mul	r24, r19
 7d4:	c0 01       	movw	r24, r0
 7d6:	11 24       	eor	r1, r1
 7d8:	80 5c       	subi	r24, 0xC0	; 192
 7da:	9e 4f       	sbci	r25, 0xFE	; 254
 7dc:	02 c0       	rjmp	.+4      	; 0x7e2 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xa0>
 7de:	80 e0       	ldi	r24, 0x00	; 0
 7e0:	90 e0       	ldi	r25, 0x00	; 0
 7e2:	90 93 0c 01 	sts	0x010C, r25
 7e6:	80 93 0b 01 	sts	0x010B, r24
 7ea:	cc cf       	rjmp	.-104    	; 0x784 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x42>
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::parameterWrite(uint8_t address, uint8_t value)
{
    // write to direct parameter page channel
    switch (address)
 7ec:	e1 30       	cpi	r30, 0x01	; 1
 7ee:	f8 f4       	brcc	.+62     	; 0x82e <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xec>
    {
    case IoLink::PAGE_MASTER_CMD:
        switch (value)
 7f0:	28 39       	cpi	r18, 0x98	; 152
 7f2:	a1 f0       	breq	.+40     	; 0x81c <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xda>
 7f4:	28 f4       	brcc	.+10     	; 0x800 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xbe>
 7f6:	2a 35       	cpi	r18, 0x5A	; 90
 7f8:	b1 f0       	breq	.+44     	; 0x826 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xe4>
 7fa:	27 39       	cpi	r18, 0x97	; 151
 7fc:	31 f0       	breq	.+12     	; 0x80a <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xc8>
 7fe:	08 95       	ret
 800:	29 39       	cpi	r18, 0x99	; 153
 802:	49 f0       	breq	.+18     	; 0x816 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xd4>
 804:	2a 39       	cpi	r18, 0x9A	; 154
 806:	19 f0       	breq	.+6      	; 0x80e <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xcc>
 808:	08 95       	ret
        {
        case IoLink::MCMD_DEVICE_STARTUP:   
            _ddlMode = IoLink::DDL_MODE_STARTUP;  
 80a:	82 e0       	ldi	r24, 0x02	; 2
 80c:	01 c0       	rjmp	.+2      	; 0x810 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xce>
            break;
        case IoLink::MCMD_DEVICE_PREOPERATE:
            _ddlMode = IoLink::DDL_MODE_PREOPERATE; 
 80e:	83 e0       	ldi	r24, 0x03	; 3
 810:	80 93 01 01 	sts	0x0101, r24
 814:	08 95       	ret
            break;
        case IoLink::MCMD_DEVICE_OPERATE:   
            _processDataOut.isValid = false;
 816:	10 92 05 01 	sts	0x0105, r1
 81a:	03 c0       	rjmp	.+6      	; 0x822 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xe0>
            _ddlMode = IoLink::DDL_MODE_OPERATE; 
            break;
        case IoLink::MCMD_PD_OUT_OPERATE:   // Process output data valid
            _processDataOut.isValid = true;
 81c:	81 e0       	ldi	r24, 0x01	; 1
 81e:	80 93 05 01 	sts	0x0105, r24
            _ddlMode = IoLink::DDL_MODE_OPERATE; 
 822:	84 e0       	ldi	r24, 0x04	; 4
 824:	f5 cf       	rjmp	.-22     	; 0x810 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xce>
            break;
        case IoLink::MCMD_FALLBACK:
            // switch to SIO mode after 3 cycles
            _fallbackCounter = 3;
 826:	83 e0       	ldi	r24, 0x03	; 3
 828:	80 93 11 01 	sts	0x0111, r24
 82c:	08 95       	ret
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::parameterWrite(uint8_t address, uint8_t value)
{
    // write to direct parameter page channel
    switch (address)
 82e:	e4 30       	cpi	r30, 0x04	; 4
 830:	09 f4       	brne	.+2      	; 0x834 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xf2>
 832:	a3 cf       	rjmp	.-186    	; 0x77a <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x38>
 834:	08 95       	ret
 836:	81 ef       	ldi	r24, 0xF1	; 241
 838:	8e 0f       	add	r24, r30
 83a:	81 31       	cpi	r24, 0x11	; 17
 83c:	08 f4       	brcc	.+2      	; 0x840 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0xfe>
 83e:	a2 cf       	rjmp	.-188    	; 0x784 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x42>
 840:	08 95       	ret

00000842 <_ZN7DemoApp11elapsed10msEv>:
}

//------------------------------------------------------------------------------
bool DemoApp::elapsed10ms()
{
    if (!(TIFR2 & _BV(OCF2A)))
 842:	b9 9b       	sbis	0x17, 1	; 23
 844:	04 c0       	rjmp	.+8      	; 0x84e <_ZN7DemoApp11elapsed10msEv+0xc>
        return false;

    TIFR2 = _BV(OCF2A);
 846:	82 e0       	ldi	r24, 0x02	; 2
 848:	87 bb       	out	0x17, r24	; 23
    return true;
 84a:	81 e0       	ldi	r24, 0x01	; 1
 84c:	08 95       	ret

//------------------------------------------------------------------------------
bool DemoApp::elapsed10ms()
{
    if (!(TIFR2 & _BV(OCF2A)))
        return false;
 84e:	80 e0       	ldi	r24, 0x00	; 0

    TIFR2 = _BV(OCF2A);
    return true;
}
 850:	08 95       	ret

00000852 <_ZN7DemoApp22updateProcessInputDataEv>:
    }
}

//------------------------------------------------------------------------------
void DemoApp::updateProcessInputData()
{
 852:	cf 93       	push	r28
 854:	df 93       	push	r29
 856:	ec 01       	movw	r28, r24
    if (elapsed10ms())
 858:	f4 df       	rcall	.-24     	; 0x842 <_ZN7DemoApp11elapsed10msEv>
 85a:	88 23       	and	r24, r24
 85c:	61 f1       	breq	.+88     	; 0x8b6 <_ZN7DemoApp22updateProcessInputDataEv+0x64>
 85e:	88 81       	ld	r24, Y
    {
        // the green LED cycles if IO-Link comms are up, red if not
        ++_ctr;
 860:	8f 5f       	subi	r24, 0xFF	; 255
 862:	88 83       	st	Y, r24
 864:	90 e0       	ldi	r25, 0x00	; 0
        uint8_t level = ((_ctr >> 3) & 0x0f);
 866:	23 e0       	ldi	r18, 0x03	; 3
 868:	95 95       	asr	r25
 86a:	87 95       	ror	r24
 86c:	2a 95       	dec	r18
 86e:	e1 f7       	brne	.-8      	; 0x868 <_ZN7DemoApp22updateProcessInputDataEv+0x16>
 870:	98 2f       	mov	r25, r24
 872:	9f 70       	andi	r25, 0x0F	; 15
 874:	83 ff       	sbrs	r24, 3
        if (level & 0x8) level = ((~level) & 0x7);
 876:	02 c0       	rjmp	.+4      	; 0x87c <_ZN7DemoApp22updateProcessInputDataEv+0x2a>
 878:	90 95       	com	r25
 87a:	97 70       	andi	r25, 0x07	; 7
 87c:	80 91 06 01 	lds	r24, 0x0106

        if (Stack::instance.masterLost())
 880:	85 30       	cpi	r24, 0x05	; 5
 882:	18 f0       	brcs	.+6      	; 0x88a <_ZN7DemoApp22updateProcessInputDataEv+0x38>
 884:	19 82       	std	Y+1, r1	; 0x01
            {
                // flash the red LED
                _ledLevel1 = Stack::LED_LEVEL_OFF;
 886:	9a 83       	std	Y+2, r25	; 0x02
                _ledLevel2 = (Stack::LedLevel)(level);
 888:	02 c0       	rjmp	.+4      	; 0x88e <_ZN7DemoApp22updateProcessInputDataEv+0x3c>
 88a:	99 83       	std	Y+1, r25	; 0x01
            }
            else
            {
                // flash the green LED
                _ledLevel1 = (Stack::LedLevel)(level);
 88c:	1a 82       	std	Y+2, r1	; 0x02
                _ledLevel2 = Stack::LED_LEVEL_OFF;
 88e:	1f 99       	sbic	0x03, 7	; 3
            };

        // the red LED is over-ridden if the push-button is pressed
        if (isDigitalButtonPressed())
 890:	02 c0       	rjmp	.+4      	; 0x896 <_ZN7DemoApp22updateProcessInputDataEv+0x44>
 892:	8f e0       	ldi	r24, 0x0F	; 15
        {
            _ledLevel2 = (Stack::LedLevel)(0xf);
 894:	8a 83       	std	Y+2, r24	; 0x02
 896:	89 81       	ldd	r24, Y+1	; 0x01
{
    switch (led)
    {
    case LED_1:
        _ledRegister &= 0x0f;
        _ledRegister |= (level << 4);
 898:	20 e1       	ldi	r18, 0x10	; 16
 89a:	82 9f       	mul	r24, r18
 89c:	c0 01       	movw	r24, r0
 89e:	11 24       	eor	r1, r1
 8a0:	90 91 10 01 	lds	r25, 0x0110
void StackBase<T, PDI, PDO, SpiSsHndlr>::setLedLevel(Led led, typename Phy::LedLevel level)
{
    switch (led)
    {
    case LED_1:
        _ledRegister &= 0x0f;
 8a4:	9f 70       	andi	r25, 0x0F	; 15
 8a6:	89 2b       	or	r24, r25
        _ledRegister |= (level << 4);
 8a8:	80 93 10 01 	sts	0x0110, r24
 8ac:	80 7f       	andi	r24, 0xF0	; 240
        break;

    case LED_2:
        _ledRegister &= 0xf0;
 8ae:	9a 81       	ldd	r25, Y+2	; 0x02
        _ledRegister |= level;
 8b0:	89 2b       	or	r24, r25
 8b2:	80 93 10 01 	sts	0x0110, r24
 8b6:	80 91 2d 01 	lds	r24, 0x012D

        Stack::instance.setLedLevel(Stack::LED_1, _ledLevel1);
        Stack::instance.setLedLevel(Stack::LED_2, _ledLevel2);
    }

    switch (Stack::instance.parameterRead(VendorParamPidMode))
 8ba:	81 30       	cpi	r24, 0x01	; 1
 8bc:	59 f0       	breq	.+22     	; 0x8d4 <_ZN7DemoApp22updateProcessInputDataEv+0x82>
 8be:	20 f0       	brcs	.+8      	; 0x8c8 <_ZN7DemoApp22updateProcessInputDataEv+0x76>
 8c0:	82 30       	cpi	r24, 0x02	; 2
 8c2:	21 f5       	brne	.+72     	; 0x90c <__stack+0xd>
 8c4:	88 81       	ld	r24, Y
        }
        break;

    case PidSawtooth:
        // copy counter to process input data
        Stack::instance.processInputData().buffer[0] = _ctr;
 8c6:	1c c0       	rjmp	.+56     	; 0x900 <__stack+0x1>
 8c8:	83 b1       	in	r24, 0x03	; 3
}

//------------------------------------------------------------------------------
bool DemoApp::isDigitalButtonPressed()
{
    return !(PINB & _BV(PINB7));
 8ca:	80 95       	com	r24

    switch (Stack::instance.parameterRead(VendorParamPidMode))
    {
    case PidDigitalInput:
        // check digital sensor 
        Stack::instance.processInputData().buffer[0] = isDigitalButtonPressed() ? 0x01 : 0x00;
 8cc:	88 1f       	adc	r24, r24
 8ce:	88 27       	eor	r24, r24
 8d0:	88 1f       	adc	r24, r24
 8d2:	16 c0       	rjmp	.+44     	; 0x900 <__stack+0x1>
 8d4:	90 91 7a 00 	lds	r25, 0x007A
        Stack::instance.processInputData().isValid = true;
        break;

    case PidAnalogInput:
        // check analog sensor
        if (!(ADCSRA & _BV(ADSC)))
 8d8:	96 fd       	sbrc	r25, 6
 8da:	1a c0       	rjmp	.+52     	; 0x910 <__stack+0x11>
 8dc:	20 91 78 00 	lds	r18, 0x0078
        {
            uint16_t sensorValue = ADC;
 8e0:	30 91 79 00 	lds	r19, 0x0079
 8e4:	36 95       	lsr	r19

            Stack::instance.processInputData().buffer[0] = sensorValue >> 2;
 8e6:	27 95       	ror	r18
 8e8:	36 95       	lsr	r19
 8ea:	27 95       	ror	r18
 8ec:	20 93 02 01 	sts	0x0102, r18
 8f0:	80 93 03 01 	sts	0x0103, r24
            Stack::instance.processInputData().isValid = true;
 8f4:	80 91 7a 00 	lds	r24, 0x007A

            // restart sampling
            ADCSRA |= _BV(ADSC);
 8f8:	80 64       	ori	r24, 0x40	; 64
 8fa:	80 93 7a 00 	sts	0x007A, r24
 8fe:	08 c0       	rjmp	.+16     	; 0x910 <__stack+0x11>
 900:	80 93 02 01 	sts	0x0102, r24
        }
        break;

    case PidSawtooth:
        // copy counter to process input data
        Stack::instance.processInputData().buffer[0] = _ctr;
 904:	81 e0       	ldi	r24, 0x01	; 1
        Stack::instance.processInputData().isValid = true;
 906:	80 93 03 01 	sts	0x0103, r24
 90a:	02 c0       	rjmp	.+4      	; 0x910 <__stack+0x11>
        break;
 90c:	10 92 03 01 	sts	0x0103, r1

    default:
        Stack::instance.processInputData().isValid = false;
 910:	df 91       	pop	r29
        break;
    }
}
 912:	cf 91       	pop	r28
 914:	08 95       	ret

00000916 <_ZN7DemoApp3runEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE>:
 916:	cf 93       	push	r28
    DDRB &= ~_BV(DDB7);
}

//------------------------------------------------------------------------------
void DemoApp::run(const Stack::Parameter* param)
{
 918:	df 93       	push	r29
 91a:	ec 01       	movw	r28, r24
    // check for write access to direct parameter page
    if (param)
 91c:	61 15       	cp	r22, r1
 91e:	71 05       	cpc	r23, r1
 920:	11 f0       	breq	.+4      	; 0x926 <_ZN7DemoApp3runEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x10>
    {
        handleParameterWrite(param);
 922:	0f df       	rcall	.-482    	; 0x742 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE>
 924:	27 c0       	rjmp	.+78     	; 0x974 <_ZN7DemoApp3runEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x5e>
 926:	80 91 01 01 	lds	r24, 0x0101
    }
    else if (Stack::instance.stackMode() == Stack::STACK_MODE_SIO)
 92a:	81 11       	cpse	r24, r1
 92c:	23 c0       	rjmp	.+70     	; 0x974 <_ZN7DemoApp3runEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x5e>
 92e:	93 b1       	in	r25, 0x03	; 3
}

//------------------------------------------------------------------------------
bool DemoApp::isDigitalButtonPressed()
{
    return !(PINB & _BV(PINB7));
 930:	90 95       	com	r25
 932:	99 1f       	adc	r25, r25
 934:	99 27       	eor	r25, r25
 936:	99 1f       	adc	r25, r25
 938:	80 91 08 01 	lds	r24, 0x0108

//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::setSioLevel(bool active)
{
    _sioLevel = active;
 93c:	90 fb       	bst	r25, 0
 93e:	80 f9       	bld	r24, 0
 940:	80 93 08 01 	sts	0x0108, r24
 944:	91 11       	cpse	r25, r1
uint8_t StackBase<T, PDI, PDO, SpiSsHndlr>::driveModeBits() const
{
    switch (StackT::SIO_DRIVE_MODE)
    {
    case DRIVE_MODE_PUSH_PULL:
        return _sioLevel ? Phy::CTL_HS : Phy::CTL_LS;
 946:	02 c0       	rjmp	.+4      	; 0x94c <_ZN7DemoApp3runEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x36>
 948:	91 e0       	ldi	r25, 0x01	; 1
 94a:	01 c0       	rjmp	.+2      	; 0x94e <_ZN7DemoApp3runEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x38>
 94c:	92 e0       	ldi	r25, 0x02	; 2
 94e:	8f ef       	ldi	r24, 0xFF	; 255
    bool driven = (hslsBits != 0);

    // we need to switch to IO-Link mode after 1ms to detect a wake-up
    if (driven)
    {
        _hiZCounter = -1;
 950:	80 93 07 01 	sts	0x0107, r24
 954:	81 e0       	ldi	r24, 0x01	; 1
    else if (wasDriven)  
    {
        _hiZCounter = 10;
    }

    wasDriven = driven;
 956:	80 93 00 01 	sts	0x0100, r24
 95a:	94 60       	ori	r25, 0x04	; 4
    uint8_t sioBit = (!driven && (_hiZCounter < 0)) 
        ? Phy::CTL_IOLINK_MODE 
        : Phy::CTL_SIO_MODE;

    return StackBase::registerWrite(Phy::REG_CTL, 
        StackT::PHY_CTL_SCT | StackT::PHY_CTL_MODE | sioBit | hslsBits);
 95c:	2a 98       	cbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 95e:	82 e8       	ldi	r24, 0x82	; 130
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 960:	8e bd       	out	0x2e, r24	; 46
 962:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 964:	07 fe       	sbrs	r0, 7
 966:	fd cf       	rjmp	.-6      	; 0x962 <_ZN7DemoApp3runEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x4c>
 968:	8e b5       	in	r24, 0x2e	; 46
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 96a:	9e bd       	out	0x2e, r25	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 96c:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 96e:	07 fe       	sbrs	r0, 7
 970:	fd cf       	rjmp	.-6      	; 0x96c <_ZN7DemoApp3runEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE+0x56>
 972:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 974:	ce 01       	movw	r24, r28
        // when in SIOActive mode, use digital input to control CQ line
    	Stack::instance.setSioLevel(isDigitalButtonPressed());
    }

    // update process data
    updateProcessInputData();
 976:	df 91       	pop	r29
}
 978:	cf 91       	pop	r28
 97a:	6b cf       	rjmp	.-298    	; 0x852 <_ZN7DemoApp22updateProcessInputDataEv>

0000097c <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9configureEv>:
        // when in SIOActive mode, use digital input to control CQ line
    	Stack::instance.setSioLevel(isDigitalButtonPressed());
    }

    // update process data
    updateProcessInputData();
 97c:	cf 93       	push	r28
 97e:	df 93       	push	r29
    return StackBase::registerRead(Phy::REG_TEMP);
}

//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::configure()
 980:	ec 01       	movw	r28, r24
    DORD   = 1'b0   - MSB first
    MSTR   = 1'b1   - Master
    CPOL   = 1'b1   - clock idles high
    CPHA   = 1'b1   - sample on trailing edge
    SPR    = 2'b00  - fosc/2 */
    SPCR = _BV(SPE) | _BV(MSTR) | _BV(CPOL) | _BV(CPHA);
 982:	8c e5       	ldi	r24, 0x5C	; 92
 984:	8c bd       	out	0x2c, r24	; 44

    /* and the SPI2X bit to speed it up */
    SPSR = _BV(SPI2X);
 986:	81 e0       	ldi	r24, 0x01	; 1
 988:	8d bd       	out	0x2d, r24	; 45

    /* Data direction in the SPI bits, PB2/SS, PB5/SCK
    and PB3/MOSI are outputs.  Drive SS high in advance */
    PORTB |= _BV(PORTB2) | _BV(PORTB5);
 98a:	85 b1       	in	r24, 0x05	; 5
 98c:	84 62       	ori	r24, 0x24	; 36
 98e:	85 b9       	out	0x05, r24	; 5
    PORTB &= ~(_BV(PORTB3)); 
 990:	2b 98       	cbi	0x05, 3	; 5
    DDRB  |= _BV(DDB5) | _BV(DDB3) | _BV(DDB2);
 992:	84 b1       	in	r24, 0x04	; 4
 994:	8c 62       	ori	r24, 0x2C	; 44
 996:	84 b9       	out	0x04, r24	; 4
    DDRB  &= ~(_BV(DDB4));
 998:	24 98       	cbi	0x04, 4	; 4
        HIBYTE(StackT::DEVICE_ID),                      // PAGE_DEVICE_ID_2
        LOBYTE(StackT::DEVICE_ID)                       // PAGE_DEVICE_ID_3
    };

    // copy the default parameters from flash to RAM
    (void)memcpy_P(directParameter, directDefaultConfig, sizeof(directDefaultConfig));
 99a:	40 e2       	ldi	r20, 0x20	; 32
 99c:	50 e0       	ldi	r21, 0x00	; 0
 99e:	68 e6       	ldi	r22, 0x68	; 104
 9a0:	70 e0       	ldi	r23, 0x00	; 0
 9a2:	8b e1       	ldi	r24, 0x1B	; 27
 9a4:	91 e0       	ldi	r25, 0x01	; 1
 9a6:	93 d0       	rcall	.+294    	; 0xace <memcpy_P>
 9a8:	18 82       	st	Y, r1

    // stack initial state is STACK_MODE_SIO operation
    _ddlMode = IoLink::DDL_MODE_IDLE;
 9aa:	1a 82       	std	Y+2, r1	; 0x02

    // set up the process data buffers and default process data
    _processDataIn.isValid = false;
 9ac:	1c 82       	std	Y+4, r1	; 0x04
    _processDataOut.isValid = false;
 9ae:	80 91 68 00 	lds	r24, 0x0068
{
    // Configure and enable interrupt
    // 
    // Only pin change interrupts are available, so the routine must check
    // the level before returning
    PCICR  |= _BV(PCIE1);
 9b2:	82 60       	ori	r24, 0x02	; 2
 9b4:	80 93 68 00 	sts	0x0068, r24
 9b8:	80 91 6c 00 	lds	r24, 0x006C
    PCMSK1 |= _BV(PCINT8);
 9bc:	81 60       	ori	r24, 0x01	; 1
 9be:	80 93 6c 00 	sts	0x006C, r24
 9c2:	02 de       	rcall	.-1020   	; 0x5c8 <__vector_4>

    // call ISR handler
    PCINT1_vect();
 9c4:	1d 82       	std	Y+5, r1	; 0x05
 9c6:	15 bc       	out	0x25, r1	; 37
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::startCallbackTimer(uint8_t delay)
{
    // reset dead cycle timer
    _deadCycleCtr = 0;
 9c8:	16 bc       	out	0x26, r1	; 38

    // disable timer
    TCCR0B = 0;
 9ca:	85 b3       	in	r24, 0x15	; 21
    TCNT0 = 0;
 9cc:	87 60       	ori	r24, 0x07	; 7

    // clear any outstanding interrupt requests
    TIFR0 |= _BV(OCF0B) | _BV(OCF0A) | _BV(TOV0);
 9ce:	85 bb       	out	0x15, r24	; 21
 9d0:	8a 85       	ldd	r24, Y+10	; 0x0a
 9d2:	9b 85       	ldd	r25, Y+11	; 0x0b
    
    // check if we need to force recalculation of cycle period
    if (_cyclePeriod == 0)
 9d4:	00 97       	sbiw	r24, 0x00	; 0
 9d6:	49 f5       	brne	.+82     	; 0xa2a <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9configureEv+0xae>
 9d8:	28 81       	ld	r18, Y
 9da:	24 30       	cpi	r18, 0x04	; 4
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::updateCyclePeriod()
{
    // get period
    uint8_t cycleParam = 0;
    if (_ddlMode == IoLink::DDL_MODE_OPERATE)
 9dc:	21 f4       	brne	.+8      	; 0x9e6 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9configureEv+0x6a>
 9de:	20 91 1c 01 	lds	r18, 0x011C
     * 
     * \param address   Parameter index
     * \return          Read value
     * 
     */
    uint8_t             parameterRead(uint8_t address) const { return directParameter[address]; }
 9e2:	21 11       	cpse	r18, r1
 9e4:	02 c0       	rjmp	.+4      	; 0x9ea <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9configureEv+0x6e>
    if (_ddlMode == IoLink::DDL_MODE_OPERATE)
    {
        cycleParam = parameterRead(IoLink::PAGE_MASTER_CYCLE_TIME);
    }

    if (cycleParam == 0)
 9e6:	20 91 1d 01 	lds	r18, 0x011D
     * 
     * \param address   Parameter index
     * \return          Read value
     * 
     */
    uint8_t             parameterRead(uint8_t address) const { return directParameter[address]; }
 9ea:	24 30       	cpi	r18, 0x04	; 4
 9ec:	e0 f0       	brcs	.+56     	; 0xa26 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9configureEv+0xaa>
        // MasterCycleTime hasn't been set yet => use MinCycleTime
        cycleParam = parameterRead(IoLink::PAGE_MIN_CYCLE_TIME);
    }

    // decode parameter into 1/10ms
    _cyclePeriod = DECODE_CYCLE_TIME(cycleParam);
 9ee:	20 34       	cpi	r18, 0x40	; 64
 9f0:	18 f4       	brcc	.+6      	; 0x9f8 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9configureEv+0x7c>
 9f2:	82 2f       	mov	r24, r18
 9f4:	90 e0       	ldi	r25, 0x00	; 0
 9f6:	17 c0       	rjmp	.+46     	; 0xa26 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9configureEv+0xaa>
 9f8:	32 2f       	mov	r19, r18
 9fa:	30 7c       	andi	r19, 0xC0	; 192
 9fc:	30 34       	cpi	r19, 0x40	; 64
 9fe:	49 f4       	brne	.+18     	; 0xa12 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9configureEv+0x96>
 a00:	84 e0       	ldi	r24, 0x04	; 4
 a02:	28 9f       	mul	r18, r24
 a04:	90 01       	movw	r18, r0
 a06:	11 24       	eor	r1, r1
 a08:	33 27       	eor	r19, r19
 a0a:	c9 01       	movw	r24, r18
 a0c:	80 5c       	subi	r24, 0xC0	; 192
 a0e:	9f 4f       	sbci	r25, 0xFF	; 255
 a10:	0a c0       	rjmp	.+20     	; 0xa26 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9configureEv+0xaa>
 a12:	30 38       	cpi	r19, 0x80	; 128
 a14:	41 f4       	brne	.+16     	; 0xa26 <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9configureEv+0xaa>
 a16:	2f 73       	andi	r18, 0x3F	; 63
 a18:	80 e1       	ldi	r24, 0x10	; 16
 a1a:	28 9f       	mul	r18, r24
 a1c:	90 01       	movw	r18, r0
 a1e:	11 24       	eor	r1, r1
 a20:	c9 01       	movw	r24, r18
 a22:	80 5c       	subi	r24, 0xC0	; 192
 a24:	9e 4f       	sbci	r25, 0xFE	; 254
 a26:	9b 87       	std	Y+11, r25	; 0x0b
 a28:	8a 87       	std	Y+10, r24	; 0x0a
 a2a:	81 e0       	ldi	r24, 0x01	; 1
 a2c:	90 e0       	ldi	r25, 0x00	; 0
    {
        updateCyclePeriod();
    }

    // initialize cycle timer
    _cycleTimer = delay + 1;
 a2e:	9d 87       	std	Y+13, r25	; 0x0d
 a30:	8c 87       	std	Y+12, r24	; 0x0c
 a32:	84 e0       	ldi	r24, 0x04	; 4
 a34:	80 93 6e 00 	sts	0x006E, r24

    if (_cycleTimer > 0)
    {      
        // Timer/Counter0 Output Compare Match B Interrupt Enable
        TIMSK0 = _BV(OCIE0B);
 a38:	82 e0       	ldi	r24, 0x02	; 2
 a3a:	84 bd       	out	0x24, r24	; 36

        // clear Timer on Compare Match A
        TCCR0A = _BV(WGM01);
 a3c:	94 e6       	ldi	r25, 0x64	; 100
 a3e:	97 bd       	out	0x27, r25	; 39

        // generate 0.1ms cycles
#if F_CPU < 20000000
        OCR0B = OCR0A = F_CPU / 80000;
 a40:	98 bd       	out	0x28, r25	; 40
 a42:	85 bd       	out	0x25, r24	; 37
 a44:	df 91       	pop	r29
        TCCR0B = _BV(CS01);             // pre-scaler clkIO/8
 a46:	cf 91       	pop	r28
    configureStackBase();
    Phy::configure();

    // start timer responsible for calling the application "main loop"
    startCallbackTimer();
};
 a48:	08 95       	ret

00000a4a <main>:
 a4a:	2f ef       	ldi	r18, 0xFF	; 255
 a4c:	81 ee       	ldi	r24, 0xE1	; 225
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 a4e:	94 e0       	ldi	r25, 0x04	; 4
 a50:	21 50       	subi	r18, 0x01	; 1
 a52:	80 40       	sbci	r24, 0x00	; 0
 a54:	90 40       	sbci	r25, 0x00	; 0
 a56:	e1 f7       	brne	.-8      	; 0xa50 <main+0x6>
 a58:	00 c0       	rjmp	.+0      	; 0xa5a <main+0x10>
 a5a:	00 00       	nop
public:
    //! setup the HW configuration
    static void configure()
    {
        // Port PD4 and PD5 as output
        DDRD  |= _BV(DDD4) | _BV(DDD5);
 a5c:	8a b1       	in	r24, 0x0a	; 10
 a5e:	80 63       	ori	r24, 0x30	; 48
 a60:	8a b9       	out	0x0a, r24	; 10
        {
            PORTD |= _BV(PORTD4);
        }
        else
        {
            PORTD &= ~(_BV(PORTD4));
 a62:	5c 98       	cbi	0x0b, 4	; 11
    // instantiate DemoApp
    DemoApp& theApp = DemoApp::instance;

    // configure all software modules
    DebugPin::configure();
    DemoApp::configure();   
 a64:	63 de       	rcall	.-826    	; 0x72c <_ZN7DemoApp9configureEv>
 a66:	81 e0       	ldi	r24, 0x01	; 1
    Stack::instance.configure();
 a68:	91 e0       	ldi	r25, 0x01	; 1
 a6a:	88 df       	rcall	.-240    	; 0x97c <_ZN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9configureEv>
 a6c:	78 94       	sei
 a6e:	83 b7       	in	r24, 0x33	; 51

    // enable interrupts
    sei();
 a70:	81 7f       	andi	r24, 0xF1	; 241

    // select sleep mode
    set_sleep_mode(SLEEP_MODE_IDLE);
 a72:	83 bf       	out	0x33, r24	; 51
 a74:	83 b7       	in	r24, 0x33	; 51
 a76:	81 60       	ori	r24, 0x01	; 1

    // enter infinite loop: processing is interrupt controlled from now on
    for (;;)
    {
        // enter sleep until interrupt wakes us up
        sleep_mode();
 a78:	83 bf       	out	0x33, r24	; 51
 a7a:	88 95       	sleep
 a7c:	83 b7       	in	r24, 0x33	; 51
 a7e:	8e 7f       	andi	r24, 0xFE	; 254
 a80:	83 bf       	out	0x33, r24	; 51
 a82:	80 91 12 01 	lds	r24, 0x0112
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
bool StackBase<T, PDI, PDO, SpiSsHndlr>::canRunUserCode(const Parameter*& lastWrittenParameter)
{
    // allow execution of user code?
    if (!_runUserCode)
 a86:	80 ff       	sbrs	r24, 0
 a88:	f5 cf       	rjmp	.-22     	; 0xa74 <main+0x2a>
 a8a:	8e 7f       	andi	r24, 0xFE	; 254
 a8c:	80 93 12 01 	sts	0x0112, r24
        return false;

    // reset flag
    _runUserCode = false;
 a90:	81 ff       	sbrs	r24, 1
 a92:	06 c0       	rjmp	.+12     	; 0xaa0 <main+0x56>

    // test for parameter write access
    if (_prmWriteAvailable)
 a94:	8d 7f       	andi	r24, 0xFD	; 253
 a96:	80 93 12 01 	sts	0x0112, r24
    {
        lastWrittenParameter = &_parameterWrite;

        // reset write access
        _prmWriteAvailable = false;
 a9a:	69 e0       	ldi	r22, 0x09	; 9
 a9c:	71 e0       	ldi	r23, 0x01	; 1
    _runUserCode = false;

    // test for parameter write access
    if (_prmWriteAvailable)
    {
        lastWrittenParameter = &_parameterWrite;
 a9e:	02 c0       	rjmp	.+4      	; 0xaa4 <main+0x5a>
 aa0:	60 e0       	ldi	r22, 0x00	; 0
 aa2:	70 e0       	ldi	r23, 0x00	; 0
        // reset write access
        _prmWriteAvailable = false;
    }
    else
    {
        lastWrittenParameter = NULL;
 aa4:	80 91 6c 00 	lds	r24, 0x006C

//------------------------------------------------------------------------------
template <class SpiSsHndlr>
void PhyDriver<SpiSsHndlr>::stopInterrupt()
{
    PCMSK1 &= ~(_BV(PCINT8));
 aa8:	8e 7f       	andi	r24, 0xFE	; 254
 aaa:	80 93 6c 00 	sts	0x006C, r24
 aae:	8b e3       	ldi	r24, 0x3B	; 59
 ab0:	91 e0       	ldi	r25, 0x01	; 1
        // check if it's time to run user code
        const Stack::Parameter* paramWrite;
        if (Stack::instance.canRunUserCode(paramWrite))
        {
            Stack::instance.stopInterrupt();
            theApp.run(paramWrite);
 ab2:	31 df       	rcall	.-414    	; 0x916 <_ZN7DemoApp3runEPKN9StackBaseI14StackMultiByteLi1ELi1E16DefaultSsHandlerE9ParameterE>
 ab4:	80 91 6c 00 	lds	r24, 0x006C
 ab8:	81 60       	ori	r24, 0x01	; 1

//------------------------------------------------------------------------------
template <class SpiSsHndlr>
void PhyDriver<SpiSsHndlr>::restartInterrupt()
{
    PCMSK1 |= _BV(PCINT8);
 aba:	80 93 6c 00 	sts	0x006C, r24
 abe:	84 dd       	rcall	.-1272   	; 0x5c8 <__vector_4>
 ac0:	d9 cf       	rjmp	.-78     	; 0xa74 <main+0x2a>

00000ac2 <__tablejump2__>:
 ac2:	ee 0f       	add	r30, r30

    // call ISR handler
    PCINT1_vect();
 ac4:	ff 1f       	adc	r31, r31
 ac6:	05 90       	lpm	r0, Z+
 ac8:	f4 91       	lpm	r31, Z
 aca:	e0 2d       	mov	r30, r0
 acc:	09 94       	ijmp

00000ace <memcpy_P>:
 ace:	fb 01       	movw	r30, r22
 ad0:	dc 01       	movw	r26, r24
 ad2:	02 c0       	rjmp	.+4      	; 0xad8 <memcpy_P+0xa>
 ad4:	05 90       	lpm	r0, Z+
 ad6:	0d 92       	st	X+, r0
 ad8:	41 50       	subi	r20, 0x01	; 1
 ada:	50 40       	sbci	r21, 0x00	; 0
 adc:	d8 f7       	brcc	.-10     	; 0xad4 <memcpy_P+0x6>
 ade:	08 95       	ret

00000ae0 <_exit>:
 ae0:	f8 94       	cli

00000ae2 <__stop_program>:
 ae2:	ff cf       	rjmp	.-2      	; 0xae2 <__stop_program>
