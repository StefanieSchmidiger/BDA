
ministack.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000bbe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000b04  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000041  00800100  00800100  00000bb8  2**0
                  ALLOC
  3 .fuse         00000003  00820000  00820000  00000bb8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .signature    00000003  00840000  00840000  00000bbb  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .comment      00000030  00000000  00000000  00000bbe  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000bf0  2**2
                  CONTENTS, READONLY
  7 .debug_aranges 000000e0  00000000  00000000  00000c30  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   0000662f  00000000  00000000  00000d10  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000012dd  00000000  00000000  0000733f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00000a81  00000000  00000000  0000861c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  0000021c  00000000  00000000  000090a0  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    0000293a  00000000  00000000  000092bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00001a13  00000000  00000000  0000bbf6  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000000e0  00000000  00000000  0000d609  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	44 c0       	rjmp	.+136    	; 0x8a <__ctors_end>
   2:	00 00       	nop
   4:	5c c0       	rjmp	.+184    	; 0xbe <__bad_interrupt>
   6:	00 00       	nop
   8:	5a c0       	rjmp	.+180    	; 0xbe <__bad_interrupt>
   a:	00 00       	nop
   c:	58 c0       	rjmp	.+176    	; 0xbe <__bad_interrupt>
   e:	00 00       	nop
  10:	df c2       	rjmp	.+1470   	; 0x5d0 <__vector_4>
  12:	00 00       	nop
  14:	54 c0       	rjmp	.+168    	; 0xbe <__bad_interrupt>
  16:	00 00       	nop
  18:	52 c0       	rjmp	.+164    	; 0xbe <__bad_interrupt>
  1a:	00 00       	nop
  1c:	50 c0       	rjmp	.+160    	; 0xbe <__bad_interrupt>
  1e:	00 00       	nop
  20:	4e c0       	rjmp	.+156    	; 0xbe <__bad_interrupt>
  22:	00 00       	nop
  24:	4c c0       	rjmp	.+152    	; 0xbe <__bad_interrupt>
  26:	00 00       	nop
  28:	4a c0       	rjmp	.+148    	; 0xbe <__bad_interrupt>
  2a:	00 00       	nop
  2c:	48 c0       	rjmp	.+144    	; 0xbe <__bad_interrupt>
  2e:	00 00       	nop
  30:	46 c0       	rjmp	.+140    	; 0xbe <__bad_interrupt>
  32:	00 00       	nop
  34:	44 c0       	rjmp	.+136    	; 0xbe <__bad_interrupt>
  36:	00 00       	nop
  38:	42 c0       	rjmp	.+132    	; 0xbe <__bad_interrupt>
  3a:	00 00       	nop
  3c:	56 c0       	rjmp	.+172    	; 0xea <__vector_15>
  3e:	00 00       	nop
  40:	3e c0       	rjmp	.+124    	; 0xbe <__bad_interrupt>
  42:	00 00       	nop
  44:	3c c0       	rjmp	.+120    	; 0xbe <__bad_interrupt>
  46:	00 00       	nop
  48:	3a c0       	rjmp	.+116    	; 0xbe <__bad_interrupt>
  4a:	00 00       	nop
  4c:	38 c0       	rjmp	.+112    	; 0xbe <__bad_interrupt>
  4e:	00 00       	nop
  50:	36 c0       	rjmp	.+108    	; 0xbe <__bad_interrupt>
  52:	00 00       	nop
  54:	34 c0       	rjmp	.+104    	; 0xbe <__bad_interrupt>
  56:	00 00       	nop
  58:	32 c0       	rjmp	.+100    	; 0xbe <__bad_interrupt>
  5a:	00 00       	nop
  5c:	30 c0       	rjmp	.+96     	; 0xbe <__bad_interrupt>
  5e:	00 00       	nop
  60:	2e c0       	rjmp	.+92     	; 0xbe <__bad_interrupt>
  62:	00 00       	nop
  64:	2c c0       	rjmp	.+88     	; 0xbe <__bad_interrupt>
	...

00000068 <__trampolines_end>:
  68:	00 00       	nop
  6a:	05 00       	.word	0x0005	; ????
  6c:	11 c3       	rjmp	.+1570   	; 0x690 <__vector_4+0xc0>
  6e:	00 01       	movw	r0, r0
  70:	a6 12       	cpse	r10, r22
  72:	34 56       	subi	r19, 0x64	; 100
	...

00000088 <__ctors_start>:
  88:	81 03       	fmuls	r16, r17

0000008a <__ctors_end>:
  8a:	11 24       	eor	r1, r1
  8c:	1f be       	out	0x3f, r1	; 63
  8e:	cf ef       	ldi	r28, 0xFF	; 255
  90:	d8 e0       	ldi	r29, 0x08	; 8
  92:	de bf       	out	0x3e, r29	; 62
  94:	cd bf       	out	0x3d, r28	; 61

00000096 <__do_clear_bss>:
  96:	21 e0       	ldi	r18, 0x01	; 1
  98:	a0 e0       	ldi	r26, 0x00	; 0
  9a:	b1 e0       	ldi	r27, 0x01	; 1
  9c:	01 c0       	rjmp	.+2      	; 0xa0 <.do_clear_bss_start>

0000009e <.do_clear_bss_loop>:
  9e:	1d 92       	st	X+, r1

000000a0 <.do_clear_bss_start>:
  a0:	a1 34       	cpi	r26, 0x41	; 65
  a2:	b2 07       	cpc	r27, r18
  a4:	e1 f7       	brne	.-8      	; 0x9e <.do_clear_bss_loop>

000000a6 <__do_global_ctors>:
  a6:	10 e0       	ldi	r17, 0x00	; 0
  a8:	c5 e4       	ldi	r28, 0x45	; 69
  aa:	d0 e0       	ldi	r29, 0x00	; 0
  ac:	03 c0       	rjmp	.+6      	; 0xb4 <__do_global_ctors+0xe>
  ae:	21 97       	sbiw	r28, 0x01	; 1
  b0:	fe 01       	movw	r30, r28
  b2:	17 d5       	rcall	.+2606   	; 0xae2 <__tablejump2__>
  b4:	c4 34       	cpi	r28, 0x44	; 68
  b6:	d1 07       	cpc	r29, r17
  b8:	d1 f7       	brne	.-12     	; 0xae <__do_global_ctors+0x8>
  ba:	d7 d4       	rcall	.+2478   	; 0xa6a <main>
  bc:	21 c5       	rjmp	.+2626   	; 0xb00 <_exit>

000000be <__bad_interrupt>:
  be:	a0 cf       	rjmp	.-192    	; 0x0 <__vectors>

000000c0 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE6odReadEhh.isra.1>:
template <class T, int PDI, int PDO, class SpiSsHndlr>
uint8_t StackBase<T, PDI, PDO, SpiSsHndlr>::odRead(uint8_t channel, uint8_t address)
{
    uint8_t data;

    switch (channel)
  c0:	80 32       	cpi	r24, 0x20	; 32
  c2:	19 f0       	breq	.+6      	; 0xca <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE6odReadEhh.isra.1+0xa>
  c4:	80 34       	cpi	r24, 0x40	; 64
  c6:	31 f0       	breq	.+12     	; 0xd4 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE6odReadEhh.isra.1+0x14>
  c8:	0d c0       	rjmp	.+26     	; 0xe4 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE6odReadEhh.isra.1+0x24>
    {
    case IoLink::MC_CHNL_PAGE:  // Direct parameter page channel
        data = directParameter[address];
  ca:	e6 2f       	mov	r30, r22
  cc:	f0 e0       	ldi	r31, 0x00	; 0
  ce:	e3 5e       	subi	r30, 0xE3	; 227
  d0:	fe 4f       	sbci	r31, 0xFE	; 254
  d2:	06 c0       	rjmp	.+12     	; 0xe0 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE6odReadEhh.isra.1+0x20>
        break;

    case IoLink::MC_CHNL_DIAG:  // Diagnosis channel
        if (address > 6)
  d4:	67 30       	cpi	r22, 0x07	; 7
  d6:	38 f4       	brcc	.+14     	; 0xe6 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE6odReadEhh.isra.1+0x26>
            break;

        data = eventPage[address];
  d8:	e6 2f       	mov	r30, r22
  da:	f0 e0       	ldi	r31, 0x00	; 0
  dc:	eb 5e       	subi	r30, 0xEB	; 235
  de:	fe 4f       	sbci	r31, 0xFE	; 254
  e0:	90 81       	ld	r25, Z
  e2:	01 c0       	rjmp	.+2      	; 0xe6 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE6odReadEhh.isra.1+0x26>
        break;

    default:            // SPDU and process data not handled
//        ASSERT(address == IoLink::MC_ADDR_ISDU_IDLE1 || address == IoLink::MC_ADDR_ISDU_IDLE2);
        data = 0;
  e4:	90 e0       	ldi	r25, 0x00	; 0
    }

    return data;
}
  e6:	89 2f       	mov	r24, r25
  e8:	08 95       	ret

000000ea <__vector_15>:
    }
}

// Interrupt on Timer0 compare match B
ISR(TIMER0_COMPB_vect)
{
  ea:	1f 92       	push	r1
  ec:	0f 92       	push	r0
  ee:	0f b6       	in	r0, 0x3f	; 63
  f0:	0f 92       	push	r0
  f2:	11 24       	eor	r1, r1
  f4:	2f 93       	push	r18
  f6:	3f 93       	push	r19
  f8:	8f 93       	push	r24
  fa:	9f 93       	push	r25
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::onTimer0CompBInterrupt()
{
    // decrement hiZ timer
    if (_hiZCounter >= 0 && --_hiZCounter < 0)
  fc:	80 91 09 01 	lds	r24, 0x0109
 100:	87 fd       	sbrc	r24, 7
 102:	1d c0       	rjmp	.+58     	; 0x13e <__vector_15+0x54>
 104:	81 50       	subi	r24, 0x01	; 1
 106:	80 93 09 01 	sts	0x0109, r24
 10a:	8f 3f       	cpi	r24, 0xFF	; 255
 10c:	c1 f4       	brne	.+48     	; 0x13e <__vector_15+0x54>
uint8_t StackBase<T, PDI, PDO, SpiSsHndlr>::driveModeBits() const
{
    switch (StackT::SIO_DRIVE_MODE)
    {
    case DRIVE_MODE_PUSH_PULL:
        return _sioLevel ? Phy::CTL_HS : Phy::CTL_LS;
 10e:	80 91 0a 01 	lds	r24, 0x010A
 112:	80 fd       	sbrc	r24, 0
 114:	26 c0       	rjmp	.+76     	; 0x162 <__vector_15+0x78>
 116:	81 e0       	ldi	r24, 0x01	; 1
    bool driven = (hslsBits != 0);

    // we need to switch to IO-Link mode after 1ms to detect a wake-up
    if (driven)
    {
        _hiZCounter = -1;
 118:	9f ef       	ldi	r25, 0xFF	; 255
 11a:	90 93 09 01 	sts	0x0109, r25
    else if (wasDriven)  
    {
        _hiZCounter = 10;
    }

    wasDriven = driven;
 11e:	91 e0       	ldi	r25, 0x01	; 1
 120:	90 93 00 01 	sts	0x0100, r25
    uint8_t sioBit = (!driven && (_hiZCounter < 0)) 
        ? Phy::CTL_IOLINK_MODE 
        : Phy::CTL_SIO_MODE;

    return StackBase::registerWrite(Phy::REG_CTL, 
        StackT::PHY_CTL_SCT | StackT::PHY_CTL_MODE | sioBit | hslsBits);
 124:	84 60       	ori	r24, 0x04	; 4
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 126:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 128:	92 e8       	ldi	r25, 0x82	; 130
 12a:	9e bd       	out	0x2e, r25	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 12c:	0d b4       	in	r0, 0x2d	; 45
 12e:	07 fe       	sbrs	r0, 7
 130:	fd cf       	rjmp	.-6      	; 0x12c <__vector_15+0x42>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 132:	9e b5       	in	r25, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 134:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 136:	0d b4       	in	r0, 0x2d	; 45
 138:	07 fe       	sbrs	r0, 7
 13a:	fd cf       	rjmp	.-6      	; 0x136 <__vector_15+0x4c>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 13c:	2a 9a       	sbi	0x05, 2	; 5
    {
        stack().setSioActive();
    }

    // check if cycle timer elapsed
    if (_cycleTimer > 0 && --_cycleTimer == 0)
 13e:	20 91 0f 01 	lds	r18, 0x010F
 142:	30 91 10 01 	lds	r19, 0x0110
 146:	80 91 14 01 	lds	r24, 0x0114
 14a:	21 15       	cp	r18, r1
 14c:	31 05       	cpc	r19, r1
 14e:	59 f0       	breq	.+22     	; 0x166 <__vector_15+0x7c>
 150:	21 50       	subi	r18, 0x01	; 1
 152:	31 09       	sbc	r19, r1
 154:	30 93 10 01 	sts	0x0110, r19
 158:	20 93 0f 01 	sts	0x010F, r18
 15c:	23 2b       	or	r18, r19
 15e:	39 f0       	breq	.+14     	; 0x16e <__vector_15+0x84>
 160:	02 c0       	rjmp	.+4      	; 0x166 <__vector_15+0x7c>
uint8_t StackBase<T, PDI, PDO, SpiSsHndlr>::driveModeBits() const
{
    switch (StackT::SIO_DRIVE_MODE)
    {
    case DRIVE_MODE_PUSH_PULL:
        return _sioLevel ? Phy::CTL_HS : Phy::CTL_LS;
 162:	82 e0       	ldi	r24, 0x02	; 2
 164:	d9 cf       	rjmp	.-78     	; 0x118 <__vector_15+0x2e>
        }
    }
    else
    {
        // too late for user code
        _runUserCode = false;
 166:	8e 7f       	andi	r24, 0xFE	; 254
 168:	80 93 14 01 	sts	0x0114, r24
 16c:	33 c0       	rjmp	.+102    	; 0x1d4 <__vector_15+0xea>

    // check if cycle timer elapsed
    if (_cycleTimer > 0 && --_cycleTimer == 0)
    {
        // user code may run
        _runUserCode = true;
 16e:	81 60       	ori	r24, 0x01	; 1
 170:	80 93 14 01 	sts	0x0114, r24

        // restart cycle timer
        _cycleTimer = _cyclePeriod;
 174:	80 91 0d 01 	lds	r24, 0x010D
 178:	90 91 0e 01 	lds	r25, 0x010E
 17c:	90 93 10 01 	sts	0x0110, r25
 180:	80 93 0f 01 	sts	0x010F, r24

        // advance the count of dead cycles
        if (_deadCycleCtr != 0xff)
 184:	80 91 08 01 	lds	r24, 0x0108
 188:	8f 3f       	cpi	r24, 0xFF	; 255
 18a:	19 f0       	breq	.+6      	; 0x192 <__vector_15+0xa8>
        {
            ++_deadCycleCtr;
 18c:	8f 5f       	subi	r24, 0xFF	; 255
 18e:	80 93 08 01 	sts	0x0108, r24
        }

        // check if we need to switch to SIO mode
        if (_fallbackCounter > 0 && --_fallbackCounter == 0)
 192:	80 91 13 01 	lds	r24, 0x0113
 196:	88 23       	and	r24, r24
 198:	29 f0       	breq	.+10     	; 0x1a4 <__vector_15+0xba>
 19a:	81 50       	subi	r24, 0x01	; 1
 19c:	80 93 13 01 	sts	0x0113, r24
 1a0:	88 23       	and	r24, r24
 1a2:	a9 f0       	breq	.+42     	; 0x1ce <__vector_15+0xe4>
        {
            _ddlMode = IoLink::DDL_MODE_IDLE;
        }

        // update LED register if necessary
        if (_savedLedRegister != _ledRegister)
 1a4:	80 91 12 01 	lds	r24, 0x0112
 1a8:	90 91 11 01 	lds	r25, 0x0111
 1ac:	98 17       	cp	r25, r24
 1ae:	91 f0       	breq	.+36     	; 0x1d4 <__vector_15+0xea>
        {
            _savedLedRegister = _ledRegister;
 1b0:	80 93 11 01 	sts	0x0111, r24
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 1b4:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 1b6:	96 e8       	ldi	r25, 0x86	; 134
 1b8:	9e bd       	out	0x2e, r25	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 1ba:	0d b4       	in	r0, 0x2d	; 45
 1bc:	07 fe       	sbrs	r0, 7
 1be:	fd cf       	rjmp	.-6      	; 0x1ba <__vector_15+0xd0>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 1c0:	9e b5       	in	r25, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 1c2:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 1c4:	0d b4       	in	r0, 0x2d	; 45
 1c6:	07 fe       	sbrs	r0, 7
 1c8:	fd cf       	rjmp	.-6      	; 0x1c4 <__vector_15+0xda>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 1ca:	2a 9a       	sbi	0x05, 2	; 5
 1cc:	03 c0       	rjmp	.+6      	; 0x1d4 <__vector_15+0xea>
        }

        // check if we need to switch to SIO mode
        if (_fallbackCounter > 0 && --_fallbackCounter == 0)
        {
            _ddlMode = IoLink::DDL_MODE_IDLE;
 1ce:	10 92 01 01 	sts	0x0101, r1
 1d2:	e8 cf       	rjmp	.-48     	; 0x1a4 <__vector_15+0xba>
    StackMultiByte::instance.onTimer0CompBInterrupt();
}
 1d4:	9f 91       	pop	r25
 1d6:	8f 91       	pop	r24
 1d8:	3f 91       	pop	r19
 1da:	2f 91       	pop	r18
 1dc:	0f 90       	pop	r0
 1de:	0f be       	out	0x3f, r0	; 63
 1e0:	0f 90       	pop	r0
 1e2:	1f 90       	pop	r1
 1e4:	18 95       	reti

000001e6 <_ZN9PhyDriverI16DefaultSsHandlerE19registerAbortAccessEv>:

//------------------------------------------------------------------------------
template <class SpiSsHndlr> 
void PhyDriver<SpiSsHndlr>::registerAbortAccess()
{
    if (_ssHndlr.asserted())
 1e6:	2a 99       	sbic	0x05, 2	; 5
 1e8:	04 c0       	rjmp	.+8      	; 0x1f2 <_ZN9PhyDriverI16DefaultSsHandlerE19registerAbortAccessEv+0xc>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 1ea:	0d b4       	in	r0, 0x2d	; 45
 1ec:	07 fe       	sbrs	r0, 7
 1ee:	fd cf       	rjmp	.-6      	; 0x1ea <_ZN9PhyDriverI16DefaultSsHandlerE19registerAbortAccessEv+0x4>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 1f0:	2a 9a       	sbi	0x05, 2	; 5
 1f2:	08 95       	ret

000001f4 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE12configurePhyEv>:
    startCallbackTimer();
};

//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::configurePhy()
 1f4:	fc 01       	movw	r30, r24
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 1f6:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 1f8:	80 e8       	ldi	r24, 0x80	; 128
 1fa:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 1fc:	0d b4       	in	r0, 0x2d	; 45
 1fe:	07 fe       	sbrs	r0, 7
 200:	fd cf       	rjmp	.-6      	; 0x1fc <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE12configurePhyEv+0x8>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 202:	88 e0       	ldi	r24, 0x08	; 8
 204:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 206:	0d b4       	in	r0, 0x2d	; 45
 208:	07 fe       	sbrs	r0, 7
 20a:	fd cf       	rjmp	.-6      	; 0x206 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE12configurePhyEv+0x12>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 20c:	82 e3       	ldi	r24, 0x32	; 50
 20e:	8e bd       	out	0x2e, r24	; 46
uint8_t StackBase<T, PDI, PDO, SpiSsHndlr>::driveModeBits() const
{
    switch (StackT::SIO_DRIVE_MODE)
    {
    case DRIVE_MODE_PUSH_PULL:
        return _sioLevel ? Phy::CTL_HS : Phy::CTL_LS;
 210:	81 85       	ldd	r24, Z+9	; 0x09
 212:	80 fd       	sbrc	r24, 0
 214:	02 c0       	rjmp	.+4      	; 0x21a <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE12configurePhyEv+0x26>
 216:	91 e0       	ldi	r25, 0x01	; 1
 218:	01 c0       	rjmp	.+2      	; 0x21c <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE12configurePhyEv+0x28>
 21a:	92 e0       	ldi	r25, 0x02	; 2
    
    // REG_CTL
    StackBase::registerWriteNext(StackT::PHY_CTL_SCT | 
                                 StackT::PHY_CTL_MODE | 
                                 Phy::CTL_SIO_MODE | 
                                 driveModeBits());
 21c:	94 60       	ori	r25, 0x04	; 4
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 21e:	0d b4       	in	r0, 0x2d	; 45
 220:	07 fe       	sbrs	r0, 7
 222:	fd cf       	rjmp	.-6      	; 0x21e <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE12configurePhyEv+0x2a>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 224:	9e bd       	out	0x2e, r25	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 226:	0d b4       	in	r0, 0x2d	; 45
 228:	07 fe       	sbrs	r0, 7
 22a:	fd cf       	rjmp	.-6      	; 0x226 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE12configurePhyEv+0x32>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 22c:	1e bc       	out	0x2e, r1	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 22e:	0d b4       	in	r0, 0x2d	; 45
 230:	07 fe       	sbrs	r0, 7
 232:	fd cf       	rjmp	.-6      	; 0x22e <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE12configurePhyEv+0x3a>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 234:	83 e0       	ldi	r24, 0x03	; 3
 236:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 238:	0d b4       	in	r0, 0x2d	; 45
 23a:	07 fe       	sbrs	r0, 7
 23c:	fd cf       	rjmp	.-6      	; 0x238 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE12configurePhyEv+0x44>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 23e:	1e bc       	out	0x2e, r1	; 46
    
    // REG_STATUS (HMT7742) / REG_TEMP (HMT7748) - (dummy write)
    Phy::registerWriteNext(0);        
    
    // LEDs
    StackBase::registerWriteNext(this->_ledRegister);        
 240:	81 89       	ldd	r24, Z+17	; 0x11
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 242:	0d b4       	in	r0, 0x2d	; 45
 244:	07 fe       	sbrs	r0, 7
 246:	fd cf       	rjmp	.-6      	; 0x242 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE12configurePhyEv+0x4e>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 248:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 24a:	0d b4       	in	r0, 0x2d	; 45
 24c:	07 fe       	sbrs	r0, 7
 24e:	fd cf       	rjmp	.-6      	; 0x24a <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE12configurePhyEv+0x56>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 250:	2a 9a       	sbi	0x05, 2	; 5
#endif

    registerWriteDone();

    // set the stack to SIO mode to be in sync with the PHY.
    _ddlMode = IoLink::DDL_MODE_IDLE;
 252:	10 82       	st	Z, r1
 254:	08 95       	ret

00000256 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE18startCallbackTimerEh>:
}


//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::startCallbackTimer(uint8_t delay)
 256:	fc 01       	movw	r30, r24
{
    // reset dead cycle timer
    _deadCycleCtr = 0;
 258:	17 82       	std	Z+7, r1	; 0x07

    // disable timer
    TCCR0B = 0;
 25a:	15 bc       	out	0x25, r1	; 37
    TCNT0 = 0;
 25c:	16 bc       	out	0x26, r1	; 38

    // clear any outstanding interrupt requests
    TIFR0 |= _BV(OCF0B) | _BV(OCF0A) | _BV(TOV0);
 25e:	85 b3       	in	r24, 0x15	; 21
 260:	87 60       	ori	r24, 0x07	; 7
 262:	85 bb       	out	0x15, r24	; 21
    
    // check if we need to force recalculation of cycle period
    if (_cyclePeriod == 0)
 264:	84 85       	ldd	r24, Z+12	; 0x0c
 266:	95 85       	ldd	r25, Z+13	; 0x0d
 268:	00 97       	sbiw	r24, 0x00	; 0
 26a:	49 f5       	brne	.+82     	; 0x2be <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE18startCallbackTimerEh+0x68>
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::updateCyclePeriod()
{
    // get period
    uint8_t cycleParam = 0;
    if (_ddlMode == IoLink::DDL_MODE_OPERATE)
 26c:	20 81       	ld	r18, Z
 26e:	24 30       	cpi	r18, 0x04	; 4
 270:	21 f4       	brne	.+8      	; 0x27a <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE18startCallbackTimerEh+0x24>
     * 
     * \param address   Parameter index
     * \return          Read value
     * 
     */
    uint8_t             parameterRead(uint8_t address) const { return directParameter[address]; }
 272:	20 91 1e 01 	lds	r18, 0x011E
    if (_ddlMode == IoLink::DDL_MODE_OPERATE)
    {
        cycleParam = parameterRead(IoLink::PAGE_MASTER_CYCLE_TIME);
    }

    if (cycleParam == 0)
 276:	21 11       	cpse	r18, r1
 278:	02 c0       	rjmp	.+4      	; 0x27e <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE18startCallbackTimerEh+0x28>
     * 
     * \param address   Parameter index
     * \return          Read value
     * 
     */
    uint8_t             parameterRead(uint8_t address) const { return directParameter[address]; }
 27a:	20 91 1f 01 	lds	r18, 0x011F
        // MasterCycleTime hasn't been set yet => use MinCycleTime
        cycleParam = parameterRead(IoLink::PAGE_MIN_CYCLE_TIME);
    }

    // decode parameter into 1/10ms
    _cyclePeriod = DECODE_CYCLE_TIME(cycleParam);
 27e:	24 30       	cpi	r18, 0x04	; 4
 280:	e0 f0       	brcs	.+56     	; 0x2ba <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE18startCallbackTimerEh+0x64>
 282:	20 34       	cpi	r18, 0x40	; 64
 284:	18 f4       	brcc	.+6      	; 0x28c <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE18startCallbackTimerEh+0x36>
 286:	82 2f       	mov	r24, r18
 288:	90 e0       	ldi	r25, 0x00	; 0
 28a:	17 c0       	rjmp	.+46     	; 0x2ba <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE18startCallbackTimerEh+0x64>
 28c:	32 2f       	mov	r19, r18
 28e:	30 7c       	andi	r19, 0xC0	; 192
 290:	30 34       	cpi	r19, 0x40	; 64
 292:	49 f4       	brne	.+18     	; 0x2a6 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE18startCallbackTimerEh+0x50>
 294:	84 e0       	ldi	r24, 0x04	; 4
 296:	28 9f       	mul	r18, r24
 298:	90 01       	movw	r18, r0
 29a:	11 24       	eor	r1, r1
 29c:	33 27       	eor	r19, r19
 29e:	c9 01       	movw	r24, r18
 2a0:	80 5c       	subi	r24, 0xC0	; 192
 2a2:	9f 4f       	sbci	r25, 0xFF	; 255
 2a4:	0a c0       	rjmp	.+20     	; 0x2ba <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE18startCallbackTimerEh+0x64>
 2a6:	30 38       	cpi	r19, 0x80	; 128
 2a8:	41 f4       	brne	.+16     	; 0x2ba <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE18startCallbackTimerEh+0x64>
 2aa:	2f 73       	andi	r18, 0x3F	; 63
 2ac:	80 e1       	ldi	r24, 0x10	; 16
 2ae:	28 9f       	mul	r18, r24
 2b0:	90 01       	movw	r18, r0
 2b2:	11 24       	eor	r1, r1
 2b4:	c9 01       	movw	r24, r18
 2b6:	80 5c       	subi	r24, 0xC0	; 192
 2b8:	9e 4f       	sbci	r25, 0xFE	; 254
 2ba:	95 87       	std	Z+13, r25	; 0x0d
 2bc:	84 87       	std	Z+12, r24	; 0x0c
    {
        updateCyclePeriod();
    }

    // initialize cycle timer
    _cycleTimer = delay + 1;
 2be:	70 e0       	ldi	r23, 0x00	; 0
 2c0:	6f 5f       	subi	r22, 0xFF	; 255
 2c2:	7f 4f       	sbci	r23, 0xFF	; 255
 2c4:	77 87       	std	Z+15, r23	; 0x0f
 2c6:	66 87       	std	Z+14, r22	; 0x0e

    if (_cycleTimer > 0)
    {      
        // Timer/Counter0 Output Compare Match B Interrupt Enable
        TIMSK0 = _BV(OCIE0B);
 2c8:	84 e0       	ldi	r24, 0x04	; 4
 2ca:	80 93 6e 00 	sts	0x006E, r24

        // clear Timer on Compare Match A
        TCCR0A = _BV(WGM01);
 2ce:	82 e0       	ldi	r24, 0x02	; 2
 2d0:	84 bd       	out	0x24, r24	; 36

        // generate 0.1ms cycles
#if F_CPU < 20000000
        OCR0B = OCR0A = F_CPU / 80000;
 2d2:	94 e6       	ldi	r25, 0x64	; 100
 2d4:	97 bd       	out	0x27, r25	; 39
 2d6:	98 bd       	out	0x28, r25	; 40
        TCCR0B = _BV(CS01);             // pre-scaler clkIO/8
 2d8:	85 bd       	out	0x25, r24	; 37
 2da:	08 95       	ret

000002dc <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh>:

StackMultiByte StackMultiByte::instance;

//------------------------------------------------------------------------------
template <IoLink::DeviceDLMode DDL_MODE>
StackMultiByte::HandlerResult StackMultiByte::handleOperatingMode(uint8_t mc)
 2dc:	cf 93       	push	r28
 2de:	df 93       	push	r29
 2e0:	ec 01       	movw	r28, r24
 2e2:	96 2f       	mov	r25, r22
{
    // get access mode, channel and address from MC octet
    const uint8_t access  = mc & IoLink::MC_RW_MASK;
    const uint8_t channel = mc & IoLink::MC_CHANNEL_MASK;
 2e4:	86 2f       	mov	r24, r22
 2e6:	80 76       	andi	r24, 0x60	; 96
    const uint8_t address = mc & IoLink::MC_ADDRESS_MASK;
 2e8:	6f 71       	andi	r22, 0x1F	; 31
    const int8_t odCount = getOdOctetCount<DDL_MODE>();
    const uint8_t pdInSize = DDL_MODE == IoLink::DDL_MODE_OPERATE ? PD_IN_SIZE : 0;
    const uint8_t pdOutSize = DDL_MODE == IoLink::DDL_MODE_OPERATE ? PD_OUT_SIZE : 0;

    if (access == IoLink::MC_WRITE)
 2ea:	97 fd       	sbrc	r25, 7
 2ec:	4e c0       	rjmp	.+156    	; 0x38a <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xae>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 2ee:	0d b4       	in	r0, 0x2d	; 45
 2f0:	07 fe       	sbrs	r0, 7
 2f2:	fd cf       	rjmp	.-6      	; 0x2ee <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x12>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 2f4:	9e b5       	in	r25, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 2f6:	9e bd       	out	0x2e, r25	; 46
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
template <IoLink::DeviceDLMode DDL_MODE>
bool StackBase<T, PDI, PDO, SpiSsHndlr>::validateFrameType(uint8_t ckt)
{
    uint8_t frameType = (ckt & IoLink::CKT_TYPE_MASK);
 2f8:	90 7c       	andi	r25, 0xC0	; 192
    {
        // get checksum/type octet
        uint8_t ckt = registerReadNext();
        if (!validateFrameType<DDL_MODE>(ckt))
 2fa:	90 38       	cpi	r25, 0x80	; 128
 2fc:	11 f0       	breq	.+4      	; 0x302 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x26>
            return ResultIllegalMessageType;
 2fe:	83 e0       	ldi	r24, 0x03	; 3
 300:	87 c0       	rjmp	.+270    	; 0x410 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x134>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 302:	0d b4       	in	r0, 0x2d	; 45
 304:	07 fe       	sbrs	r0, 7
 306:	fd cf       	rjmp	.-6      	; 0x302 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x26>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 308:	2e b5       	in	r18, 0x2e	; 46
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 30a:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 30c:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 30e:	90 e9       	ldi	r25, 0x90	; 144
 310:	9e bd       	out	0x2e, r25	; 46
 312:	9b 89       	ldd	r25, Y+19	; 0x13

//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::odWrite(uint8_t channel, uint8_t address, uint8_t data)
{
    if (channel == IoLink::MC_CHNL_PAGE)
 314:	80 32       	cpi	r24, 0x20	; 32
 316:	59 f4       	brne	.+22     	; 0x32e <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x52>
    {
        // store data for use in application
        _parameterWrite.address = address;
 318:	6a 87       	std	Y+10, r22	; 0x0a
        _parameterWrite.value = data;
 31a:	2b 87       	std	Y+11, r18	; 0x0b
        _prmWriteAvailable = true;
 31c:	89 2f       	mov	r24, r25
 31e:	82 60       	ori	r24, 0x02	; 2
 320:	8b 8b       	std	Y+19, r24	; 0x13
 322:	fe 01       	movw	r30, r28
 324:	31 96       	adiw	r30, 0x01	; 1
 326:	9e 01       	movw	r18, r28
 328:	2b 5f       	subi	r18, 0xFB	; 251
 32a:	3f 4f       	sbci	r19, 0xFF	; 255
 32c:	0c c0       	rjmp	.+24     	; 0x346 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x6a>
    }
    else
    {
        _prmWriteAvailable = false;
 32e:	89 2f       	mov	r24, r25
 330:	8d 7f       	andi	r24, 0xFD	; 253
 332:	f6 cf       	rjmp	.-20     	; 0x320 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x44>
        odWrite(channel, address, od);

        // send PDin data
        for (uint8_t i = 0; i < pdInSize; ++i)
        {
            registerWriteNext(_processDataIn.isValid ? _processDataIn.buffer[i] : 0);
 334:	80 e0       	ldi	r24, 0x00	; 0
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 336:	0d b4       	in	r0, 0x2d	; 45
 338:	07 fe       	sbrs	r0, 7
 33a:	fd cf       	rjmp	.-6      	; 0x336 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x5a>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 33c:	8e bd       	out	0x2e, r24	; 46
 33e:	31 96       	adiw	r30, 0x01	; 1

        // store OD octet
        odWrite(channel, address, od);

        // send PDin data
        for (uint8_t i = 0; i < pdInSize; ++i)
 340:	e2 17       	cp	r30, r18
 342:	f3 07       	cpc	r31, r19
 344:	29 f0       	breq	.+10     	; 0x350 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x74>
        {
            registerWriteNext(_processDataIn.isValid ? _processDataIn.buffer[i] : 0);
 346:	8d 81       	ldd	r24, Y+5	; 0x05
 348:	88 23       	and	r24, r24
 34a:	a1 f3       	breq	.-24     	; 0x334 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x58>
 34c:	80 81       	ld	r24, Z
 34e:	f3 cf       	rjmp	.-26     	; 0x336 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x5a>
        }

        // send the CKS octet, note the checksum field is set to 0
        registerWriteNext((pdInSize > 0 && _processDataIn.isValid) ? 
            IoLink::CKS_PD_VALID : IoLink::CKS_PD_INVALID);
 350:	8d 81       	ldd	r24, Y+5	; 0x05
 352:	81 11       	cpse	r24, r1
 354:	02 c0       	rjmp	.+4      	; 0x35a <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x7e>
 356:	80 e4       	ldi	r24, 0x40	; 64
 358:	01 c0       	rjmp	.+2      	; 0x35c <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x80>
 35a:	80 e0       	ldi	r24, 0x00	; 0
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 35c:	0d b4       	in	r0, 0x2d	; 45
 35e:	07 fe       	sbrs	r0, 7
 360:	fd cf       	rjmp	.-6      	; 0x35c <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x80>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 362:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 364:	0d b4       	in	r0, 0x2d	; 45
 366:	07 fe       	sbrs	r0, 7
 368:	fd cf       	rjmp	.-6      	; 0x364 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x88>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 36a:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 36c:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 36e:	83 e8       	ldi	r24, 0x83	; 131
 370:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 372:	0d b4       	in	r0, 0x2d	; 45
 374:	07 fe       	sbrs	r0, 7
 376:	fd cf       	rjmp	.-6      	; 0x372 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x96>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 378:	8e b5       	in	r24, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 37a:	85 e1       	ldi	r24, 0x15	; 21
 37c:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 37e:	0d b4       	in	r0, 0x2d	; 45
 380:	07 fe       	sbrs	r0, 7
 382:	fd cf       	rjmp	.-6      	; 0x37e <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xa2>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 384:	2a 9a       	sbi	0x05, 2	; 5
{
    // start user call-back timer after sending last byte (each byte spaced
    // by 14 x T1)
    if (BAUD_RATE == 230400)
    {
        startCallbackTimer((octetCnt + 1) * 14 / 23 /* approx 230.4 / 10 */);
 386:	63 e0       	ldi	r22, 0x03	; 3
 388:	40 c0       	rjmp	.+128    	; 0x40a <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x12e>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 38a:	0d b4       	in	r0, 0x2d	; 45
 38c:	07 fe       	sbrs	r0, 7
 38e:	fd cf       	rjmp	.-6      	; 0x38a <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xae>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 390:	9e b5       	in	r25, 0x2e	; 46
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 392:	2a 9a       	sbi	0x05, 2	; 5
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
template <IoLink::DeviceDLMode DDL_MODE>
bool StackBase<T, PDI, PDO, SpiSsHndlr>::validateFrameType(uint8_t ckt)
{
    uint8_t frameType = (ckt & IoLink::CKT_TYPE_MASK);
 394:	90 7c       	andi	r25, 0xC0	; 192
                if (frameType == IoLink::CKT_TYPE_2)
                    return true;                                   // TYPE_2_1-2_5
            }
            else if ((StackT::REVISION_ID == IoLink::REVISION_ID_1_1) && (PD_OUT_SIZE + PD_IN_SIZE <= 4))
            {
                if (frameType == IoLink::CKT_TYPE_2)
 396:	90 38       	cpi	r25, 0x80	; 128
 398:	09 f0       	breq	.+2      	; 0x39c <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xc0>
 39a:	b1 cf       	rjmp	.-158    	; 0x2fe <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x22>
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 39c:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 39e:	90 e9       	ldi	r25, 0x90	; 144
 3a0:	9e bd       	out	0x2e, r25	; 46

        // start sending the return data
        registerWriteBegin(REG_FR0);

        // send OD data
        registerWriteNext(odRead(channel, address));
 3a2:	8e de       	rcall	.-740    	; 0xc0 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE6odReadEhh.isra.1>
 3a4:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 3a6:	07 fe       	sbrs	r0, 7
 3a8:	fd cf       	rjmp	.-6      	; 0x3a4 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xc8>
 3aa:	8e bd       	out	0x2e, r24	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 3ac:	fe 01       	movw	r30, r28
 3ae:	31 96       	adiw	r30, 0x01	; 1
 3b0:	9e 01       	movw	r18, r28
 3b2:	2b 5f       	subi	r18, 0xFB	; 251
 3b4:	3f 4f       	sbci	r19, 0xFF	; 255
 3b6:	8d 81       	ldd	r24, Y+5	; 0x05
        }

        // send PDin data
        for (uint8_t i = 0; i < pdInSize; ++i)
        {
            registerWriteNext(_processDataIn.isValid ? _processDataIn.buffer[i] : 0);
 3b8:	88 23       	and	r24, r24
 3ba:	11 f0       	breq	.+4      	; 0x3c0 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xe4>
 3bc:	80 81       	ld	r24, Z
 3be:	01 c0       	rjmp	.+2      	; 0x3c2 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xe6>
 3c0:	80 e0       	ldi	r24, 0x00	; 0
 3c2:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 3c4:	07 fe       	sbrs	r0, 7
 3c6:	fd cf       	rjmp	.-6      	; 0x3c2 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xe6>
 3c8:	8e bd       	out	0x2e, r24	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 3ca:	31 96       	adiw	r30, 0x01	; 1
 3cc:	e2 17       	cp	r30, r18
        {
            registerWriteNext(0);
        }

        // send PDin data
        for (uint8_t i = 0; i < pdInSize; ++i)
 3ce:	f3 07       	cpc	r31, r19
 3d0:	91 f7       	brne	.-28     	; 0x3b6 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xda>
 3d2:	8d 81       	ldd	r24, Y+5	; 0x05
            registerWriteNext(_processDataIn.isValid ? _processDataIn.buffer[i] : 0);
        }

        // send the CKS octet, note the checksum field is set to 0
        registerWriteNext((pdInSize > 0 && _processDataIn.isValid) ? 
            IoLink::CKS_PD_VALID : IoLink::CKS_PD_INVALID);
 3d4:	81 11       	cpse	r24, r1
 3d6:	02 c0       	rjmp	.+4      	; 0x3dc <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x100>
 3d8:	80 e4       	ldi	r24, 0x40	; 64
 3da:	01 c0       	rjmp	.+2      	; 0x3de <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x102>
 3dc:	80 e0       	ldi	r24, 0x00	; 0
 3de:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 3e0:	07 fe       	sbrs	r0, 7
 3e2:	fd cf       	rjmp	.-6      	; 0x3de <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x102>
 3e4:	8e bd       	out	0x2e, r24	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 3e6:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 3e8:	07 fe       	sbrs	r0, 7
 3ea:	fd cf       	rjmp	.-6      	; 0x3e6 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x10a>
 3ec:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 3ee:	2a 98       	cbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 3f0:	83 e8       	ldi	r24, 0x83	; 131
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 3f2:	8e bd       	out	0x2e, r24	; 46
 3f4:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 3f6:	07 fe       	sbrs	r0, 7
 3f8:	fd cf       	rjmp	.-6      	; 0x3f4 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x118>
 3fa:	8e b5       	in	r24, 0x2e	; 46
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 3fc:	89 e1       	ldi	r24, 0x19	; 25
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 3fe:	8e bd       	out	0x2e, r24	; 46
 400:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 402:	07 fe       	sbrs	r0, 7
 404:	fd cf       	rjmp	.-6      	; 0x400 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x124>
 406:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 408:	64 e0       	ldi	r22, 0x04	; 4
{
    // start user call-back timer after sending last byte (each byte spaced
    // by 14 x T1)
    if (BAUD_RATE == 230400)
    {
        startCallbackTimer((octetCnt + 1) * 14 / 23 /* approx 230.4 / 10 */);
 40a:	ce 01       	movw	r24, r28
 40c:	24 df       	rcall	.-440    	; 0x256 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE18startCallbackTimerEh>
 40e:	80 e0       	ldi	r24, 0x00	; 0
 410:	df 91       	pop	r29
        // if IDLE, enter STARTUP state
        _ddlMode = IoLink::DDL_MODE_STARTUP;
        setIoLinkListen();
    }

    return ResultSuccess;
 412:	cf 91       	pop	r28
}
 414:	08 95       	ret

00000416 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh>:
 416:	cf 93       	push	r28
 418:	df 93       	push	r29

StackMultiByte StackMultiByte::instance;

//------------------------------------------------------------------------------
template <IoLink::DeviceDLMode DDL_MODE>
StackMultiByte::HandlerResult StackMultiByte::handleOperatingMode(uint8_t mc)
 41a:	ec 01       	movw	r28, r24
 41c:	96 2f       	mov	r25, r22
{
    // get access mode, channel and address from MC octet
    const uint8_t access  = mc & IoLink::MC_RW_MASK;
    const uint8_t channel = mc & IoLink::MC_CHANNEL_MASK;
 41e:	86 2f       	mov	r24, r22
 420:	80 76       	andi	r24, 0x60	; 96
    const uint8_t address = mc & IoLink::MC_ADDRESS_MASK;
 422:	6f 71       	andi	r22, 0x1F	; 31
    const int8_t odCount = getOdOctetCount<DDL_MODE>();
    const uint8_t pdInSize = DDL_MODE == IoLink::DDL_MODE_OPERATE ? PD_IN_SIZE : 0;
    const uint8_t pdOutSize = DDL_MODE == IoLink::DDL_MODE_OPERATE ? PD_OUT_SIZE : 0;

    if (access == IoLink::MC_WRITE)
 424:	97 fd       	sbrc	r25, 7
 426:	30 c0       	rjmp	.+96     	; 0x488 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x72>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 428:	0d b4       	in	r0, 0x2d	; 45
 42a:	07 fe       	sbrs	r0, 7
 42c:	fd cf       	rjmp	.-6      	; 0x428 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x12>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 42e:	9e b5       	in	r25, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 430:	9e bd       	out	0x2e, r25	; 46
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
template <IoLink::DeviceDLMode DDL_MODE>
bool StackBase<T, PDI, PDO, SpiSsHndlr>::validateFrameType(uint8_t ckt)
{
    uint8_t frameType = (ckt & IoLink::CKT_TYPE_MASK);
 432:	90 7c       	andi	r25, 0xC0	; 192
    {
        // get checksum/type octet
        uint8_t ckt = registerReadNext();
        if (!validateFrameType<DDL_MODE>(ckt))
 434:	11 f0       	breq	.+4      	; 0x43a <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x24>
            return ResultIllegalMessageType;
 436:	83 e0       	ldi	r24, 0x03	; 3
 438:	50 c0       	rjmp	.+160    	; 0x4da <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xc4>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 43a:	0d b4       	in	r0, 0x2d	; 45
 43c:	07 fe       	sbrs	r0, 7
 43e:	fd cf       	rjmp	.-6      	; 0x43a <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x24>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 440:	2e b5       	in	r18, 0x2e	; 46
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 442:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 444:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 446:	90 e9       	ldi	r25, 0x90	; 144
 448:	9e bd       	out	0x2e, r25	; 46
 44a:	9b 89       	ldd	r25, Y+19	; 0x13

//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::odWrite(uint8_t channel, uint8_t address, uint8_t data)
{
    if (channel == IoLink::MC_CHNL_PAGE)
 44c:	80 32       	cpi	r24, 0x20	; 32
 44e:	21 f4       	brne	.+8      	; 0x458 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x42>
    {
        // store data for use in application
        _parameterWrite.address = address;
 450:	6a 87       	std	Y+10, r22	; 0x0a
        _parameterWrite.value = data;
 452:	2b 87       	std	Y+11, r18	; 0x0b
        _prmWriteAvailable = true;
 454:	92 60       	ori	r25, 0x02	; 2
 456:	01 c0       	rjmp	.+2      	; 0x45a <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x44>
    }
    else
    {
        _prmWriteAvailable = false;
 458:	9d 7f       	andi	r25, 0xFD	; 253
 45a:	9b 8b       	std	Y+19, r25	; 0x13
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 45c:	0d b4       	in	r0, 0x2d	; 45
 45e:	07 fe       	sbrs	r0, 7
 460:	fd cf       	rjmp	.-6      	; 0x45c <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x46>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 462:	80 e4       	ldi	r24, 0x40	; 64
 464:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 466:	0d b4       	in	r0, 0x2d	; 45
 468:	07 fe       	sbrs	r0, 7
 46a:	fd cf       	rjmp	.-6      	; 0x466 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x50>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 46c:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 46e:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 470:	83 e8       	ldi	r24, 0x83	; 131
 472:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 474:	0d b4       	in	r0, 0x2d	; 45
 476:	07 fe       	sbrs	r0, 7
 478:	fd cf       	rjmp	.-6      	; 0x474 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x5e>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 47a:	8e b5       	in	r24, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 47c:	85 e0       	ldi	r24, 0x05	; 5
 47e:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 480:	0d b4       	in	r0, 0x2d	; 45
 482:	07 fe       	sbrs	r0, 7
 484:	fd cf       	rjmp	.-6      	; 0x480 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x6a>
 486:	24 c0       	rjmp	.+72     	; 0x4d0 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xba>
 488:	0d b4       	in	r0, 0x2d	; 45
 48a:	07 fe       	sbrs	r0, 7
 48c:	fd cf       	rjmp	.-6      	; 0x488 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x72>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 48e:	9e b5       	in	r25, 0x2e	; 46
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 490:	2a 9a       	sbi	0x05, 2	; 5
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
template <IoLink::DeviceDLMode DDL_MODE>
bool StackBase<T, PDI, PDO, SpiSsHndlr>::validateFrameType(uint8_t ckt)
{
    uint8_t frameType = (ckt & IoLink::CKT_TYPE_MASK);
 492:	90 7c       	andi	r25, 0xC0	; 192
        // see table A.8
    case IoLink::DDL_MODE_PREOPERATE:
        switch (StackT::MSEQ_CAPABILITY & IoLink::MSEQCAP_PREOP_MASK)
        {
        case IoLink::MSEQCAP_PREOP_CODE_0: 
            if (frameType == IoLink::CKT_TYPE_0) 
 494:	81 f6       	brne	.-96     	; 0x436 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x20>
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 496:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 498:	90 e9       	ldi	r25, 0x90	; 144
 49a:	9e bd       	out	0x2e, r25	; 46

        // start sending the return data
        registerWriteBegin(REG_FR0);

        // send OD data
        registerWriteNext(odRead(channel, address));
 49c:	11 de       	rcall	.-990    	; 0xc0 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE6odReadEhh.isra.1>
 49e:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 4a0:	07 fe       	sbrs	r0, 7
 4a2:	fd cf       	rjmp	.-6      	; 0x49e <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x88>
 4a4:	8e bd       	out	0x2e, r24	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 4a6:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 4a8:	07 fe       	sbrs	r0, 7
 4aa:	fd cf       	rjmp	.-6      	; 0x4a6 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x90>
 4ac:	80 e4       	ldi	r24, 0x40	; 64
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 4ae:	8e bd       	out	0x2e, r24	; 46
 4b0:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 4b2:	07 fe       	sbrs	r0, 7
 4b4:	fd cf       	rjmp	.-6      	; 0x4b0 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x9a>
 4b6:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 4b8:	2a 98       	cbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 4ba:	83 e8       	ldi	r24, 0x83	; 131
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 4bc:	8e bd       	out	0x2e, r24	; 46
 4be:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 4c0:	07 fe       	sbrs	r0, 7
 4c2:	fd cf       	rjmp	.-6      	; 0x4be <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xa8>
 4c4:	8e b5       	in	r24, 0x2e	; 46
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 4c6:	89 e0       	ldi	r24, 0x09	; 9
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 4c8:	8e bd       	out	0x2e, r24	; 46
 4ca:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 4cc:	07 fe       	sbrs	r0, 7
 4ce:	fd cf       	rjmp	.-6      	; 0x4ca <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xb4>
 4d0:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 4d2:	61 e0       	ldi	r22, 0x01	; 1
{
    // start user call-back timer after sending last byte (each byte spaced
    // by 14 x T1)
    if (BAUD_RATE == 230400)
    {
        startCallbackTimer((octetCnt + 1) * 14 / 23 /* approx 230.4 / 10 */);
 4d4:	ce 01       	movw	r24, r28
 4d6:	bf de       	rcall	.-642    	; 0x256 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE18startCallbackTimerEh>
 4d8:	80 e0       	ldi	r24, 0x00	; 0
 4da:	df 91       	pop	r29
        // if IDLE, enter STARTUP state
        _ddlMode = IoLink::DDL_MODE_STARTUP;
        setIoLinkListen();
    }

    return ResultSuccess;
 4dc:	cf 91       	pop	r28
}
 4de:	08 95       	ret

000004e0 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh>:
 4e0:	cf 93       	push	r28
 4e2:	df 93       	push	r29

StackMultiByte StackMultiByte::instance;

//------------------------------------------------------------------------------
template <IoLink::DeviceDLMode DDL_MODE>
StackMultiByte::HandlerResult StackMultiByte::handleOperatingMode(uint8_t mc)
 4e4:	ec 01       	movw	r28, r24
 4e6:	96 2f       	mov	r25, r22
{
    // get access mode, channel and address from MC octet
    const uint8_t access  = mc & IoLink::MC_RW_MASK;
    const uint8_t channel = mc & IoLink::MC_CHANNEL_MASK;
 4e8:	86 2f       	mov	r24, r22
 4ea:	80 76       	andi	r24, 0x60	; 96
    const uint8_t address = mc & IoLink::MC_ADDRESS_MASK;
 4ec:	6f 71       	andi	r22, 0x1F	; 31
    const int8_t odCount = getOdOctetCount<DDL_MODE>();
    const uint8_t pdInSize = DDL_MODE == IoLink::DDL_MODE_OPERATE ? PD_IN_SIZE : 0;
    const uint8_t pdOutSize = DDL_MODE == IoLink::DDL_MODE_OPERATE ? PD_OUT_SIZE : 0;

    if (access == IoLink::MC_WRITE)
 4ee:	97 fd       	sbrc	r25, 7
 4f0:	32 c0       	rjmp	.+100    	; 0x556 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x76>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 4f2:	0d b4       	in	r0, 0x2d	; 45
 4f4:	07 fe       	sbrs	r0, 7
 4f6:	fd cf       	rjmp	.-6      	; 0x4f2 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x12>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 4f8:	9e b5       	in	r25, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 4fa:	9e bd       	out	0x2e, r25	; 46
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
template <IoLink::DeviceDLMode DDL_MODE>
bool StackBase<T, PDI, PDO, SpiSsHndlr>::validateFrameType(uint8_t ckt)
{
    uint8_t frameType = (ckt & IoLink::CKT_TYPE_MASK);
 4fc:	90 7c       	andi	r25, 0xC0	; 192
    {
        // get checksum/type octet
        uint8_t ckt = registerReadNext();
        if (!validateFrameType<DDL_MODE>(ckt))
 4fe:	11 f0       	breq	.+4      	; 0x504 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x24>
            return ResultIllegalMessageType;
 500:	83 e0       	ldi	r24, 0x03	; 3
 502:	63 c0       	rjmp	.+198    	; 0x5ca <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xea>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 504:	0d b4       	in	r0, 0x2d	; 45
 506:	07 fe       	sbrs	r0, 7
 508:	fd cf       	rjmp	.-6      	; 0x504 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x24>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 50a:	2e b5       	in	r18, 0x2e	; 46
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 50c:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 50e:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 510:	90 e9       	ldi	r25, 0x90	; 144
 512:	9e bd       	out	0x2e, r25	; 46
 514:	9b 89       	ldd	r25, Y+19	; 0x13

//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::odWrite(uint8_t channel, uint8_t address, uint8_t data)
{
    if (channel == IoLink::MC_CHNL_PAGE)
 516:	80 32       	cpi	r24, 0x20	; 32
 518:	29 f4       	brne	.+10     	; 0x524 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x44>
    {
        // store data for use in application
        _parameterWrite.address = address;
 51a:	6a 87       	std	Y+10, r22	; 0x0a
        _parameterWrite.value = data;
 51c:	2b 87       	std	Y+11, r18	; 0x0b
        _prmWriteAvailable = true;
 51e:	89 2f       	mov	r24, r25
 520:	82 60       	ori	r24, 0x02	; 2
 522:	02 c0       	rjmp	.+4      	; 0x528 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x48>
    }
    else
    {
        _prmWriteAvailable = false;
 524:	89 2f       	mov	r24, r25
 526:	8d 7f       	andi	r24, 0xFD	; 253
 528:	8b 8b       	std	Y+19, r24	; 0x13
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 52a:	0d b4       	in	r0, 0x2d	; 45
 52c:	07 fe       	sbrs	r0, 7
 52e:	fd cf       	rjmp	.-6      	; 0x52a <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x4a>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 530:	80 e4       	ldi	r24, 0x40	; 64
 532:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 534:	0d b4       	in	r0, 0x2d	; 45
 536:	07 fe       	sbrs	r0, 7
 538:	fd cf       	rjmp	.-6      	; 0x534 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x54>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 53a:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 53c:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 53e:	83 e8       	ldi	r24, 0x83	; 131
 540:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 542:	0d b4       	in	r0, 0x2d	; 45
 544:	07 fe       	sbrs	r0, 7
 546:	fd cf       	rjmp	.-6      	; 0x542 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x62>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 548:	8e b5       	in	r24, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 54a:	85 e0       	ldi	r24, 0x05	; 5
 54c:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 54e:	0d b4       	in	r0, 0x2d	; 45
 550:	07 fe       	sbrs	r0, 7
 552:	fd cf       	rjmp	.-6      	; 0x54e <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x6e>
 554:	24 c0       	rjmp	.+72     	; 0x59e <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xbe>
 556:	0d b4       	in	r0, 0x2d	; 45
 558:	07 fe       	sbrs	r0, 7
 55a:	fd cf       	rjmp	.-6      	; 0x556 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x76>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 55c:	9e b5       	in	r25, 0x2e	; 46
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 55e:	2a 9a       	sbi	0x05, 2	; 5
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
template <IoLink::DeviceDLMode DDL_MODE>
bool StackBase<T, PDI, PDO, SpiSsHndlr>::validateFrameType(uint8_t ckt)
{
    uint8_t frameType = (ckt & IoLink::CKT_TYPE_MASK);
 560:	90 7c       	andi	r25, 0xC0	; 192
    switch (DDL_MODE)
    {
        // see table A.7
    case IoLink::DDL_MODE_IDLE:
    case IoLink::DDL_MODE_STARTUP:
        if (frameType == IoLink::CKT_TYPE_0) 
 562:	71 f6       	brne	.-100    	; 0x500 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x20>
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 564:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 566:	90 e9       	ldi	r25, 0x90	; 144
 568:	9e bd       	out	0x2e, r25	; 46

        // start sending the return data
        registerWriteBegin(REG_FR0);

        // send OD data
        registerWriteNext(odRead(channel, address));
 56a:	aa dd       	rcall	.-1196   	; 0xc0 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE6odReadEhh.isra.1>
 56c:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 56e:	07 fe       	sbrs	r0, 7
 570:	fd cf       	rjmp	.-6      	; 0x56c <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x8c>
 572:	8e bd       	out	0x2e, r24	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 574:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 576:	07 fe       	sbrs	r0, 7
 578:	fd cf       	rjmp	.-6      	; 0x574 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x94>
 57a:	80 e4       	ldi	r24, 0x40	; 64
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 57c:	8e bd       	out	0x2e, r24	; 46
 57e:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 580:	07 fe       	sbrs	r0, 7
 582:	fd cf       	rjmp	.-6      	; 0x57e <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0x9e>
 584:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 586:	2a 98       	cbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 588:	83 e8       	ldi	r24, 0x83	; 131
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 58a:	8e bd       	out	0x2e, r24	; 46
 58c:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 58e:	07 fe       	sbrs	r0, 7
 590:	fd cf       	rjmp	.-6      	; 0x58c <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xac>
 592:	8e b5       	in	r24, 0x2e	; 46
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 594:	89 e0       	ldi	r24, 0x09	; 9
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 596:	8e bd       	out	0x2e, r24	; 46
 598:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 59a:	07 fe       	sbrs	r0, 7
 59c:	fd cf       	rjmp	.-6      	; 0x598 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xb8>
 59e:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 5a0:	61 e0       	ldi	r22, 0x01	; 1
{
    // start user call-back timer after sending last byte (each byte spaced
    // by 14 x T1)
    if (BAUD_RATE == 230400)
    {
        startCallbackTimer((octetCnt + 1) * 14 / 23 /* approx 230.4 / 10 */);
 5a2:	ce 01       	movw	r24, r28
 5a4:	58 de       	rcall	.-848    	; 0x256 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE18startCallbackTimerEh>
 5a6:	88 81       	ld	r24, Y
 5a8:	82 30       	cpi	r24, 0x02	; 2

        // start user call-back timer after sending last byte 
        startCallbackTimerAfterReply(octetCount);
    }

    if ((DDL_MODE == IoLink::DDL_MODE_STARTUP || DDL_MODE == IoLink::DDL_MODE_IDLE) 
 5aa:	71 f0       	breq	.+28     	; 0x5c8 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xe8>
 5ac:	82 e0       	ldi	r24, 0x02	; 2
 5ae:	88 83       	st	Y, r24
        && _ddlMode != IoLink::DDL_MODE_STARTUP)
    {
        // if IDLE, enter STARTUP state
        _ddlMode = IoLink::DDL_MODE_STARTUP;
 5b0:	2a 98       	cbi	0x05, 2	; 5
 5b2:	82 e8       	ldi	r24, 0x82	; 130
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 5b4:	8e bd       	out	0x2e, r24	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 5b6:	0d b4       	in	r0, 0x2d	; 45
 5b8:	07 fe       	sbrs	r0, 7
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 5ba:	fd cf       	rjmp	.-6      	; 0x5b6 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xd6>
 5bc:	8e b5       	in	r24, 0x2e	; 46
 5be:	1e bc       	out	0x2e, r1	; 46
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 5c0:	0d b4       	in	r0, 0x2d	; 45
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 5c2:	07 fe       	sbrs	r0, 7
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 5c4:	fd cf       	rjmp	.-6      	; 0x5c0 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh+0xe0>
 5c6:	2a 9a       	sbi	0x05, 2	; 5
 5c8:	80 e0       	ldi	r24, 0x00	; 0
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 5ca:	df 91       	pop	r29
        setIoLinkListen();
    }

    return ResultSuccess;
 5cc:	cf 91       	pop	r28
}
 5ce:	08 95       	ret

000005d0 <__vector_4>:
 5d0:	1f 92       	push	r1
 5d2:	0f 92       	push	r0
 * Interrupt service routine for the PHY interrupt.
 *
 * We immediately forward the call to onPhyInterrupt().
 */
ISR(PCINT1_vect)
{
 5d4:	0f b6       	in	r0, 0x3f	; 63
 5d6:	0f 92       	push	r0
 5d8:	11 24       	eor	r1, r1
 5da:	2f 93       	push	r18
 5dc:	3f 93       	push	r19
 5de:	4f 93       	push	r20
 5e0:	5f 93       	push	r21
 5e2:	6f 93       	push	r22
 5e4:	7f 93       	push	r23
 5e6:	8f 93       	push	r24
 5e8:	9f 93       	push	r25
 5ea:	af 93       	push	r26
 5ec:	bf 93       	push	r27
 5ee:	ef 93       	push	r30
 5f0:	ff 93       	push	r31
    // 
    // (If INT isn't cleared after the handler, then the PHY state is probably
    //  out of sync with the one expected by the firmware. In that case, this
    //  ISR will never be called again. Looping the handler ensures we eventually
    //  resync before exiting the ISR)
    while (bit_is_set(PINC, PINC0))
 5f2:	30 9b       	sbis	0x06, 0	; 6
 5f4:	75 c0       	rjmp	.+234    	; 0x6e0 <__vector_4+0x110>
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 5f6:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 5f8:	80 e1       	ldi	r24, 0x10	; 16
 5fa:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 5fc:	0d b4       	in	r0, 0x2d	; 45
 5fe:	07 fe       	sbrs	r0, 7
 600:	fd cf       	rjmp	.-6      	; 0x5fc <__vector_4+0x2c>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 602:	8e b5       	in	r24, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 604:	8e bd       	out	0x2e, r24	; 46
    // read the device status and start reading the frame register
    uint8_t status = registerReadBegin(REG_FR0);

    // test flags
    HandlerResult result;
    if (!(status & STATUS_RST))
 606:	87 ff       	sbrs	r24, 7
 608:	4a c0       	rjmp	.+148    	; 0x69e <__vector_4+0xce>
    {
        result = ResultPhyReset;
    }
    else if (!(status & STATUS_DAT))
 60a:	82 ff       	sbrs	r24, 2
 60c:	25 c0       	rjmp	.+74     	; 0x658 <__vector_4+0x88>
    {
        result = ResultNoData;
    }
    else if (status & STATUS_CHK)
 60e:	83 fd       	sbrc	r24, 3
 610:	25 c0       	rjmp	.+74     	; 0x65c <__vector_4+0x8c>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 612:	0d b4       	in	r0, 0x2d	; 45
 614:	07 fe       	sbrs	r0, 7
 616:	fd cf       	rjmp	.-6      	; 0x612 <__vector_4+0x42>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 618:	6e b5       	in	r22, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 61a:	6e bd       	out	0x2e, r22	; 46
    {
        // get master sequence control octet
        const uint8_t mc = registerReadNext();

        // call appropriate state handler
        switch (_ddlMode)
 61c:	80 91 01 01 	lds	r24, 0x0101
 620:	83 30       	cpi	r24, 0x03	; 3
 622:	31 f0       	breq	.+12     	; 0x630 <__vector_4+0x60>
 624:	84 30       	cpi	r24, 0x04	; 4
 626:	41 f4       	brne	.+16     	; 0x638 <__vector_4+0x68>
        {
        case IoLink::DDL_MODE_OPERATE:    
            result = handleOperatingMode<IoLink::DDL_MODE_OPERATE>(mc); 
 628:	81 e0       	ldi	r24, 0x01	; 1
 62a:	91 e0       	ldi	r25, 0x01	; 1
 62c:	57 de       	rcall	.-850    	; 0x2dc <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE4EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh>
 62e:	07 c0       	rjmp	.+14     	; 0x63e <__vector_4+0x6e>
 630:	81 e0       	ldi	r24, 0x01	; 1
            break;
        case IoLink::DDL_MODE_PREOPERATE:
            result = handleOperatingMode<IoLink::DDL_MODE_PREOPERATE>(mc);
 632:	91 e0       	ldi	r25, 0x01	; 1
 634:	f0 de       	rcall	.-544    	; 0x416 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE3EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh>
 636:	03 c0       	rjmp	.+6      	; 0x63e <__vector_4+0x6e>
 638:	81 e0       	ldi	r24, 0x01	; 1
 63a:	91 e0       	ldi	r25, 0x01	; 1
            break;
        default:                  
            result = handleOperatingMode<IoLink::DDL_MODE_STARTUP>(mc); 
 63c:	51 df       	rcall	.-350    	; 0x4e0 <_ZN14StackMultiByte19handleOperatingModeILN6IoLink12DeviceDLModeE2EEEN9StackBaseIS_Li4ELi0E16DefaultSsHandlerE13HandlerResultEh>
 63e:	82 30       	cpi	r24, 0x02	; 2
 640:	69 f0       	breq	.+26     	; 0x65c <__vector_4+0x8c>
 642:	20 f4       	brcc	.+8      	; 0x64c <__vector_4+0x7c>
            break;
        }
    }

    // handle result codes
    switch (result)
 644:	81 30       	cpi	r24, 0x01	; 1
 646:	09 f0       	breq	.+2      	; 0x64a <__vector_4+0x7a>
 648:	48 c0       	rjmp	.+144    	; 0x6da <__vector_4+0x10a>
 64a:	06 c0       	rjmp	.+12     	; 0x658 <__vector_4+0x88>
 64c:	83 30       	cpi	r24, 0x03	; 3
 64e:	a9 f0       	breq	.+42     	; 0x67a <__vector_4+0xaa>
 650:	84 30       	cpi	r24, 0x04	; 4
 652:	09 f0       	breq	.+2      	; 0x656 <__vector_4+0x86>
 654:	42 c0       	rjmp	.+132    	; 0x6da <__vector_4+0x10a>
 656:	23 c0       	rjmp	.+70     	; 0x69e <__vector_4+0xce>
 658:	c6 dd       	rcall	.-1140   	; 0x1e6 <_ZN9PhyDriverI16DefaultSsHandlerE19registerAbortAccessEv>
 65a:	3f c0       	rjmp	.+126    	; 0x6da <__vector_4+0x10a>
 65c:	c4 dd       	rcall	.-1144   	; 0x1e6 <_ZN9PhyDriverI16DefaultSsHandlerE19registerAbortAccessEv>
    case ResultSuccess:
        break;

    case ResultNoData:
        // terminate SPI access
        registerAbortAccess();
 65e:	2a 98       	cbi	0x05, 2	; 5
 660:	83 e8       	ldi	r24, 0x83	; 131
 662:	8e bd       	out	0x2e, r24	; 46
        break;

    case ResultChecksumError:
        // terminate SPI access
        registerAbortAccess();
 664:	0d b4       	in	r0, 0x2d	; 45
 666:	07 fe       	sbrs	r0, 7
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 668:	fd cf       	rjmp	.-6      	; 0x664 <__vector_4+0x94>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 66a:	8e b5       	in	r24, 0x2e	; 46
 66c:	82 e0       	ldi	r24, 0x02	; 2
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 66e:	8e bd       	out	0x2e, r24	; 46
 670:	0d b4       	in	r0, 0x2d	; 45
 672:	07 fe       	sbrs	r0, 7
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 674:	fd cf       	rjmp	.-6      	; 0x670 <__vector_4+0xa0>
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 676:	2a 9a       	sbi	0x05, 2	; 5
 678:	30 c0       	rjmp	.+96     	; 0x6da <__vector_4+0x10a>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 67a:	b5 dd       	rcall	.-1174   	; 0x1e6 <_ZN9PhyDriverI16DefaultSsHandlerE19registerAbortAccessEv>
 67c:	2a 98       	cbi	0x05, 2	; 5
 67e:	83 e8       	ldi	r24, 0x83	; 131
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 680:	8e bd       	out	0x2e, r24	; 46
 682:	0d b4       	in	r0, 0x2d	; 45
        registerWrite(REG_LINK, LINK_END);
        break;

    case ResultIllegalMessageType:
        // terminate SPI access
        registerAbortAccess();
 684:	07 fe       	sbrs	r0, 7
 686:	fd cf       	rjmp	.-6      	; 0x682 <__vector_4+0xb2>
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 688:	8e b5       	in	r24, 0x2e	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 68a:	82 e0       	ldi	r24, 0x02	; 2
 68c:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 68e:	0d b4       	in	r0, 0x2d	; 45
 690:	07 fe       	sbrs	r0, 7
 692:	fd cf       	rjmp	.-6      	; 0x68e <__vector_4+0xbe>
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 694:	2a 9a       	sbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 696:	82 e0       	ldi	r24, 0x02	; 2
 698:	80 93 01 01 	sts	0x0101, r24
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 69c:	1e c0       	rjmp	.+60     	; 0x6da <__vector_4+0x10a>
 69e:	a3 dd       	rcall	.-1210   	; 0x1e6 <_ZN9PhyDriverI16DefaultSsHandlerE19registerAbortAccessEv>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 6a0:	2a 98       	cbi	0x05, 2	; 5

        // bad data has been received, so decline to respond
        registerWrite(REG_LINK, LINK_END);

        // revert to startup mode
        _ddlMode = IoLink::DDL_MODE_STARTUP;
 6a2:	83 e8       	ldi	r24, 0x83	; 131
 6a4:	8e bd       	out	0x2e, r24	; 46
 6a6:	0d b4       	in	r0, 0x2d	; 45
 6a8:	07 fe       	sbrs	r0, 7
        break;

    case ResultPhyReset:
        // terminate SPI access
        registerAbortAccess();
 6aa:	fd cf       	rjmp	.-6      	; 0x6a6 <__vector_4+0xd6>
 6ac:	8e b5       	in	r24, 0x2e	; 46
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 6ae:	82 e0       	ldi	r24, 0x02	; 2
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 6b0:	8e bd       	out	0x2e, r24	; 46
 6b2:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 6b4:	07 fe       	sbrs	r0, 7
 6b6:	fd cf       	rjmp	.-6      	; 0x6b2 <__vector_4+0xe2>
 6b8:	2a 9a       	sbi	0x05, 2	; 5
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 6ba:	2a 98       	cbi	0x05, 2	; 5
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 6bc:	85 e8       	ldi	r24, 0x85	; 133
 6be:	8e bd       	out	0x2e, r24	; 46
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 6c0:	0d b4       	in	r0, 0x2d	; 45
 6c2:	07 fe       	sbrs	r0, 7
 6c4:	fd cf       	rjmp	.-6      	; 0x6c0 <__vector_4+0xf0>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 6c6:	8e b5       	in	r24, 0x2e	; 46
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 6c8:	80 e8       	ldi	r24, 0x80	; 128
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 6ca:	8e bd       	out	0x2e, r24	; 46
 6cc:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 6ce:	07 fe       	sbrs	r0, 7
 6d0:	fd cf       	rjmp	.-6      	; 0x6cc <__vector_4+0xfc>
 6d2:	2a 9a       	sbi	0x05, 2	; 5
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 6d4:	81 e0       	ldi	r24, 0x01	; 1
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 6d6:	91 e0       	ldi	r25, 0x01	; 1
 6d8:	8d dd       	rcall	.-1254   	; 0x1f4 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE12configurePhyEv>
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 6da:	82 e0       	ldi	r24, 0x02	; 2
 6dc:	8b bb       	out	0x1b, r24	; 27
 6de:	89 cf       	rjmp	.-238    	; 0x5f2 <__vector_4+0x22>
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 6e0:	ff 91       	pop	r31
        // decline to respond
        registerWrite(REG_LINK, LINK_END);

        // reset the reset bit
        registerWrite(REG_STATUS, STATUS_RST);
        configurePhy(); // implicitly reverts to DDL_MODE_STARTUP
 6e2:	ef 91       	pop	r30
 6e4:	bf 91       	pop	r27
 6e6:	af 91       	pop	r26
 6e8:	9f 91       	pop	r25
    while (bit_is_set(PINC, PINC0))
    {
        StackMultiByte::instance.onPhyInterrupt();

        // clear interrupt
        PCIFR = _BV(PCIF1);
 6ea:	8f 91       	pop	r24
 6ec:	7f 91       	pop	r23
 6ee:	6f 91       	pop	r22
    }
}
 6f0:	5f 91       	pop	r21
 6f2:	4f 91       	pop	r20
 6f4:	3f 91       	pop	r19
 6f6:	2f 91       	pop	r18
 6f8:	0f 90       	pop	r0
 6fa:	0f be       	out	0x3f, r0	; 63
 6fc:	0f 90       	pop	r0
 6fe:	1f 90       	pop	r1
 700:	18 95       	reti

00000702 <_GLOBAL__sub_I_directParameter>:
 702:	e1 e0       	ldi	r30, 0x01	; 1
 704:	f1 e0       	ldi	r31, 0x01	; 1
 706:	10 82       	st	Z, r1
 708:	9f ef       	ldi	r25, 0xFF	; 255
 70a:	97 83       	std	Z+7, r25	; 0x07
 70c:	aa e0       	ldi	r26, 0x0A	; 10
 70e:	b1 e0       	ldi	r27, 0x01	; 1
 710:	8c 91       	ld	r24, X
    , _ledRegister(0)
    , _fallbackCounter(0)
    , _runUserCode(false)
    , _sioLevel(true)
    , _prmWriteAvailable(false)
    , _flag(false)
 712:	81 60       	ori	r24, 0x01	; 1
 714:	8c 93       	st	X, r24
 716:	15 86       	std	Z+13, r1	; 0x0d
 718:	14 86       	std	Z+12, r1	; 0x0c
 71a:	17 86       	std	Z+15, r1	; 0x0f
 71c:	16 86       	std	Z+14, r1	; 0x0e
 71e:	90 8b       	std	Z+16, r25	; 0x10
 720:	11 8a       	std	Z+17, r1	; 0x11
 722:	12 8a       	std	Z+18, r1	; 0x12
 724:	a4 e1       	ldi	r26, 0x14	; 20
 726:	b1 e0       	ldi	r27, 0x01	; 1
 728:	8c 91       	ld	r24, X
 72a:	8c 7f       	andi	r24, 0xFC	; 252
 72c:	8b 7f       	andi	r24, 0xFB	; 251
 72e:	8c 93       	st	X, r24
{
    _parameterWrite.address = IoLink::PAGE_NO_PARAMETER;
 730:	92 87       	std	Z+10, r25	; 0x0a
 732:	08 95       	ret

00000734 <_ZN7DemoApp9configureEv>:

//------------------------------------------------------------------------------
void DemoApp::configure()
{
    // Configure a timer with 10ms cycle
    OCR2A   = F_CPU / 1024 / 100;
 734:	8e e4       	ldi	r24, 0x4E	; 78
 736:	80 93 b3 00 	sts	0x00B3, r24

    /* Start the timer
       WGM    = 3'b010  - clear timer on match
       COMxx  = 2'b0    - pins not used
       CS     = 3'b111   - divide by 1024 */
    TCCR2A = _BV(WGM21);
 73a:	82 e0       	ldi	r24, 0x02	; 2
 73c:	80 93 b0 00 	sts	0x00B0, r24
    TCCR2B = _BV(CS22) | _BV(CS21) | _BV(CS20);
 740:	87 e0       	ldi	r24, 0x07	; 7
 742:	80 93 b1 00 	sts	0x00B1, r24

    // configure digital input
    DDRB &= ~_BV(DDB7);
 746:	27 98       	cbi	0x04, 7	; 4
 748:	08 95       	ret

0000074a <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE>:
    updateProcessInputData();
}

//------------------------------------------------------------------------------
void DemoApp::handleParameterWrite(const Stack::Parameter* param)
{
 74a:	fb 01       	movw	r30, r22
    // (this is the location to intercept the write access if desired)
    bool commit = true;

    switch (param->address)
 74c:	80 81       	ld	r24, Z
 74e:	81 31       	cpi	r24, 0x11	; 17
 750:	09 f4       	brne	.+2      	; 0x754 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xa>
 752:	7a c0       	rjmp	.+244    	; 0x848 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xfe>
 754:	91 81       	ldd	r25, Z+1	; 0x01
 756:	82 31       	cpi	r24, 0x12	; 18
 758:	29 f0       	breq	.+10     	; 0x764 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x1a>
 75a:	80 31       	cpi	r24, 0x10	; 16
 75c:	59 f4       	brne	.+22     	; 0x774 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x2a>
    case IoLink::PAGE_DEVICE_SPECIFIC_1B:
    case IoLink::PAGE_DEVICE_SPECIFIC_1C:
    case IoLink::PAGE_DEVICE_SPECIFIC_1D:
    case IoLink::PAGE_DEVICE_SPECIFIC_1E:
    case IoLink::PAGE_DEVICE_SPECIFIC_1F:
        directParameter[address] = value;
 75e:	90 93 2e 01 	sts	0x012E, r25
 762:	08 c0       	rjmp	.+16     	; 0x774 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x2a>
        // read-only access => ignore
        commit = false;
        break;

    case VendorParamPidMode:  // process input data selection
        switch (param->value)
 764:	91 30       	cpi	r25, 0x01	; 1
 766:	31 f4       	brne	.+12     	; 0x774 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x2a>
        {
        case PidAnalogInput:
            // configure ADC
            ADMUX = _BV(REFS0) | 7; 
 768:	87 e4       	ldi	r24, 0x47	; 71
 76a:	80 93 7c 00 	sts	0x007C, r24
            ADCSRA = _BV(ADPS0) | _BV(ADPS1) | _BV(ADPS2) | _BV(ADEN) | _BV(ADSC);
 76e:	87 ec       	ldi	r24, 0xC7	; 199
 770:	80 93 7a 00 	sts	0x007A, r24
    }

    if (commit)
    {
        // commit to stack
        Stack::instance.parameterWrite(param->address, param->value);
 774:	21 81       	ldd	r18, Z+1	; 0x01
 776:	e0 81       	ld	r30, Z
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::parameterWrite(uint8_t address, uint8_t value)
{
    // write to direct parameter page channel
    switch (address)
 778:	ec 30       	cpi	r30, 0x0C	; 12
 77a:	08 f0       	brcs	.+2      	; 0x77e <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x34>
 77c:	60 c0       	rjmp	.+192    	; 0x83e <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xf4>
 77e:	e9 30       	cpi	r30, 0x09	; 9
 780:	50 f0       	brcs	.+20     	; 0x796 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x4c>

    case IoLink::PAGE_REVISION_ID:
    case IoLink::PAGE_DEVICE_ID_1:
    case IoLink::PAGE_DEVICE_ID_2:
    case IoLink::PAGE_DEVICE_ID_3:
        if (_ddlMode == IoLink::DDL_MODE_STARTUP)
 782:	80 91 01 01 	lds	r24, 0x0101
 786:	82 30       	cpi	r24, 0x02	; 2
 788:	09 f0       	breq	.+2      	; 0x78c <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x42>
 78a:	5e c0       	rjmp	.+188    	; 0x848 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xfe>
        {
            directParameter[address] = value;
 78c:	f0 e0       	ldi	r31, 0x00	; 0
 78e:	e3 5e       	subi	r30, 0xE3	; 227
 790:	fe 4f       	sbci	r31, 0xFE	; 254
 792:	20 83       	st	Z, r18
 794:	08 95       	ret
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::parameterWrite(uint8_t address, uint8_t value)
{
    // write to direct parameter page channel
    switch (address)
 796:	e1 30       	cpi	r30, 0x01	; 1
 798:	69 f5       	brne	.+90     	; 0x7f4 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xaa>
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::updateCyclePeriod()
{
    // get period
    uint8_t cycleParam = 0;
    if (_ddlMode == IoLink::DDL_MODE_OPERATE)
 79a:	80 91 01 01 	lds	r24, 0x0101
 79e:	84 30       	cpi	r24, 0x04	; 4
 7a0:	21 f4       	brne	.+8      	; 0x7aa <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x60>
     * 
     * \param address   Parameter index
     * \return          Read value
     * 
     */
    uint8_t             parameterRead(uint8_t address) const { return directParameter[address]; }
 7a2:	80 91 1e 01 	lds	r24, 0x011E
    if (_ddlMode == IoLink::DDL_MODE_OPERATE)
    {
        cycleParam = parameterRead(IoLink::PAGE_MASTER_CYCLE_TIME);
    }

    if (cycleParam == 0)
 7a6:	81 11       	cpse	r24, r1
 7a8:	02 c0       	rjmp	.+4      	; 0x7ae <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x64>
     * 
     * \param address   Parameter index
     * \return          Read value
     * 
     */
    uint8_t             parameterRead(uint8_t address) const { return directParameter[address]; }
 7aa:	80 91 1f 01 	lds	r24, 0x011F
        // MasterCycleTime hasn't been set yet => use MinCycleTime
        cycleParam = parameterRead(IoLink::PAGE_MIN_CYCLE_TIME);
    }

    // decode parameter into 1/10ms
    _cyclePeriod = DECODE_CYCLE_TIME(cycleParam);
 7ae:	84 30       	cpi	r24, 0x04	; 4
 7b0:	d0 f0       	brcs	.+52     	; 0x7e6 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x9c>
 7b2:	80 34       	cpi	r24, 0x40	; 64
 7b4:	10 f4       	brcc	.+4      	; 0x7ba <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x70>
 7b6:	90 e0       	ldi	r25, 0x00	; 0
 7b8:	18 c0       	rjmp	.+48     	; 0x7ea <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xa0>
 7ba:	98 2f       	mov	r25, r24
 7bc:	90 7c       	andi	r25, 0xC0	; 192
 7be:	90 34       	cpi	r25, 0x40	; 64
 7c0:	41 f4       	brne	.+16     	; 0x7d2 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x88>
 7c2:	34 e0       	ldi	r19, 0x04	; 4
 7c4:	83 9f       	mul	r24, r19
 7c6:	c0 01       	movw	r24, r0
 7c8:	11 24       	eor	r1, r1
 7ca:	99 27       	eor	r25, r25
 7cc:	80 5c       	subi	r24, 0xC0	; 192
 7ce:	9f 4f       	sbci	r25, 0xFF	; 255
 7d0:	0c c0       	rjmp	.+24     	; 0x7ea <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xa0>
 7d2:	90 38       	cpi	r25, 0x80	; 128
 7d4:	41 f4       	brne	.+16     	; 0x7e6 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x9c>
 7d6:	8f 73       	andi	r24, 0x3F	; 63
 7d8:	30 e1       	ldi	r19, 0x10	; 16
 7da:	83 9f       	mul	r24, r19
 7dc:	c0 01       	movw	r24, r0
 7de:	11 24       	eor	r1, r1
 7e0:	80 5c       	subi	r24, 0xC0	; 192
 7e2:	9e 4f       	sbci	r25, 0xFE	; 254
 7e4:	02 c0       	rjmp	.+4      	; 0x7ea <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xa0>
 7e6:	80 e0       	ldi	r24, 0x00	; 0
 7e8:	90 e0       	ldi	r25, 0x00	; 0
 7ea:	90 93 0e 01 	sts	0x010E, r25
 7ee:	80 93 0d 01 	sts	0x010D, r24
 7f2:	cc cf       	rjmp	.-104    	; 0x78c <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x42>
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::parameterWrite(uint8_t address, uint8_t value)
{
    // write to direct parameter page channel
    switch (address)
 7f4:	e1 30       	cpi	r30, 0x01	; 1
 7f6:	f8 f4       	brcc	.+62     	; 0x836 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xec>
    {
    case IoLink::PAGE_MASTER_CMD:
        switch (value)
 7f8:	28 39       	cpi	r18, 0x98	; 152
 7fa:	a1 f0       	breq	.+40     	; 0x824 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xda>
 7fc:	28 f4       	brcc	.+10     	; 0x808 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xbe>
 7fe:	2a 35       	cpi	r18, 0x5A	; 90
 800:	b1 f0       	breq	.+44     	; 0x82e <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xe4>
 802:	27 39       	cpi	r18, 0x97	; 151
 804:	31 f0       	breq	.+12     	; 0x812 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xc8>
 806:	08 95       	ret
 808:	29 39       	cpi	r18, 0x99	; 153
 80a:	49 f0       	breq	.+18     	; 0x81e <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xd4>
 80c:	2a 39       	cpi	r18, 0x9A	; 154
 80e:	19 f0       	breq	.+6      	; 0x816 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xcc>
 810:	08 95       	ret
        {
        case IoLink::MCMD_DEVICE_STARTUP:   
            _ddlMode = IoLink::DDL_MODE_STARTUP;  
 812:	82 e0       	ldi	r24, 0x02	; 2
 814:	01 c0       	rjmp	.+2      	; 0x818 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xce>
            break;
        case IoLink::MCMD_DEVICE_PREOPERATE:
            _ddlMode = IoLink::DDL_MODE_PREOPERATE; 
 816:	83 e0       	ldi	r24, 0x03	; 3
 818:	80 93 01 01 	sts	0x0101, r24
 81c:	08 95       	ret
            break;
        case IoLink::MCMD_DEVICE_OPERATE:   
            _processDataOut.isValid = false;
 81e:	10 92 07 01 	sts	0x0107, r1
 822:	03 c0       	rjmp	.+6      	; 0x82a <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xe0>
            _ddlMode = IoLink::DDL_MODE_OPERATE; 
            break;
        case IoLink::MCMD_PD_OUT_OPERATE:   // Process output data valid
            _processDataOut.isValid = true;
 824:	81 e0       	ldi	r24, 0x01	; 1
 826:	80 93 07 01 	sts	0x0107, r24
            _ddlMode = IoLink::DDL_MODE_OPERATE; 
 82a:	84 e0       	ldi	r24, 0x04	; 4
 82c:	f5 cf       	rjmp	.-22     	; 0x818 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xce>
            break;
        case IoLink::MCMD_FALLBACK:
            // switch to SIO mode after 3 cycles
            _fallbackCounter = 3;
 82e:	83 e0       	ldi	r24, 0x03	; 3
 830:	80 93 13 01 	sts	0x0113, r24
 834:	08 95       	ret
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::parameterWrite(uint8_t address, uint8_t value)
{
    // write to direct parameter page channel
    switch (address)
 836:	e4 30       	cpi	r30, 0x04	; 4
 838:	09 f4       	brne	.+2      	; 0x83c <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xf2>
 83a:	a3 cf       	rjmp	.-186    	; 0x782 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x38>
 83c:	08 95       	ret
 83e:	81 ef       	ldi	r24, 0xF1	; 241
 840:	8e 0f       	add	r24, r30
 842:	81 31       	cpi	r24, 0x11	; 17
 844:	08 f4       	brcc	.+2      	; 0x848 <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0xfe>
 846:	a2 cf       	rjmp	.-188    	; 0x78c <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x42>
 848:	08 95       	ret

0000084a <_ZN7DemoApp11elapsed10msEv>:
}

//------------------------------------------------------------------------------
bool DemoApp::elapsed10ms()
{
    if (!(TIFR2 & _BV(OCF2A)))
 84a:	b9 9b       	sbis	0x17, 1	; 23
 84c:	04 c0       	rjmp	.+8      	; 0x856 <_ZN7DemoApp11elapsed10msEv+0xc>
        return false;

    TIFR2 = _BV(OCF2A);
 84e:	82 e0       	ldi	r24, 0x02	; 2
 850:	87 bb       	out	0x17, r24	; 23
    return true;
 852:	81 e0       	ldi	r24, 0x01	; 1
 854:	08 95       	ret

//------------------------------------------------------------------------------
bool DemoApp::elapsed10ms()
{
    if (!(TIFR2 & _BV(OCF2A)))
        return false;
 856:	80 e0       	ldi	r24, 0x00	; 0

    TIFR2 = _BV(OCF2A);
    return true;
}
 858:	08 95       	ret

0000085a <_ZN7DemoApp22updateProcessInputDataEv>:
    }
}

//------------------------------------------------------------------------------
void DemoApp::updateProcessInputData()
{
 85a:	cf 93       	push	r28
 85c:	df 93       	push	r29
 85e:	ec 01       	movw	r28, r24
    if (elapsed10ms())
 860:	f4 df       	rcall	.-24     	; 0x84a <_ZN7DemoApp11elapsed10msEv>
 862:	88 23       	and	r24, r24
 864:	61 f1       	breq	.+88     	; 0x8be <_ZN7DemoApp22updateProcessInputDataEv+0x64>
 866:	88 81       	ld	r24, Y
    {
        // the green LED cycles if IO-Link comms are up, red if not
        ++_ctr;
 868:	8f 5f       	subi	r24, 0xFF	; 255
 86a:	88 83       	st	Y, r24
 86c:	90 e0       	ldi	r25, 0x00	; 0
        uint8_t level = ((_ctr >> 3) & 0x0f);
 86e:	23 e0       	ldi	r18, 0x03	; 3
 870:	95 95       	asr	r25
 872:	87 95       	ror	r24
 874:	2a 95       	dec	r18
 876:	e1 f7       	brne	.-8      	; 0x870 <_ZN7DemoApp22updateProcessInputDataEv+0x16>
 878:	98 2f       	mov	r25, r24
 87a:	9f 70       	andi	r25, 0x0F	; 15
 87c:	83 ff       	sbrs	r24, 3
        if (level & 0x8) level = ((~level) & 0x7);
 87e:	02 c0       	rjmp	.+4      	; 0x884 <_ZN7DemoApp22updateProcessInputDataEv+0x2a>
 880:	90 95       	com	r25
 882:	97 70       	andi	r25, 0x07	; 7
 884:	80 91 08 01 	lds	r24, 0x0108

        if (Stack::instance.masterLost())
 888:	85 30       	cpi	r24, 0x05	; 5
 88a:	18 f0       	brcs	.+6      	; 0x892 <_ZN7DemoApp22updateProcessInputDataEv+0x38>
 88c:	19 82       	std	Y+1, r1	; 0x01
            {
                // flash the red LED
                _ledLevel1 = Stack::LED_LEVEL_OFF;
 88e:	9a 83       	std	Y+2, r25	; 0x02
                _ledLevel2 = (Stack::LedLevel)(level);
 890:	02 c0       	rjmp	.+4      	; 0x896 <_ZN7DemoApp22updateProcessInputDataEv+0x3c>
 892:	99 83       	std	Y+1, r25	; 0x01
            }
            else
            {
                // flash the green LED
                _ledLevel1 = (Stack::LedLevel)(level);
 894:	1a 82       	std	Y+2, r1	; 0x02
                _ledLevel2 = Stack::LED_LEVEL_OFF;
 896:	1f 99       	sbic	0x03, 7	; 3
            };

        // the red LED is over-ridden if the push-button is pressed
        if (isDigitalButtonPressed())
 898:	02 c0       	rjmp	.+4      	; 0x89e <_ZN7DemoApp22updateProcessInputDataEv+0x44>
 89a:	8f e0       	ldi	r24, 0x0F	; 15
        {
            _ledLevel2 = (Stack::LedLevel)(0xf);
 89c:	8a 83       	std	Y+2, r24	; 0x02
 89e:	89 81       	ldd	r24, Y+1	; 0x01
{
    switch (led)
    {
    case LED_1:
        _ledRegister &= 0x0f;
        _ledRegister |= (level << 4);
 8a0:	20 e1       	ldi	r18, 0x10	; 16
 8a2:	82 9f       	mul	r24, r18
 8a4:	c0 01       	movw	r24, r0
 8a6:	11 24       	eor	r1, r1
 8a8:	90 91 12 01 	lds	r25, 0x0112
void StackBase<T, PDI, PDO, SpiSsHndlr>::setLedLevel(Led led, typename Phy::LedLevel level)
{
    switch (led)
    {
    case LED_1:
        _ledRegister &= 0x0f;
 8ac:	9f 70       	andi	r25, 0x0F	; 15
 8ae:	89 2b       	or	r24, r25
        _ledRegister |= (level << 4);
 8b0:	80 93 12 01 	sts	0x0112, r24
 8b4:	80 7f       	andi	r24, 0xF0	; 240
        break;

    case LED_2:
        _ledRegister &= 0xf0;
 8b6:	9a 81       	ldd	r25, Y+2	; 0x02
        _ledRegister |= level;
 8b8:	89 2b       	or	r24, r25
 8ba:	80 93 12 01 	sts	0x0112, r24
 8be:	80 91 2f 01 	lds	r24, 0x012F

        Stack::instance.setLedLevel(Stack::LED_1, _ledLevel1);
        Stack::instance.setLedLevel(Stack::LED_2, _ledLevel2);
    }

    switch (Stack::instance.parameterRead(VendorParamPidMode))
 8c2:	82 30       	cpi	r24, 0x02	; 2
 8c4:	51 f1       	breq	.+84     	; 0x91a <__stack+0x1b>
 8c6:	28 f4       	brcc	.+10     	; 0x8d2 <_ZN7DemoApp22updateProcessInputDataEv+0x78>
 8c8:	88 23       	and	r24, r24
 8ca:	59 f0       	breq	.+22     	; 0x8e2 <_ZN7DemoApp22updateProcessInputDataEv+0x88>
 8cc:	81 30       	cpi	r24, 0x01	; 1
 8ce:	79 f0       	breq	.+30     	; 0x8ee <_ZN7DemoApp22updateProcessInputDataEv+0x94>
 8d0:	2d c0       	rjmp	.+90     	; 0x92c <__stack+0x2d>
 8d2:	83 30       	cpi	r24, 0x03	; 3
 8d4:	21 f1       	breq	.+72     	; 0x91e <__stack+0x1f>
 8d6:	84 30       	cpi	r24, 0x04	; 4
 8d8:	49 f5       	brne	.+82     	; 0x92c <__stack+0x2d>
 8da:	8c e2       	ldi	r24, 0x2C	; 44
		//Stack::instance.processInputData().buffer[1] = 34;
		Stack::instance.processInputData().isValid = true;
		break;
		
	case SpiInput:
		Stack::instance.processInputData().buffer[0] = 44;
 8dc:	80 93 02 01 	sts	0x0102, r24
 8e0:	25 c0       	rjmp	.+74     	; 0x92c <__stack+0x2d>
 8e2:	83 b1       	in	r24, 0x03	; 3
}

//------------------------------------------------------------------------------
bool DemoApp::isDigitalButtonPressed()
{
    return !(PINB & _BV(PINB7));
 8e4:	80 95       	com	r24

    switch (Stack::instance.parameterRead(VendorParamPidMode))
    {
    case PidDigitalInput:
        // check digital sensor 
        Stack::instance.processInputData().buffer[0] = isDigitalButtonPressed() ? 0x01 : 0x00;
 8e6:	88 1f       	adc	r24, r24
 8e8:	88 27       	eor	r24, r24
 8ea:	88 1f       	adc	r24, r24
 8ec:	19 c0       	rjmp	.+50     	; 0x920 <__stack+0x21>
 8ee:	90 91 7a 00 	lds	r25, 0x007A
        Stack::instance.processInputData().isValid = true;
        break;

    case PidAnalogInput:
        // check analog sensor
        if (!(ADCSRA & _BV(ADSC)))
 8f2:	96 fd       	sbrc	r25, 6
 8f4:	1d c0       	rjmp	.+58     	; 0x930 <__stack+0x31>
 8f6:	20 91 78 00 	lds	r18, 0x0078
        {
            uint16_t sensorValue = ADC;
 8fa:	30 91 79 00 	lds	r19, 0x0079
 8fe:	36 95       	lsr	r19

            Stack::instance.processInputData().buffer[0] = sensorValue >> 2;
 900:	27 95       	ror	r18
 902:	36 95       	lsr	r19
 904:	27 95       	ror	r18
 906:	20 93 02 01 	sts	0x0102, r18
 90a:	80 93 06 01 	sts	0x0106, r24
            Stack::instance.processInputData().isValid = true;
 90e:	80 91 7a 00 	lds	r24, 0x007A

            // restart sampling
            ADCSRA |= _BV(ADSC);
 912:	80 64       	ori	r24, 0x40	; 64
 914:	80 93 7a 00 	sts	0x007A, r24
 918:	0b c0       	rjmp	.+22     	; 0x930 <__stack+0x31>
 91a:	88 81       	ld	r24, Y
        }
        break;

    case PidSawtooth:
        // copy counter to process input data
        Stack::instance.processInputData().buffer[0] = _ctr;
 91c:	01 c0       	rjmp	.+2      	; 0x920 <__stack+0x21>
 91e:	81 e2       	ldi	r24, 0x21	; 33
        Stack::instance.processInputData().isValid = true;
        break;
		
	case I2cInput:
		Stack::instance.processInputData().buffer[0] = 33;
 920:	80 93 02 01 	sts	0x0102, r24
 924:	81 e0       	ldi	r24, 0x01	; 1
		//Stack::instance.processInputData().buffer[1] = 34;
		Stack::instance.processInputData().isValid = true;
 926:	80 93 06 01 	sts	0x0106, r24
 92a:	02 c0       	rjmp	.+4      	; 0x930 <__stack+0x31>
		break;
 92c:	10 92 06 01 	sts	0x0106, r1
		Stack::instance.processInputData().buffer[0] = 44;
		//Stack::instance.processInputData().buffer[1] = 45;
		Stack::instance.processInputData().isValid = true;

    default:
        Stack::instance.processInputData().isValid = false;
 930:	df 91       	pop	r29
        break;
    }
}
 932:	cf 91       	pop	r28
 934:	08 95       	ret

00000936 <_ZN7DemoApp3runEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE>:
 936:	cf 93       	push	r28
    DDRB &= ~_BV(DDB7);
}

//------------------------------------------------------------------------------
void DemoApp::run(const Stack::Parameter* param)
{
 938:	df 93       	push	r29
 93a:	ec 01       	movw	r28, r24
    // check for write access to direct parameter page
    if (param)
 93c:	61 15       	cp	r22, r1
 93e:	71 05       	cpc	r23, r1
 940:	11 f0       	breq	.+4      	; 0x946 <_ZN7DemoApp3runEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x10>
    {
        handleParameterWrite(param);
 942:	03 df       	rcall	.-506    	; 0x74a <_ZN7DemoApp20handleParameterWriteEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE>
 944:	27 c0       	rjmp	.+78     	; 0x994 <_ZN7DemoApp3runEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x5e>
 946:	80 91 01 01 	lds	r24, 0x0101
    }
    else if (Stack::instance.stackMode() == Stack::STACK_MODE_SIO)
 94a:	81 11       	cpse	r24, r1
 94c:	23 c0       	rjmp	.+70     	; 0x994 <_ZN7DemoApp3runEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x5e>
 94e:	93 b1       	in	r25, 0x03	; 3
}

//------------------------------------------------------------------------------
bool DemoApp::isDigitalButtonPressed()
{
    return !(PINB & _BV(PINB7));
 950:	90 95       	com	r25
 952:	99 1f       	adc	r25, r25
 954:	99 27       	eor	r25, r25
 956:	99 1f       	adc	r25, r25
 958:	80 91 0a 01 	lds	r24, 0x010A

//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::setSioLevel(bool active)
{
    _sioLevel = active;
 95c:	90 fb       	bst	r25, 0
 95e:	80 f9       	bld	r24, 0
 960:	80 93 0a 01 	sts	0x010A, r24
 964:	91 11       	cpse	r25, r1
uint8_t StackBase<T, PDI, PDO, SpiSsHndlr>::driveModeBits() const
{
    switch (StackT::SIO_DRIVE_MODE)
    {
    case DRIVE_MODE_PUSH_PULL:
        return _sioLevel ? Phy::CTL_HS : Phy::CTL_LS;
 966:	02 c0       	rjmp	.+4      	; 0x96c <_ZN7DemoApp3runEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x36>
 968:	91 e0       	ldi	r25, 0x01	; 1
 96a:	01 c0       	rjmp	.+2      	; 0x96e <_ZN7DemoApp3runEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x38>
 96c:	92 e0       	ldi	r25, 0x02	; 2
 96e:	8f ef       	ldi	r24, 0xFF	; 255
    bool driven = (hslsBits != 0);

    // we need to switch to IO-Link mode after 1ms to detect a wake-up
    if (driven)
    {
        _hiZCounter = -1;
 970:	80 93 09 01 	sts	0x0109, r24
 974:	81 e0       	ldi	r24, 0x01	; 1
    else if (wasDriven)  
    {
        _hiZCounter = 10;
    }

    wasDriven = driven;
 976:	80 93 00 01 	sts	0x0100, r24
 97a:	94 60       	ori	r25, 0x04	; 4
    uint8_t sioBit = (!driven && (_hiZCounter < 0)) 
        ? Phy::CTL_IOLINK_MODE 
        : Phy::CTL_SIO_MODE;

    return StackBase::registerWrite(Phy::REG_CTL, 
        StackT::PHY_CTL_SCT | StackT::PHY_CTL_MODE | sioBit | hslsBits);
 97c:	2a 98       	cbi	0x05, 2	; 5
    /**
     * Assert SS/ to begin SPI communication
     */
    static void         assert() __attribute__((always_inline))
    {
        PORTB &= ~ _BV(PORTB2);
 97e:	82 e8       	ldi	r24, 0x82	; 130
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 980:	8e bd       	out	0x2e, r24	; 46
 982:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 984:	07 fe       	sbrs	r0, 7
 986:	fd cf       	rjmp	.-6      	; 0x982 <_ZN7DemoApp3runEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x4c>
 988:	8e b5       	in	r24, 0x2e	; 46
    static uint8_t      rx() __attribute__((always_inline))
    {
        wait();

        // get received data from buffer
        return SPDR;
 98a:	9e bd       	out	0x2e, r25	; 46
     * \param data  Byte to send
     */
    static void         tx(uint8_t data)  __attribute__((always_inline))
    {
        // put data into buffer, sends the data
        SPDR = data;
 98c:	0d b4       	in	r0, 0x2d	; 45
    /**
     * Waits until SPI transmission / reception complete
     */
    static void         wait()  __attribute__((always_inline))
    {        
        loop_until_bit_is_set(SPSR, SPIF);
 98e:	07 fe       	sbrs	r0, 7
 990:	fd cf       	rjmp	.-6      	; 0x98c <_ZN7DemoApp3runEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE+0x56>
 992:	2a 9a       	sbi	0x05, 2	; 5
    /**
     * Deassert SS/ to terminate SPI communication
     */
    static void         deassert() __attribute__((always_inline))
    {
        PORTB |= _BV(PORTB2);
 994:	ce 01       	movw	r24, r28
        // when in SIOActive mode, use digital input to control CQ line
    	Stack::instance.setSioLevel(isDigitalButtonPressed());
    }

    // update process data
    updateProcessInputData();
 996:	df 91       	pop	r29
}
 998:	cf 91       	pop	r28
 99a:	5f cf       	rjmp	.-322    	; 0x85a <_ZN7DemoApp22updateProcessInputDataEv>

0000099c <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9configureEv>:
        // when in SIOActive mode, use digital input to control CQ line
    	Stack::instance.setSioLevel(isDigitalButtonPressed());
    }

    // update process data
    updateProcessInputData();
 99c:	cf 93       	push	r28
 99e:	df 93       	push	r29
    return StackBase::registerRead(Phy::REG_TEMP);
}

//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::configure()
 9a0:	ec 01       	movw	r28, r24
    DORD   = 1'b0   - MSB first
    MSTR   = 1'b1   - Master
    CPOL   = 1'b1   - clock idles high
    CPHA   = 1'b1   - sample on trailing edge
    SPR    = 2'b00  - fosc/2 */
    SPCR = _BV(SPE) | _BV(MSTR) | _BV(CPOL) | _BV(CPHA);
 9a2:	8c e5       	ldi	r24, 0x5C	; 92
 9a4:	8c bd       	out	0x2c, r24	; 44

    /* and the SPI2X bit to speed it up */
    SPSR = _BV(SPI2X);
 9a6:	81 e0       	ldi	r24, 0x01	; 1
 9a8:	8d bd       	out	0x2d, r24	; 45

    /* Data direction in the SPI bits, PB2/SS, PB5/SCK
    and PB3/MOSI are outputs.  Drive SS high in advance */
    PORTB |= _BV(PORTB2) | _BV(PORTB5);
 9aa:	85 b1       	in	r24, 0x05	; 5
 9ac:	84 62       	ori	r24, 0x24	; 36
 9ae:	85 b9       	out	0x05, r24	; 5
    PORTB &= ~(_BV(PORTB3)); 
 9b0:	2b 98       	cbi	0x05, 3	; 5
    DDRB  |= _BV(DDB5) | _BV(DDB3) | _BV(DDB2);
 9b2:	84 b1       	in	r24, 0x04	; 4
 9b4:	8c 62       	ori	r24, 0x2C	; 44
 9b6:	84 b9       	out	0x04, r24	; 4
    DDRB  &= ~(_BV(DDB4));
 9b8:	24 98       	cbi	0x04, 4	; 4
        HIBYTE(StackT::DEVICE_ID),                      // PAGE_DEVICE_ID_2
        LOBYTE(StackT::DEVICE_ID)                       // PAGE_DEVICE_ID_3
    };

    // copy the default parameters from flash to RAM
    (void)memcpy_P(directParameter, directDefaultConfig, sizeof(directDefaultConfig));
 9ba:	40 e2       	ldi	r20, 0x20	; 32
 9bc:	50 e0       	ldi	r21, 0x00	; 0
 9be:	68 e6       	ldi	r22, 0x68	; 104
 9c0:	70 e0       	ldi	r23, 0x00	; 0
 9c2:	8d e1       	ldi	r24, 0x1D	; 29
 9c4:	91 e0       	ldi	r25, 0x01	; 1
 9c6:	93 d0       	rcall	.+294    	; 0xaee <memcpy_P>
 9c8:	18 82       	st	Y, r1

    // stack initial state is STACK_MODE_SIO operation
    _ddlMode = IoLink::DDL_MODE_IDLE;
 9ca:	1d 82       	std	Y+5, r1	; 0x05

    // set up the process data buffers and default process data
    _processDataIn.isValid = false;
 9cc:	1e 82       	std	Y+6, r1	; 0x06
    _processDataOut.isValid = false;
 9ce:	80 91 68 00 	lds	r24, 0x0068
{
    // Configure and enable interrupt
    // 
    // Only pin change interrupts are available, so the routine must check
    // the level before returning
    PCICR  |= _BV(PCIE1);
 9d2:	82 60       	ori	r24, 0x02	; 2
 9d4:	80 93 68 00 	sts	0x0068, r24
 9d8:	80 91 6c 00 	lds	r24, 0x006C
    PCMSK1 |= _BV(PCINT8);
 9dc:	81 60       	ori	r24, 0x01	; 1
 9de:	80 93 6c 00 	sts	0x006C, r24
 9e2:	f6 dd       	rcall	.-1044   	; 0x5d0 <__vector_4>

    // call ISR handler
    PCINT1_vect();
 9e4:	1f 82       	std	Y+7, r1	; 0x07
 9e6:	15 bc       	out	0x25, r1	; 37
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::startCallbackTimer(uint8_t delay)
{
    // reset dead cycle timer
    _deadCycleCtr = 0;
 9e8:	16 bc       	out	0x26, r1	; 38

    // disable timer
    TCCR0B = 0;
 9ea:	85 b3       	in	r24, 0x15	; 21
    TCNT0 = 0;
 9ec:	87 60       	ori	r24, 0x07	; 7

    // clear any outstanding interrupt requests
    TIFR0 |= _BV(OCF0B) | _BV(OCF0A) | _BV(TOV0);
 9ee:	85 bb       	out	0x15, r24	; 21
 9f0:	8c 85       	ldd	r24, Y+12	; 0x0c
 9f2:	9d 85       	ldd	r25, Y+13	; 0x0d
    
    // check if we need to force recalculation of cycle period
    if (_cyclePeriod == 0)
 9f4:	00 97       	sbiw	r24, 0x00	; 0
 9f6:	49 f5       	brne	.+82     	; 0xa4a <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9configureEv+0xae>
 9f8:	28 81       	ld	r18, Y
 9fa:	24 30       	cpi	r18, 0x04	; 4
template <class T, int PDI, int PDO, class SpiSsHndlr>
void StackBase<T, PDI, PDO, SpiSsHndlr>::updateCyclePeriod()
{
    // get period
    uint8_t cycleParam = 0;
    if (_ddlMode == IoLink::DDL_MODE_OPERATE)
 9fc:	21 f4       	brne	.+8      	; 0xa06 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9configureEv+0x6a>
 9fe:	20 91 1e 01 	lds	r18, 0x011E
     * 
     * \param address   Parameter index
     * \return          Read value
     * 
     */
    uint8_t             parameterRead(uint8_t address) const { return directParameter[address]; }
 a02:	21 11       	cpse	r18, r1
 a04:	02 c0       	rjmp	.+4      	; 0xa0a <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9configureEv+0x6e>
    if (_ddlMode == IoLink::DDL_MODE_OPERATE)
    {
        cycleParam = parameterRead(IoLink::PAGE_MASTER_CYCLE_TIME);
    }

    if (cycleParam == 0)
 a06:	20 91 1f 01 	lds	r18, 0x011F
     * 
     * \param address   Parameter index
     * \return          Read value
     * 
     */
    uint8_t             parameterRead(uint8_t address) const { return directParameter[address]; }
 a0a:	24 30       	cpi	r18, 0x04	; 4
 a0c:	e0 f0       	brcs	.+56     	; 0xa46 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9configureEv+0xaa>
        // MasterCycleTime hasn't been set yet => use MinCycleTime
        cycleParam = parameterRead(IoLink::PAGE_MIN_CYCLE_TIME);
    }

    // decode parameter into 1/10ms
    _cyclePeriod = DECODE_CYCLE_TIME(cycleParam);
 a0e:	20 34       	cpi	r18, 0x40	; 64
 a10:	18 f4       	brcc	.+6      	; 0xa18 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9configureEv+0x7c>
 a12:	82 2f       	mov	r24, r18
 a14:	90 e0       	ldi	r25, 0x00	; 0
 a16:	17 c0       	rjmp	.+46     	; 0xa46 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9configureEv+0xaa>
 a18:	32 2f       	mov	r19, r18
 a1a:	30 7c       	andi	r19, 0xC0	; 192
 a1c:	30 34       	cpi	r19, 0x40	; 64
 a1e:	49 f4       	brne	.+18     	; 0xa32 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9configureEv+0x96>
 a20:	84 e0       	ldi	r24, 0x04	; 4
 a22:	28 9f       	mul	r18, r24
 a24:	90 01       	movw	r18, r0
 a26:	11 24       	eor	r1, r1
 a28:	33 27       	eor	r19, r19
 a2a:	c9 01       	movw	r24, r18
 a2c:	80 5c       	subi	r24, 0xC0	; 192
 a2e:	9f 4f       	sbci	r25, 0xFF	; 255
 a30:	0a c0       	rjmp	.+20     	; 0xa46 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9configureEv+0xaa>
 a32:	30 38       	cpi	r19, 0x80	; 128
 a34:	41 f4       	brne	.+16     	; 0xa46 <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9configureEv+0xaa>
 a36:	2f 73       	andi	r18, 0x3F	; 63
 a38:	80 e1       	ldi	r24, 0x10	; 16
 a3a:	28 9f       	mul	r18, r24
 a3c:	90 01       	movw	r18, r0
 a3e:	11 24       	eor	r1, r1
 a40:	c9 01       	movw	r24, r18
 a42:	80 5c       	subi	r24, 0xC0	; 192
 a44:	9e 4f       	sbci	r25, 0xFE	; 254
 a46:	9d 87       	std	Y+13, r25	; 0x0d
 a48:	8c 87       	std	Y+12, r24	; 0x0c
 a4a:	81 e0       	ldi	r24, 0x01	; 1
 a4c:	90 e0       	ldi	r25, 0x00	; 0
    {
        updateCyclePeriod();
    }

    // initialize cycle timer
    _cycleTimer = delay + 1;
 a4e:	9f 87       	std	Y+15, r25	; 0x0f
 a50:	8e 87       	std	Y+14, r24	; 0x0e
 a52:	84 e0       	ldi	r24, 0x04	; 4
 a54:	80 93 6e 00 	sts	0x006E, r24

    if (_cycleTimer > 0)
    {      
        // Timer/Counter0 Output Compare Match B Interrupt Enable
        TIMSK0 = _BV(OCIE0B);
 a58:	82 e0       	ldi	r24, 0x02	; 2
 a5a:	84 bd       	out	0x24, r24	; 36

        // clear Timer on Compare Match A
        TCCR0A = _BV(WGM01);
 a5c:	94 e6       	ldi	r25, 0x64	; 100
 a5e:	97 bd       	out	0x27, r25	; 39

        // generate 0.1ms cycles
#if F_CPU < 20000000
        OCR0B = OCR0A = F_CPU / 80000;
 a60:	98 bd       	out	0x28, r25	; 40
 a62:	85 bd       	out	0x25, r24	; 37
 a64:	df 91       	pop	r29
        TCCR0B = _BV(CS01);             // pre-scaler clkIO/8
 a66:	cf 91       	pop	r28
    configureStackBase();
    Phy::configure();

    // start timer responsible for calling the application "main loop"
    startCallbackTimer();
};
 a68:	08 95       	ret

00000a6a <main>:
 a6a:	2f ef       	ldi	r18, 0xFF	; 255
 a6c:	81 ee       	ldi	r24, 0xE1	; 225
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 a6e:	94 e0       	ldi	r25, 0x04	; 4
 a70:	21 50       	subi	r18, 0x01	; 1
 a72:	80 40       	sbci	r24, 0x00	; 0
 a74:	90 40       	sbci	r25, 0x00	; 0
 a76:	e1 f7       	brne	.-8      	; 0xa70 <main+0x6>
 a78:	00 c0       	rjmp	.+0      	; 0xa7a <main+0x10>
 a7a:	00 00       	nop
public:
    //! setup the HW configuration
    static void configure()
    {
        // Port PD4 and PD5 as output
        DDRD  |= _BV(DDD4) | _BV(DDD5);
 a7c:	8a b1       	in	r24, 0x0a	; 10
 a7e:	80 63       	ori	r24, 0x30	; 48
 a80:	8a b9       	out	0x0a, r24	; 10
        {
            PORTD |= _BV(PORTD4);
        }
        else
        {
            PORTD &= ~(_BV(PORTD4));
 a82:	5c 98       	cbi	0x0b, 4	; 11
    // instantiate DemoApp
    DemoApp& theApp = DemoApp::instance;

    // configure all software modules
    DebugPin::configure();
    DemoApp::configure();   
 a84:	57 de       	rcall	.-850    	; 0x734 <_ZN7DemoApp9configureEv>
 a86:	81 e0       	ldi	r24, 0x01	; 1
    Stack::instance.configure();
 a88:	91 e0       	ldi	r25, 0x01	; 1
 a8a:	88 df       	rcall	.-240    	; 0x99c <_ZN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9configureEv>
 a8c:	78 94       	sei
 a8e:	83 b7       	in	r24, 0x33	; 51

    // enable interrupts
    sei();
 a90:	81 7f       	andi	r24, 0xF1	; 241

    // select sleep mode
    set_sleep_mode(SLEEP_MODE_IDLE);
 a92:	83 bf       	out	0x33, r24	; 51
 a94:	83 b7       	in	r24, 0x33	; 51
 a96:	81 60       	ori	r24, 0x01	; 1

    // enter infinite loop: processing is interrupt controlled from now on
    for (;;)
    {
        // enter sleep until interrupt wakes us up
        sleep_mode();
 a98:	83 bf       	out	0x33, r24	; 51
 a9a:	88 95       	sleep
 a9c:	83 b7       	in	r24, 0x33	; 51
 a9e:	8e 7f       	andi	r24, 0xFE	; 254
 aa0:	83 bf       	out	0x33, r24	; 51
 aa2:	80 91 14 01 	lds	r24, 0x0114
//------------------------------------------------------------------------------
template <class T, int PDI, int PDO, class SpiSsHndlr>
bool StackBase<T, PDI, PDO, SpiSsHndlr>::canRunUserCode(const Parameter*& lastWrittenParameter)
{
    // allow execution of user code?
    if (!_runUserCode)
 aa6:	80 ff       	sbrs	r24, 0
 aa8:	f5 cf       	rjmp	.-22     	; 0xa94 <main+0x2a>
 aaa:	8e 7f       	andi	r24, 0xFE	; 254
 aac:	80 93 14 01 	sts	0x0114, r24
        return false;

    // reset flag
    _runUserCode = false;
 ab0:	81 ff       	sbrs	r24, 1
 ab2:	06 c0       	rjmp	.+12     	; 0xac0 <main+0x56>

    // test for parameter write access
    if (_prmWriteAvailable)
 ab4:	8d 7f       	andi	r24, 0xFD	; 253
 ab6:	80 93 14 01 	sts	0x0114, r24
    {
        lastWrittenParameter = &_parameterWrite;

        // reset write access
        _prmWriteAvailable = false;
 aba:	6b e0       	ldi	r22, 0x0B	; 11
 abc:	71 e0       	ldi	r23, 0x01	; 1
    _runUserCode = false;

    // test for parameter write access
    if (_prmWriteAvailable)
    {
        lastWrittenParameter = &_parameterWrite;
 abe:	02 c0       	rjmp	.+4      	; 0xac4 <main+0x5a>
 ac0:	60 e0       	ldi	r22, 0x00	; 0
 ac2:	70 e0       	ldi	r23, 0x00	; 0
        // reset write access
        _prmWriteAvailable = false;
    }
    else
    {
        lastWrittenParameter = NULL;
 ac4:	80 91 6c 00 	lds	r24, 0x006C

//------------------------------------------------------------------------------
template <class SpiSsHndlr>
void PhyDriver<SpiSsHndlr>::stopInterrupt()
{
    PCMSK1 &= ~(_BV(PCINT8));
 ac8:	8e 7f       	andi	r24, 0xFE	; 254
 aca:	80 93 6c 00 	sts	0x006C, r24
 ace:	8d e3       	ldi	r24, 0x3D	; 61
 ad0:	91 e0       	ldi	r25, 0x01	; 1
        // check if it's time to run user code
        const Stack::Parameter* paramWrite;
        if (Stack::instance.canRunUserCode(paramWrite))
        {
            Stack::instance.stopInterrupt();
            theApp.run(paramWrite);
 ad2:	31 df       	rcall	.-414    	; 0x936 <_ZN7DemoApp3runEPKN9StackBaseI14StackMultiByteLi4ELi0E16DefaultSsHandlerE9ParameterE>
 ad4:	80 91 6c 00 	lds	r24, 0x006C
 ad8:	81 60       	ori	r24, 0x01	; 1

//------------------------------------------------------------------------------
template <class SpiSsHndlr>
void PhyDriver<SpiSsHndlr>::restartInterrupt()
{
    PCMSK1 |= _BV(PCINT8);
 ada:	80 93 6c 00 	sts	0x006C, r24
 ade:	78 dd       	rcall	.-1296   	; 0x5d0 <__vector_4>
 ae0:	d9 cf       	rjmp	.-78     	; 0xa94 <main+0x2a>

00000ae2 <__tablejump2__>:
 ae2:	ee 0f       	add	r30, r30

    // call ISR handler
    PCINT1_vect();
 ae4:	ff 1f       	adc	r31, r31
 ae6:	05 90       	lpm	r0, Z+
 ae8:	f4 91       	lpm	r31, Z
 aea:	e0 2d       	mov	r30, r0
 aec:	09 94       	ijmp

00000aee <memcpy_P>:
 aee:	fb 01       	movw	r30, r22
 af0:	dc 01       	movw	r26, r24
 af2:	02 c0       	rjmp	.+4      	; 0xaf8 <memcpy_P+0xa>
 af4:	05 90       	lpm	r0, Z+
 af6:	0d 92       	st	X+, r0
 af8:	41 50       	subi	r20, 0x01	; 1
 afa:	50 40       	sbci	r21, 0x00	; 0
 afc:	d8 f7       	brcc	.-10     	; 0xaf4 <memcpy_P+0x6>
 afe:	08 95       	ret

00000b00 <_exit>:
 b00:	f8 94       	cli

00000b02 <__stop_program>:
 b02:	ff cf       	rjmp	.-2      	; 0xb02 <__stop_program>
