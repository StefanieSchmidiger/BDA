<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>HMT Mini-Stack software: StackMultiByte Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="HMT-logo.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">HMT Mini-Stack software
   &#160;<span id="projectnumber">1.0.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">StackMultiByte Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="StackMultiByte" --><!-- doxytag: inherits="StackBase" -->
<p>Stack implementation using multi-byte mode.  
 <a href="class_stack_multi_byte.html#details">More...</a></p>

<p><code>#include &lt;stackmultibyte.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for StackMultiByte:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_stack_multi_byte.png" usemap="#StackMultiByte_map" alt=""/>
  <map id="StackMultiByte_map" name="StackMultiByte_map">
<area href="class_stack_base.html" title="The StackBase is the base class for minimal IO-Link stacks for different IO-Link devices." alt="StackBase&lt; T, PDI, PDO, SpiSsHndlr &gt;" shape="rect" coords="0,56,205,80"/>
<area href="class_phy_driver.html" title="Static class implementing register access to the PHY." alt="PhyDriver&lt; SpiSsHndlr &gt;" shape="rect" coords="0,0,205,24"/>
</map>
 </div></div>

<p><a href="class_stack_multi_byte-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#aba03e68229de6848aa8dbcbebb0b8fa1">Led</a> { <a class="el" href="class_stack_base.html#aba03e68229de6848aa8dbcbebb0b8fa1a4a55e3c481ac3717ffd540efe2cdada9">LED_1</a>, 
<a class="el" href="class_stack_base.html#aba03e68229de6848aa8dbcbebb0b8fa1a8243769f261f048c81e94e82c37e8845">LED_2</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LEDs.  <a href="class_stack_base.html#aba03e68229de6848aa8dbcbebb0b8fa1">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a6db4d23904347b9a9a4843a1a4dd3625">StackMode</a> { <b>STACK_MODE_SIO</b>, 
<b>STACK_MODE_IOLINK</b>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack mode. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a3dcf9e80a57e04850e9d352314ab3d1f">SioDriveMode</a> { <a class="el" href="class_stack_base.html#a3dcf9e80a57e04850e9d352314ab3d1fa75f3754813a2ebfc35f1444723fdfaf2">DRIVE_MODE_PUSH_PULL</a> =  0, 
<a class="el" href="class_stack_base.html#a3dcf9e80a57e04850e9d352314ab3d1fafad837a4257fb2e2da156eee102574c5">DRIVE_MODE_NPN</a>, 
<a class="el" href="class_stack_base.html#a3dcf9e80a57e04850e9d352314ab3d1faf61e899e8cb745fae418ea0ba7448784">DRIVE_MODE_PNP</a>, 
<a class="el" href="class_stack_base.html#a3dcf9e80a57e04850e9d352314ab3d1fa70ad0a02cc8bf4d1c74eb3ab6b51e182">DRIVE_MODE_INACTIVE</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Drive capability in SIO mode.  <a href="class_stack_base.html#a3dcf9e80a57e04850e9d352314ab3d1f">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1030d5446e44aaa9095be32bff8eb343"></a><!-- doxytag: member="StackMultiByte::Phy" ref="a1030d5446e44aaa9095be32bff8eb343" args="" -->
typedef <a class="el" href="class_phy_driver.html">PhyDriver</a>&lt; SpiSsHndlr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a1030d5446e44aaa9095be32bff8eb343">Phy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience typedef for <a class="el" href="class_phy_driver.html" title="Static class implementing register access to the PHY.">PhyDriver</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacc069c5ddb782702ed3410369f3e833"></a><!-- doxytag: member="StackMultiByte::StackT" ref="aacc069c5ddb782702ed3410369f3e833" args="" -->
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#aacc069c5ddb782702ed3410369f3e833">StackT</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specific derived stack type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a249c62d18d7f5249b8b5181eeb62d7b3"></a><!-- doxytag: member="StackMultiByte::BaseT" ref="a249c62d18d7f5249b8b5181eeb62d7b3" args="" -->
typedef <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, <br class="typebreak"/>
SpiSsHndlr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a249c62d18d7f5249b8b5181eeb62d7b3">BaseT</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience typedef for this class. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23bedeec38ffe6161974a64ed69a599c"></a><!-- doxytag: member="StackMultiByte::ProcessDataIn" ref="a23bedeec38ffe6161974a64ed69a599c" args="" -->
typedef <a class="el" href="struct_stack_base_1_1_process_data.html">ProcessData</a>&lt; PDI &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a23bedeec38ffe6161974a64ed69a599c">ProcessDataIn</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Input process data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cc01e2d617efb90f3ad7b9a0dbc9f69"></a><!-- doxytag: member="StackMultiByte::ProcessDataOut" ref="a1cc01e2d617efb90f3ad7b9a0dbc9f69" args="" -->
typedef <a class="el" href="struct_stack_base_1_1_process_data.html">ProcessData</a>&lt; PDO &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a1cc01e2d617efb90f3ad7b9a0dbc9f69">ProcessDataOut</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output process data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#ae290b3f020b5a79f2dc8461c096fb928">LedLevel</a> { <br/>
&#160;&#160;<a class="el" href="class_phy_driver.html#ae290b3f020b5a79f2dc8461c096fb928a89e8da1db7236717b27dfec7bd4f8077">LED_LEVEL_OFF</a>, 
<a class="el" href="class_phy_driver.html#ae290b3f020b5a79f2dc8461c096fb928a77737b265d716d2c1ecba8375fcafa62">LED_LEVEL_1</a>, 
<a class="el" href="class_phy_driver.html#ae290b3f020b5a79f2dc8461c096fb928a6a83cb0be345e7d895dd90fc21715dcf">LED_LEVEL_2</a>, 
<a class="el" href="class_phy_driver.html#ae290b3f020b5a79f2dc8461c096fb928ab53d99fcb0aae57dedb95caa2f7c4a03">LED_LEVEL_3</a>, 
<br/>
&#160;&#160;<a class="el" href="class_phy_driver.html#ae290b3f020b5a79f2dc8461c096fb928af2f3a3f08fb2150f7cebfbfecaffd4ee">LED_LEVEL_4</a>, 
<a class="el" href="class_phy_driver.html#ae290b3f020b5a79f2dc8461c096fb928a7e1fc2bd6e4961501ac9db51971fbebf">LED_LEVEL_5</a>, 
<a class="el" href="class_phy_driver.html#ae290b3f020b5a79f2dc8461c096fb928a328040a7a5a65d65acabed81cad3fd1a">LED_LEVEL_6</a>, 
<a class="el" href="class_phy_driver.html#ae290b3f020b5a79f2dc8461c096fb928a5e459f2313778df3b50cfa275e2f94f9">LED_LEVEL_7</a>, 
<br/>
&#160;&#160;<b>LED_LEVEL_MAX</b> =  LED_LEVEL_7, 
<a class="el" href="class_phy_driver.html#ae290b3f020b5a79f2dc8461c096fb928aae1a262375bfac1b09083b5c96feb9e8">LED_LEVEL_INVALID</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LED currents.  <a href="class_phy_driver.html#ae290b3f020b5a79f2dc8461c096fb928">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25c9e0c7eebea865ddf59cc192b9f9a6"></a><!-- doxytag: member="StackMultiByte::configure" ref="a25c9e0c7eebea865ddf59cc192b9f9a6" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a25c9e0c7eebea865ddf59cc192b9f9a6">configure</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure sets up the hardware resources on the uC, and initializes the stack. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#afc10293a20578493f96c4a9df0214588">canRunUserCode</a> (const <a class="el" href="struct_stack_base_1_1_parameter.html">Parameter</a> *&amp;lastWrittenParameter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_stack_base.html#a6db4d23904347b9a9a4843a1a4dd3625">StackMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a19460c2295fea1889af3f24b854a0be3">stackMode</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current stack mode.  <a href="#a19460c2295fea1889af3f24b854a0be3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#acfd926835fe22d245c25d89fdd16fb57">masterLost</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if connection to master has been lost.  <a href="#acfd926835fe22d245c25d89fdd16fb57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a203a612a2d635a6b12b9d30a827c3eef"></a><!-- doxytag: member="StackMultiByte::flag" ref="a203a612a2d635a6b12b9d30a827c3eef" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a203a612a2d635a6b12b9d30a827c3eef">flag</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging flag. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a5f37283c0dd6c22c9aad37ae4f9ba41d">setSioLevel</a> (bool active)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the level of the CQ line in SIO mode (STACK_MODE_SIO) state.  <a href="#a5f37283c0dd6c22c9aad37ae4f9ba41d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a2bd81a6437f3bca35cccdd92a681ad3e">parameterRead</a> (uint8_t address) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read value from direct parameter page.  <a href="#a2bd81a6437f3bca35cccdd92a681ad3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a98da21e399322a4c83f069ca6532bb67">parameterWrite</a> (uint8_t address, uint8_t value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write value to direct parameter page.  <a href="#a98da21e399322a4c83f069ca6532bb67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_stack_base.html#a23bedeec38ffe6161974a64ed69a599c">ProcessDataIn</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#af707582de534cc16206350465693e14d">processInputData</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get buffer for returning process input data from slave to master.  <a href="#af707582de534cc16206350465693e14d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_stack_base.html#a1cc01e2d617efb90f3ad7b9a0dbc9f69">ProcessDataOut</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a32e528826cf2ef157e7848630ccfea3c">processOutputData</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get buffer for process output data received from master.  <a href="#a32e528826cf2ef157e7848630ccfea3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a3886bb7a9e5f77ff948c858ce000810c">setLedLevel</a> (<a class="el" href="class_stack_base.html#aba03e68229de6848aa8dbcbebb0b8fa1">Led</a> led, typename <a class="el" href="class_phy_driver.html#ae290b3f020b5a79f2dc8461c096fb928">Phy::LedLevel</a> level)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set LED level.  <a href="#a3886bb7a9e5f77ff948c858ce000810c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_phy_driver.html#ae290b3f020b5a79f2dc8461c096fb928">Phy::LedLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a5d2a5b7a804805f6ee708a31c925c614">ledLevel</a> (<a class="el" href="class_stack_base.html#aba03e68229de6848aa8dbcbebb0b8fa1">Led</a> led) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get LED level.  <a href="#a5d2a5b7a804805f6ee708a31c925c614"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#af1158c426af1489d6599aa902dc9f7cf">temperature</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current measured temperature value.  <a href="#af1158c426af1489d6599aa902dc9f7cf"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58078f10073f2239a07dcb3e43b8d446"></a><!-- doxytag: member="StackMultiByte::stopInterrupt" ref="a58078f10073f2239a07dcb3e43b8d446" args="()" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a58078f10073f2239a07dcb3e43b8d446">stopInterrupt</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporarily disable the ISR. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae614833d6ed06e8ae8b690c225141dd6"></a><!-- doxytag: member="StackMultiByte::restartInterrupt" ref="ae614833d6ed06e8ae8b690c225141dd6" args="()" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#ae614833d6ed06e8ae8b690c225141dd6">restartInterrupt</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart the ISR. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e3381676b5e4bf1384d78350cb5b9fd"></a><!-- doxytag: member="StackMultiByte::REVISION_ID" ref="a1e3381676b5e4bf1384d78350cb5b9fd" args="" -->
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_multi_byte.html#a1e3381676b5e4bf1384d78350cb5b9fd">REVISION_ID</a> = IoLink::REVISION_ID_1_1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">RevisionID of protocol implemented (Direct Parameter 0x04) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c8d55b1c01e0b8f87cbdd93bcc47106"></a><!-- doxytag: member="StackMultiByte::VENDOR_ID" ref="a2c8d55b1c01e0b8f87cbdd93bcc47106" args="" -->
static const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_multi_byte.html#a2c8d55b1c01e0b8f87cbdd93bcc47106">VENDOR_ID</a> = 0x01a6</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">VendorID (Direct Parameters 0x07 and 0x08) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2ab5c8ee32a38901842d0e886afe55b"></a><!-- doxytag: member="StackMultiByte::DEVICE_ID" ref="ad2ab5c8ee32a38901842d0e886afe55b" args="" -->
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_multi_byte.html#ad2ab5c8ee32a38901842d0e886afe55b">DEVICE_ID</a> = 0x123456</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DeviceID (Direct Parameters 0x09 - 0x0b) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0afe2483a3d59140ddd04090a336406d"></a><!-- doxytag: member="StackMultiByte::BAUD_RATE" ref="a0afe2483a3d59140ddd04090a336406d" args="" -->
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_multi_byte.html#a0afe2483a3d59140ddd04090a336406d">BAUD_RATE</a> = 38400</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Communication speed (must be either 38400 or 230400) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad730e30b7a4bd23bb1feca4201c5633a"></a><!-- doxytag: member="StackMultiByte::MIN_CYC_TIME" ref="ad730e30b7a4bd23bb1feca4201c5633a" args="" -->
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_multi_byte.html#ad730e30b7a4bd23bb1feca4201c5633a">MIN_CYC_TIME</a> = 30</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MinCycleTime in 0.1ms units. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_multi_byte.html#a5ebd01fd0a680fa8a9e26dbdcb5981cb">MSEQ_CAPABILITY</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">M-sequence Capability (Direct Parameter 0x03)  <a href="#a5ebd01fd0a680fa8a9e26dbdcb5981cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_multi_byte.html#a4de9e504f38e60ca8d25d39a0e833490">PHY_CFG</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PHY configuration.  <a href="#a4de9e504f38e60ca8d25d39a0e833490"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72c28b2ae05331e1a78cffa8f6f9062d"></a><!-- doxytag: member="StackMultiByte::PHY_CTL_SCT" ref="a72c28b2ae05331e1a78cffa8f6f9062d" args="" -->
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_multi_byte.html#a72c28b2ae05331e1a78cffa8f6f9062d">PHY_CTL_SCT</a> = CTL_SCT_190MA</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PHY short-circuit threshold. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36f36d7e03ece276f5291e0eb8f4fa27"></a><!-- doxytag: member="StackMultiByte::PHY_CTL_MODE" ref="a36f36d7e03ece276f5291e0eb8f4fa27" args="" -->
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_multi_byte.html#a36f36d7e03ece276f5291e0eb8f4fa27">PHY_CTL_MODE</a> = CTL_IOLINK_MODE</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PHY mode (must be CTL_IOLINK_MODE) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6243166470d7f7fe9fde2e0ef5f33674"></a><!-- doxytag: member="StackMultiByte::SIO_DRIVE_MODE" ref="a6243166470d7f7fe9fde2e0ef5f33674" args="" -->
static enum <a class="el" href="class_stack_base.html#a3dcf9e80a57e04850e9d352314ab3d1f">SioDriveMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_multi_byte.html#a6243166470d7f7fe9fde2e0ef5f33674">SIO_DRIVE_MODE</a> = DRIVE_MODE_PUSH_PULL</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PHY drive mode to use in SIO mode. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac433744a89671ee87c58d9081a460b95"></a><!-- doxytag: member="StackMultiByte::PHY_THERM_DEG" ref="ac433744a89671ee87c58d9081a460b95" args="" -->
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_multi_byte.html#ac433744a89671ee87c58d9081a460b95">PHY_THERM_DEG</a> = 175</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PHY thermal shutdown temperature (in degrees centigrade) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41dc83c2d8a90a805994b4ea86934f36"></a><!-- doxytag: member="StackMultiByte::instance" ref="a41dc83c2d8a90a805994b4ea86934f36" args="" -->
static <a class="el" href="class_stack_multi_byte.html">StackMultiByte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_multi_byte.html#a41dc83c2d8a90a805994b4ea86934f36">instance</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The one and only stack instance. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39f93217cc84d22175fac4a9ed8cbbdc"></a><!-- doxytag: member="StackMultiByte::PD_IN_SIZE" ref="a39f93217cc84d22175fac4a9ed8cbbdc" args="" -->
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a39f93217cc84d22175fac4a9ed8cbbdc">PD_IN_SIZE</a> = PDI</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of input process data (in octets) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a008aa4c3f95711215caf76105a6bfe88"></a><!-- doxytag: member="StackMultiByte::PD_OUT_SIZE" ref="a008aa4c3f95711215caf76105a6bfe88" args="" -->
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a008aa4c3f95711215caf76105a6bfe88">PD_OUT_SIZE</a> = PDO</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of output process data (in octets) <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#afb7ff3c3ea3ba6ea6dce07589c7f70d3">HandlerResult</a> { <br/>
&#160;&#160;<b>ResultSuccess</b> =  0, 
<b>ResultNoData</b>, 
<b>ResultChecksumError</b>, 
<b>ResultIllegalMessageType</b>, 
<br/>
&#160;&#160;<b>ResultPhyReset</b>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Result codes for ISR sub-handlers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#ac5693c6e85cbe34cc1550150601f9b3d">MseqRegister</a> { <b>MSEQ_M2CNT_SHIFT</b> =  2, 
<b>MSEQ_OD_1</b> =  0 &lt;&lt; 0, 
<b>MSEQ_OD_2</b> =  1 &lt;&lt; 0, 
<b>MSEQ_OD_8</b> =  2 &lt;&lt; 0
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PHY MSEQ register flags. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#ade7686aea200c2dbe07c1ade2a4756b1">CfgRegister</a> { <br/>
&#160;&#160;<b>CFG_NONE</b> =  0, 
<b>CFG_UVT_18_0V</b> =  0 &lt;&lt; 5, 
<b>CFG_UVT_16_3V</b> =  1 &lt;&lt; 5, 
<b>CFG_UVT_15_0V</b> =  2 &lt;&lt; 5, 
<br/>
&#160;&#160;<b>CFG_UVT_13_9V</b> =  3 &lt;&lt; 5, 
<b>CFG_UVT_12_0V</b> =  4 &lt;&lt; 5, 
<b>CFG_UVT_10_0V</b> =  5 &lt;&lt; 5, 
<b>CFG_UVT_8_6V</b> =  6 &lt;&lt; 5, 
<br/>
&#160;&#160;<b>CFG_UVT_7_2V</b> =  7 &lt;&lt; 5, 
<a class="el" href="class_phy_driver.html#ade7686aea200c2dbe07c1ade2a4756b1aa76bc8384e8ecfa639e67f80525e6131">CFG_BD_38400</a> =  0 &lt;&lt; 4, 
<a class="el" href="class_phy_driver.html#ade7686aea200c2dbe07c1ade2a4756b1a4390ee12dbd6a30b61149d39f29de0a2">CFG_BD_230400</a> =  1 &lt;&lt; 4, 
<b>CFG_RF_ABS</b> =  0 &lt;&lt; 3, 
<br/>
&#160;&#160;<b>CFG_RF_REL</b> =  1 &lt;&lt; 3, 
<b>CFG_S5V_SS</b> =  0 &lt;&lt; 0, 
<b>CFG_S5V_3_3V</b> =  2 &lt;&lt; 0, 
<b>CFG_S5V_5_0V</b> =  3 &lt;&lt; 0
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PHY CFG register flags.  <a href="class_phy_driver.html#ade7686aea200c2dbe07c1ade2a4756b1">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#a1ec684509a017e02e797a7e1314ad3b0">CtlRegister</a> { <br/>
&#160;&#160;<b>CTL_NONE</b> =  0, 
<b>CTL_TRNS_MODE</b> =  1 &lt;&lt; 7, 
<b>CTL_SCT_190MA</b> =  0 &lt;&lt; 4, 
<b>CTL_SCT_210MA</b> =  1 &lt;&lt; 4, 
<br/>
&#160;&#160;<b>CTL_SCT_230MA</b> =  2 &lt;&lt; 4, 
<b>CTL_SCT_250MA</b> =  3 &lt;&lt; 4, 
<b>CTL_SCT_110MA</b> =  4 &lt;&lt; 4, 
<b>CTL_SCT_130MA</b> =  5 &lt;&lt; 4, 
<br/>
&#160;&#160;<b>CTL_SCT_150MA</b> =  6 &lt;&lt; 4, 
<b>CTL_SCT_170MA</b> =  7 &lt;&lt; 4, 
<b>CTL_SGL_MODE</b> =  1 &lt;&lt; 3, 
<b>CTL_IEN_MODE</b> =  1 &lt;&lt; 3, 
<br/>
&#160;&#160;<b>CTL_IOLINK_MODE</b> =  0 &lt;&lt; 2, 
<b>CTL_DIO</b> =  1 &lt;&lt; 2, 
<b>CTL_JOIN</b> =  0 &lt;&lt; 2, 
<b>CTL_SIO_MODE</b> =  1 &lt;&lt; 2, 
<br/>
&#160;&#160;<b>CTL_HS</b> =  1 &lt;&lt; 1, 
<b>CTL_LS</b> =  1 &lt;&lt; 0
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PHY CTL register flags. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#a6cdbb86047c2094a9cd0f6598b160b47">LinkRegister</a> { <br/>
&#160;&#160;<b>LINK_NONE</b> =  0, 
<b>LINK_CNT_MASK</b> =  0x3C, 
<b>LINK_CNT_SHIFT</b> =  2, 
<b>LINK_END</b> =  1 &lt;&lt; 1, 
<br/>
&#160;&#160;<b>LINK_SND</b> =  1 &lt;&lt; 0
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PHY LINK register flags. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#a8f5e83453da6ef3956d947875df44ed1">StatusRegister</a> { <br/>
&#160;&#160;<b>STATUS_NONE</b> =  0, 
<b>STATUS_RST</b> =  1 &lt;&lt; 7, 
<b>STATUS_INT</b> =  1 &lt;&lt; 6, 
<b>STATUS_UV</b> =  1 &lt;&lt; 5, 
<br/>
&#160;&#160;<b>STATUS_DINT</b> =  1 &lt;&lt; 4, 
<b>STATUS_CHK</b> =  1 &lt;&lt; 3, 
<b>STATUS_DAT</b> =  1 &lt;&lt; 2, 
<b>STATUS_SSC</b> =  1 &lt;&lt; 1, 
<br/>
&#160;&#160;<b>STATUS_SOT</b> =  1 &lt;&lt; 0
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PHY STATUS register flags. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#abf3ac557edcb0b091f037cffc8e1bfd2">TempRegister</a> { <b>TEMP_NONE</b> =  0
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PHY TEMP register flags. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#a8332bb9bcad6f1800bf24d4fc5eedda1">DcDcRegister</a> { <br/>
&#160;&#160;<b>DCDC_NONE</b> =  0, 
<b>DCDC_DIS</b> =  1 &lt;&lt; 7, 
<b>DCDC_BYP</b> =  1 &lt;&lt; 6, 
<b>DCDC_FSET_500kHz</b> =  4 &lt;&lt; 3, 
<br/>
&#160;&#160;<b>DCDC_FSET_625kHz</b> =  5 &lt;&lt; 3, 
<b>DCDC_FSET_710kHz</b> =  6 &lt;&lt; 3, 
<b>DCDC_FSET_830kHz</b> =  7 &lt;&lt; 3, 
<b>DCDC_FSET_1000kHz</b> =  0 &lt;&lt; 3, 
<br/>
&#160;&#160;<b>DCDC_FSET_1250kHz</b> =  1 &lt;&lt; 3, 
<b>DCDC_FSET_1670kHz</b> =  2 &lt;&lt; 3, 
<b>DCDC_FSET_2000kHz</b> =  3 &lt;&lt; 3, 
<b>DCDC_VSET_4V2</b> =  4, 
<br/>
&#160;&#160;<b>DCDC_VSET_4V5</b> =  5, 
<b>DCDC_VSET_4V9</b> =  6, 
<b>DCDC_VSET_5V4</b> =  7, 
<b>DCDC_VSET_6V0</b> =  0, 
<br/>
&#160;&#160;<b>DCDC_VSET_6V7</b> =  1, 
<b>DCDC_VSET_7V8</b> =  2, 
<b>DCDC_VSET_9V5</b> =  3
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">HMT7748 DCDC register flags. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#a69b0de0f1d0b3bc379804457314b2c16">DstatRegister</a> { <b>DSTAT_NONE</b> =  0, 
<b>DSTAT_LVL</b> =  1 &lt;&lt; 2, 
<b>DSTAT_SSC</b> =  1 &lt;&lt; 1
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">HMT7748 DSTAT register flags. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_stack_base.html#aacc069c5ddb782702ed3410369f3e833">StackT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#ad4c95c8a70f95822c7dc388df674f758">stack</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function returning derived stack specialization.  <a href="#ad4c95c8a70f95822c7dc388df674f758"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addb78060e87aae731037edbca8455120"></a><!-- doxytag: member="StackMultiByte::configureStackBase" ref="addb78060e87aae731037edbca8455120" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#addb78060e87aae731037edbca8455120">configureStackBase</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the stack base class. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45721fbbef2917ea67edff06103e93dd"></a><!-- doxytag: member="StackMultiByte::configureStack" ref="a45721fbbef2917ea67edff06103e93dd" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a45721fbbef2917ea67edff06103e93dd">configureStack</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty default implementation of derived stack configuration. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#af489c4b1c37a50a4caf178e2186da214">configurePhy</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the PHY.  <a href="#af489c4b1c37a50a4caf178e2186da214"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#afd27d8ef43303f31ddd5a83b8b65c0b0">setSioActive</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Put PHY in SIO-Active state.  <a href="#afd27d8ef43303f31ddd5a83b8b65c0b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#adae86d1fe4a4320d6beaa3a01c56774a">odWrite</a> (uint8_t channel, uint8_t address, uint8_t data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write received on-demand data.  <a href="#adae86d1fe4a4320d6beaa3a01c56774a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a028c49ff6a97d8c9fd43460d8c67587e">odRead</a> (uint8_t channel, uint8_t address)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read requested on-demand data.  <a href="#a028c49ff6a97d8c9fd43460d8c67587e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9c5385e4c5d0e40b846e77a15708e67"></a><!-- doxytag: member="StackMultiByte::updateCyclePeriod" ref="ac9c5385e4c5d0e40b846e77a15708e67" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#ac9c5385e4c5d0e40b846e77a15708e67">updateCyclePeriod</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate cycle period from MasterCycleTime. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#aaa8c60e19125424e7d78063182485ece">startCallbackTimer</a> (uint8_t delay=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start / synchronize user-callback timer.  <a href="#aaa8c60e19125424e7d78063182485ece"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7335345690c06200fb7c2561713dd48"></a><!-- doxytag: member="StackMultiByte::onTimer0CompBInterrupt" ref="ae7335345690c06200fb7c2561713dd48" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#ae7335345690c06200fb7c2561713dd48">onTimer0CompBInterrupt</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ISR handler as member function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">friend&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a8edcb86567e271faaa365c9294b4c975">void::TIMER0_COMPB_vect</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The ISR function can access the stack state, and is declared here as a friend.  <a href="#a8edcb86567e271faaa365c9294b4c975"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a5a62338b4ed70e09a471a2d5771a3b48">setSioListen</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Put PHY in SIO-Listen mode.  <a href="#a5a62338b4ed70e09a471a2d5771a3b48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#aca369861be996ee1bd185a6b0c5faa54">setIoLinkListen</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Put PHY in IO-Link-Listen mode.  <a href="#aca369861be996ee1bd185a6b0c5faa54"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;IoLink::DeviceDLMode DDL_MODE&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a86cf479d55b6af402b865ac50431365d">getOdOctetCount</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of OD octets.  <a href="#a86cf479d55b6af402b865ac50431365d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f9451e6a937d00051251bd67286b72c"></a><!-- doxytag: member="StackMultiByte::validateControlOctet" ref="a7f9451e6a937d00051251bd67286b72c" args="(uint8_t mc)" -->
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a7f9451e6a937d00051251bd67286b72c">validateControlOctet</a> (uint8_t mc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate control octet. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;IoLink::DeviceDLMode DDL_MODE&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a496c084e0accd0e1850bd38c33b54cdf">validateFrameType</a> (uint8_t ckt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate frame type.  <a href="#a496c084e0accd0e1850bd38c33b54cdf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#a3e69188f608ae6042cf70e0c81a23b8f">registerReadBegin</a> (Registers address)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start reading from PHY registers.  <a href="#a3e69188f608ae6042cf70e0c81a23b8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#a86da8a9341905d2407b3e0092f098810">registerReadNext</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next PHY register value.  <a href="#a86da8a9341905d2407b3e0092f098810"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#a66321e787e8cf040b58451a94335c79c">registerReadLast</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read final PHY register value.  <a href="#a66321e787e8cf040b58451a94335c79c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#abb5d9abac9362d93a92c074c52de3c66">registerRead</a> (Registers address)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single byte from a PHY register.  <a href="#abb5d9abac9362d93a92c074c52de3c66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#a47a2482b49abe71602179fd3aa07d618">registerReadStatus</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the status register.  <a href="#a47a2482b49abe71602179fd3aa07d618"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#acc92fa8676c28e9d37bb9829d097efcd">registerWriteBegin</a> (Registers address)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start write operation to PHY registers.  <a href="#acc92fa8676c28e9d37bb9829d097efcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#ae07a77c1480a60438716fc6817ce3c3e">registerWriteBegin</a> (Registers address, uint8_t data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start write operation to PHY registers.  <a href="#ae07a77c1480a60438716fc6817ce3c3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#ab524d19f3140e0f85cf749455386d777">registerWriteNext</a> (uint8_t data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write next PHY register value.  <a href="#ab524d19f3140e0f85cf749455386d777"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#ac12de1a0052912732c3e336a63813288">registerWriteDone</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish write access.  <a href="#ac12de1a0052912732c3e336a63813288"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#a398f7bbadcaaddf963e47620f68e1374">registerWrite</a> (Registers address, uint8_t data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single byte to a PHY register.  <a href="#a398f7bbadcaaddf963e47620f68e1374"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#a7f903f8fdaa2eab1b7590bc313e6b953">registerReadWriteBegin</a> (Registers address, uint8_t data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start write/read operation to PHY registers.  <a href="#a7f903f8fdaa2eab1b7590bc313e6b953"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#acb69fbf8ceb40d008bf224d391e6d227">registerReadWriteNext</a> (uint8_t data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write/read next PHY register value.  <a href="#acb69fbf8ceb40d008bf224d391e6d227"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#ae716f1ad688df5d7ec51c21ac7455714">registerReadWriteDone</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish write access and return final PHY register value.  <a href="#ae716f1ad688df5d7ec51c21ac7455714"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ff069348992fd9de376ac1b3ea464f8"></a><!-- doxytag: member="StackMultiByte::registerAbortAccess" ref="a5ff069348992fd9de376ac1b3ea464f8" args="()" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#a5ff069348992fd9de376ac1b3ea464f8">registerAbortAccess</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort register access. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73a8c5154502ec9a3a8cb0bdbc81a0cc"></a><!-- doxytag: member="StackMultiByte::_ddlMode" ref="a73a8c5154502ec9a3a8cb0bdbc81a0cc" args="" -->
<a class="el" href="class_io_link.html#ad6edfa5d119210ab07d3cfdecb82621f">IoLink::DeviceDLMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a73a8c5154502ec9a3a8cb0bdbc81a0cc">_ddlMode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Device DL-mode. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad11dbabed4bed514036e66bbe175b088"></a><!-- doxytag: member="StackMultiByte::_processDataIn" ref="ad11dbabed4bed514036e66bbe175b088" args="" -->
<a class="el" href="class_stack_base.html#a23bedeec38ffe6161974a64ed69a599c">ProcessDataIn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#ad11dbabed4bed514036e66bbe175b088">_processDataIn</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">process input data buffers <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b75d6ac67f8adc07c77774eebf55cf4"></a><!-- doxytag: member="StackMultiByte::_processDataOut" ref="a7b75d6ac67f8adc07c77774eebf55cf4" args="" -->
<a class="el" href="class_stack_base.html#a1cc01e2d617efb90f3ad7b9a0dbc9f69">ProcessDataOut</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a7b75d6ac67f8adc07c77774eebf55cf4">_processDataOut</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">process output data buffer <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02264a0b73f13eb8467276bc2b10596d"></a><!-- doxytag: member="StackMultiByte::_deadCycleCtr" ref="a02264a0b73f13eb8467276bc2b10596d" args="" -->
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a02264a0b73f13eb8467276bc2b10596d">_deadCycleCtr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of cycles from last master exchange. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31f6b4498c6514ea05532a48437b035d"></a><!-- doxytag: member="StackMultiByte::_hiZCounter" ref="a31f6b4498c6514ea05532a48437b035d" args="" -->
int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a31f6b4498c6514ea05532a48437b035d">_hiZCounter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cycle counter for listening to the CQ. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27f6375f9dc5a504f73a8bcd770d99ff"></a><!-- doxytag: member="StackMultiByte::_sioLevel" ref="a27f6375f9dc5a504f73a8bcd770d99ff" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stack_base.html#a27f6375f9dc5a504f73a8bcd770d99ff">_sioLevel</a>: 1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Level of CQ line during SIOActive state. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba73911a05005586cc4b5a202cf6b08d"></a><!-- doxytag: member="StackMultiByte::_ssHndlr" ref="aba73911a05005586cc4b5a202cf6b08d" args="" -->
static SpiSsHndlr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_phy_driver.html#aba73911a05005586cc4b5a202cf6b08d">_ssHndlr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler functor for SS/ line. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Stack implementation using multi-byte mode. </p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ade7686aea200c2dbe07c1ade2a4756b1"></a><!-- doxytag: member="StackMultiByte::CfgRegister" ref="ade7686aea200c2dbe07c1ade2a4756b1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpiSsHndlr = DefaultSsHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_phy_driver.html#ade7686aea200c2dbe07c1ade2a4756b1">PhyDriver::CfgRegister</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PHY CFG register flags. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ade7686aea200c2dbe07c1ade2a4756b1aa76bc8384e8ecfa639e67f80525e6131"></a><!-- doxytag: member="CFG_BD_38400" ref="ade7686aea200c2dbe07c1ade2a4756b1aa76bc8384e8ecfa639e67f80525e6131" args="" -->CFG_BD_38400</em>&nbsp;</td><td>
<p>COM2. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ade7686aea200c2dbe07c1ade2a4756b1a4390ee12dbd6a30b61149d39f29de0a2"></a><!-- doxytag: member="CFG_BD_230400" ref="ade7686aea200c2dbe07c1ade2a4756b1a4390ee12dbd6a30b61149d39f29de0a2" args="" -->CFG_BD_230400</em>&nbsp;</td><td>
<p>COM3. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aba03e68229de6848aa8dbcbebb0b8fa1"></a><!-- doxytag: member="StackMultiByte::Led" ref="aba03e68229de6848aa8dbcbebb0b8fa1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int PDI, int PDO, class SpiSsHndlr = DefaultSsHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_stack_base.html#aba03e68229de6848aa8dbcbebb0b8fa1">StackBase::Led</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LEDs. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aba03e68229de6848aa8dbcbebb0b8fa1a4a55e3c481ac3717ffd540efe2cdada9"></a><!-- doxytag: member="LED_1" ref="aba03e68229de6848aa8dbcbebb0b8fa1a4a55e3c481ac3717ffd540efe2cdada9" args="" -->LED_1</em>&nbsp;</td><td>
<p>LED 1. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aba03e68229de6848aa8dbcbebb0b8fa1a8243769f261f048c81e94e82c37e8845"></a><!-- doxytag: member="LED_2" ref="aba03e68229de6848aa8dbcbebb0b8fa1a8243769f261f048c81e94e82c37e8845" args="" -->LED_2</em>&nbsp;</td><td>
<p>LED 2. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ae290b3f020b5a79f2dc8461c096fb928"></a><!-- doxytag: member="StackMultiByte::LedLevel" ref="ae290b3f020b5a79f2dc8461c096fb928" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpiSsHndlr = DefaultSsHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_phy_driver.html#ae290b3f020b5a79f2dc8461c096fb928">PhyDriver::LedLevel</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LED currents. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae290b3f020b5a79f2dc8461c096fb928a89e8da1db7236717b27dfec7bd4f8077"></a><!-- doxytag: member="LED_LEVEL_OFF" ref="ae290b3f020b5a79f2dc8461c096fb928a89e8da1db7236717b27dfec7bd4f8077" args="" -->LED_LEVEL_OFF</em>&nbsp;</td><td>
<p>LED off. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae290b3f020b5a79f2dc8461c096fb928a77737b265d716d2c1ecba8375fcafa62"></a><!-- doxytag: member="LED_LEVEL_1" ref="ae290b3f020b5a79f2dc8461c096fb928a77737b265d716d2c1ecba8375fcafa62" args="" -->LED_LEVEL_1</em>&nbsp;</td><td>
<p>~0.5mA </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae290b3f020b5a79f2dc8461c096fb928a6a83cb0be345e7d895dd90fc21715dcf"></a><!-- doxytag: member="LED_LEVEL_2" ref="ae290b3f020b5a79f2dc8461c096fb928a6a83cb0be345e7d895dd90fc21715dcf" args="" -->LED_LEVEL_2</em>&nbsp;</td><td>
<p>~1.0mA </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae290b3f020b5a79f2dc8461c096fb928ab53d99fcb0aae57dedb95caa2f7c4a03"></a><!-- doxytag: member="LED_LEVEL_3" ref="ae290b3f020b5a79f2dc8461c096fb928ab53d99fcb0aae57dedb95caa2f7c4a03" args="" -->LED_LEVEL_3</em>&nbsp;</td><td>
<p>~1.5mA </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae290b3f020b5a79f2dc8461c096fb928af2f3a3f08fb2150f7cebfbfecaffd4ee"></a><!-- doxytag: member="LED_LEVEL_4" ref="ae290b3f020b5a79f2dc8461c096fb928af2f3a3f08fb2150f7cebfbfecaffd4ee" args="" -->LED_LEVEL_4</em>&nbsp;</td><td>
<p>~2.0mA </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae290b3f020b5a79f2dc8461c096fb928a7e1fc2bd6e4961501ac9db51971fbebf"></a><!-- doxytag: member="LED_LEVEL_5" ref="ae290b3f020b5a79f2dc8461c096fb928a7e1fc2bd6e4961501ac9db51971fbebf" args="" -->LED_LEVEL_5</em>&nbsp;</td><td>
<p>~2.5mA </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae290b3f020b5a79f2dc8461c096fb928a328040a7a5a65d65acabed81cad3fd1a"></a><!-- doxytag: member="LED_LEVEL_6" ref="ae290b3f020b5a79f2dc8461c096fb928a328040a7a5a65d65acabed81cad3fd1a" args="" -->LED_LEVEL_6</em>&nbsp;</td><td>
<p>~3.0mA </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae290b3f020b5a79f2dc8461c096fb928a5e459f2313778df3b50cfa275e2f94f9"></a><!-- doxytag: member="LED_LEVEL_7" ref="ae290b3f020b5a79f2dc8461c096fb928a5e459f2313778df3b50cfa275e2f94f9" args="" -->LED_LEVEL_7</em>&nbsp;</td><td>
<p>~3.5mA </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae290b3f020b5a79f2dc8461c096fb928aae1a262375bfac1b09083b5c96feb9e8"></a><!-- doxytag: member="LED_LEVEL_INVALID" ref="ae290b3f020b5a79f2dc8461c096fb928aae1a262375bfac1b09083b5c96feb9e8" args="" -->LED_LEVEL_INVALID</em>&nbsp;</td><td>
<p>not a LED level </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a3dcf9e80a57e04850e9d352314ab3d1f"></a><!-- doxytag: member="StackMultiByte::SioDriveMode" ref="a3dcf9e80a57e04850e9d352314ab3d1f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int PDI, int PDO, class SpiSsHndlr = DefaultSsHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_stack_base.html#a3dcf9e80a57e04850e9d352314ab3d1f">StackBase::SioDriveMode</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drive capability in SIO mode. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a3dcf9e80a57e04850e9d352314ab3d1fa75f3754813a2ebfc35f1444723fdfaf2"></a><!-- doxytag: member="DRIVE_MODE_PUSH_PULL" ref="a3dcf9e80a57e04850e9d352314ab3d1fa75f3754813a2ebfc35f1444723fdfaf2" args="" -->DRIVE_MODE_PUSH_PULL</em>&nbsp;</td><td>
<p>Push-pull, HS and LS active. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3dcf9e80a57e04850e9d352314ab3d1fafad837a4257fb2e2da156eee102574c5"></a><!-- doxytag: member="DRIVE_MODE_NPN" ref="a3dcf9e80a57e04850e9d352314ab3d1fafad837a4257fb2e2da156eee102574c5" args="" -->DRIVE_MODE_NPN</em>&nbsp;</td><td>
<p>LS only used. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3dcf9e80a57e04850e9d352314ab3d1faf61e899e8cb745fae418ea0ba7448784"></a><!-- doxytag: member="DRIVE_MODE_PNP" ref="a3dcf9e80a57e04850e9d352314ab3d1faf61e899e8cb745fae418ea0ba7448784" args="" -->DRIVE_MODE_PNP</em>&nbsp;</td><td>
<p>HS only used. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3dcf9e80a57e04850e9d352314ab3d1fa70ad0a02cc8bf4d1c74eb3ab6b51e182"></a><!-- doxytag: member="DRIVE_MODE_INACTIVE" ref="a3dcf9e80a57e04850e9d352314ab3d1fa70ad0a02cc8bf4d1c74eb3ab6b51e182" args="" -->DRIVE_MODE_INACTIVE</em>&nbsp;</td><td>
<p>neither switch used (typical for an actuator) </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="afc10293a20578493f96c4a9df0214588"></a><!-- doxytag: member="StackMultiByte::canRunUserCode" ref="afc10293a20578493f96c4a9df0214588" args="(const Parameter *&amp;lastWrittenParameter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int PDI, int PDO, class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::canRunUserCode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_stack_base_1_1_parameter.html">Parameter</a> *&amp;&#160;</td>
          <td class="paramname"><em>lastWrittenParameter</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="anchor" id="canRunUserCode"></a> Test if cyclic user code may run</p>
<p>Call this function immediately after being woken up in the application's main() loop, or, if no sleep mode is being used, at least every 0.1ms.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lastWrittenParameter</td><td>Pointer reference in which the function returns a <a class="el" href="struct_stack_base_1_1_parameter.html" title="Parameter structure.">Parameter</a> structure. If the returned pointer is not NULL then the most recent message completed a write access to the direct parameter page. The data is *not* automatically written to the direct parameter page, but needs to be manually committed by calling <a class="el" href="class_stack_base.html#a98da21e399322a4c83f069ca6532bb67" title="Write value to direct parameter page.">parameterWrite()</a>. The returned pointer may be NULL if no write access occurred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true: user code may run now; false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="af489c4b1c37a50a4caf178e2186da214"></a><!-- doxytag: member="StackMultiByte::configurePhy" ref="af489c4b1c37a50a4caf178e2186da214" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int PDI, int PDO, class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::configurePhy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configure the PHY. </p>
<p>This function is called whenever the stack detects that the PHY has been reset </p>

</div>
</div>
<a class="anchor" id="a86cf479d55b6af402b865ac50431365d"></a><!-- doxytag: member="StackMultiByte::getOdOctetCount" ref="a86cf479d55b6af402b865ac50431365d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int PDI, int PDO, class SpiSsHndlr &gt; </div>
<div class="memtemplate">
template&lt;IoLink::DeviceDLMode DDL_MODE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int8_t <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::getOdOctetCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get number of OD octets. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">DDL_MODE</td><td>Applicable DDL mode (see <a class="el" href="class_io_link.html#ad6edfa5d119210ab07d3cfdecb82621f" title="Device DL-mode.">IoLink::DeviceDLMode</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Expected OD octet count </dd></dl>

</div>
</div>
<a class="anchor" id="a5d2a5b7a804805f6ee708a31c925c614"></a><!-- doxytag: member="StackMultiByte::ledLevel" ref="a5d2a5b7a804805f6ee708a31c925c614" args="(Led led) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int PDI, int PDO, class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_phy_driver.html">PhyDriver</a>&lt; SpiSsHndlr &gt;::<a class="el" href="class_phy_driver.html#ae290b3f020b5a79f2dc8461c096fb928">LedLevel</a> <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::ledLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_stack_base.html#aba03e68229de6848aa8dbcbebb0b8fa1">Led</a>&#160;</td>
          <td class="paramname"><em>led</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get LED level. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">led</td><td>Selected LED </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current LED level </dd></dl>

</div>
</div>
<a class="anchor" id="acfd926835fe22d245c25d89fdd16fb57"></a><!-- doxytag: member="StackMultiByte::masterLost" ref="acfd926835fe22d245c25d89fdd16fb57" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int PDI, int PDO, class SpiSsHndlr = DefaultSsHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::masterLost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if connection to master has been lost. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>True</code> if no communication exchange took place for at least four cycles. </dd></dl>

</div>
</div>
<a class="anchor" id="a028c49ff6a97d8c9fd43460d8c67587e"></a><!-- doxytag: member="StackMultiByte::odRead" ref="a028c49ff6a97d8c9fd43460d8c67587e" args="(uint8_t channel, uint8_t address)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int PDI, int PDO, class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::odRead </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read requested on-demand data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Message channel (IoLink::MC_CHNL_*) </td></tr>
    <tr><td class="paramname">address</td><td>Address within selected channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Data octet at address </dd></dl>

</div>
</div>
<a class="anchor" id="adae86d1fe4a4320d6beaa3a01c56774a"></a><!-- doxytag: member="StackMultiByte::odWrite" ref="adae86d1fe4a4320d6beaa3a01c56774a" args="(uint8_t channel, uint8_t address, uint8_t data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int PDI, int PDO, class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::odWrite </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write received on-demand data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Message channel (IoLink::MC_CHNL_*) </td></tr>
    <tr><td class="paramname">address</td><td>Address within selected channel </td></tr>
    <tr><td class="paramname">data</td><td>Data octet to write to address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2bd81a6437f3bca35cccdd92a681ad3e"></a><!-- doxytag: member="StackMultiByte::parameterRead" ref="a2bd81a6437f3bca35cccdd92a681ad3e" args="(uint8_t address) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int PDI, int PDO, class SpiSsHndlr = DefaultSsHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::parameterRead </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read value from direct parameter page. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="struct_stack_base_1_1_parameter.html" title="Parameter structure.">Parameter</a> index </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Read value </dd></dl>

</div>
</div>
<a class="anchor" id="a98da21e399322a4c83f069ca6532bb67"></a><!-- doxytag: member="StackMultiByte::parameterWrite" ref="a98da21e399322a4c83f069ca6532bb67" args="(uint8_t address, uint8_t value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int PDI, int PDO, class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::parameterWrite </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write value to direct parameter page. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="struct_stack_base_1_1_parameter.html" title="Parameter structure.">Parameter</a> index </td></tr>
    <tr><td class="paramname">value</td><td>Value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af707582de534cc16206350465693e14d"></a><!-- doxytag: member="StackMultiByte::processInputData" ref="af707582de534cc16206350465693e14d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int PDI, int PDO, class SpiSsHndlr = DefaultSsHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_stack_base.html#a23bedeec38ffe6161974a64ed69a599c">ProcessDataIn</a>&amp; <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::processInputData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get buffer for returning process input data from slave to master. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Process input data buffer (read/writable) </dd></dl>

</div>
</div>
<a class="anchor" id="a32e528826cf2ef157e7848630ccfea3c"></a><!-- doxytag: member="StackMultiByte::processOutputData" ref="a32e528826cf2ef157e7848630ccfea3c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int PDI, int PDO, class SpiSsHndlr = DefaultSsHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_stack_base.html#a1cc01e2d617efb90f3ad7b9a0dbc9f69">ProcessDataOut</a>&amp; <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::processOutputData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get buffer for process output data received from master. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Process output data buffer (read-only) </dd></dl>

</div>
</div>
<a class="anchor" id="abb5d9abac9362d93a92c074c52de3c66"></a><!-- doxytag: member="StackMultiByte::registerRead" ref="abb5d9abac9362d93a92c074c52de3c66" args="(Registers address)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_phy_driver.html">PhyDriver</a>&lt; SpiSsHndlr &gt;::registerRead </td>
          <td>(</td>
          <td class="paramtype">Registers&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td><code> [inline, static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a single byte from a PHY register. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Ensure interrupts disabled before calling!</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>PHY register </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PHY register value</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_phy_driver.html#a3e69188f608ae6042cf70e0c81a23b8f" title="Start reading from PHY registers.">registerReadBegin</a> </dd>
<dd>
<a class="el" href="class_phy_driver.html#a86da8a9341905d2407b3e0092f098810" title="Read next PHY register value.">registerReadNext</a> </dd>
<dd>
<a class="el" href="class_phy_driver.html#a66321e787e8cf040b58451a94335c79c" title="Read final PHY register value.">registerReadLast</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3e69188f608ae6042cf70e0c81a23b8f"></a><!-- doxytag: member="StackMultiByte::registerReadBegin" ref="a3e69188f608ae6042cf70e0c81a23b8f" args="(Registers address)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_phy_driver.html">PhyDriver</a>&lt; SpiSsHndlr &gt;::registerReadBegin </td>
          <td>(</td>
          <td class="paramtype">Registers&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start reading from PHY registers. </p>
<p>Asserts SS/ and starts reading from PHY register at specified address. This call must be followed by zero or more calls to <code><a class="el" href="class_phy_driver.html#a86da8a9341905d2407b3e0092f098810" title="Read next PHY register value.">registerReadNext()</a></code> and a final call to <a class="el" href="class_phy_driver.html#a66321e787e8cf040b58451a94335c79c" title="Read final PHY register value.">registerReadLast()</a>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Ensure interrupts disabled before calling!</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>PHY register </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PHY status register value</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_phy_driver.html#a86da8a9341905d2407b3e0092f098810" title="Read next PHY register value.">registerReadNext</a> </dd>
<dd>
<a class="el" href="class_phy_driver.html#a66321e787e8cf040b58451a94335c79c" title="Read final PHY register value.">registerReadLast</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a66321e787e8cf040b58451a94335c79c"></a><!-- doxytag: member="StackMultiByte::registerReadLast" ref="a66321e787e8cf040b58451a94335c79c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_phy_driver.html">PhyDriver</a>&lt; SpiSsHndlr &gt;::registerReadLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read final PHY register value. </p>
<p>Reads final PHY register value and de-asserts SS/</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Ensure interrupts disabled before calling!</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PHY register value</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_phy_driver.html#a3e69188f608ae6042cf70e0c81a23b8f" title="Start reading from PHY registers.">registerReadBegin</a> </dd>
<dd>
<a class="el" href="class_phy_driver.html#a86da8a9341905d2407b3e0092f098810" title="Read next PHY register value.">registerReadNext</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a86da8a9341905d2407b3e0092f098810"></a><!-- doxytag: member="StackMultiByte::registerReadNext" ref="a86da8a9341905d2407b3e0092f098810" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_phy_driver.html">PhyDriver</a>&lt; SpiSsHndlr &gt;::registerReadNext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read next PHY register value. </p>
<p>This function automatically request the following register value. Use <code>registerReadLast</code> when reading the last required PHY register value.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Ensure interrupts disabled before calling!</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PHY register value</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_phy_driver.html#a3e69188f608ae6042cf70e0c81a23b8f" title="Start reading from PHY registers.">registerReadBegin</a> </dd>
<dd>
<a class="el" href="class_phy_driver.html#a66321e787e8cf040b58451a94335c79c" title="Read final PHY register value.">registerReadLast</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a47a2482b49abe71602179fd3aa07d618"></a><!-- doxytag: member="StackMultiByte::registerReadStatus" ref="a47a2482b49abe71602179fd3aa07d618" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_phy_driver.html">PhyDriver</a>&lt; SpiSsHndlr &gt;::registerReadStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the status register. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>PHY status register value </dd></dl>

</div>
</div>
<a class="anchor" id="a7f903f8fdaa2eab1b7590bc313e6b953"></a><!-- doxytag: member="StackMultiByte::registerReadWriteBegin" ref="a7f903f8fdaa2eab1b7590bc313e6b953" args="(Registers address, uint8_t data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_phy_driver.html">PhyDriver</a>&lt; SpiSsHndlr &gt;::registerReadWriteBegin </td>
          <td>(</td>
          <td class="paramtype">Registers&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start write/read operation to PHY registers. </p>
<p>Asserts SS/ and starts writing to PHY register at specified address. This call must be followed by zero or more calls to <code><a class="el" href="class_phy_driver.html#ab524d19f3140e0f85cf749455386d777" title="Write next PHY register value.">registerWriteNext()</a></code> and a final call to <a class="el" href="class_phy_driver.html#ac12de1a0052912732c3e336a63813288" title="Finish write access.">registerWriteDone()</a>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Ensure interrupts disabled before calling!</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>PHY register </td></tr>
    <tr><td class="paramname">data</td><td>PHY register value to write at address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PHY status register value</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_phy_driver.html#ab524d19f3140e0f85cf749455386d777" title="Write next PHY register value.">registerWriteNext</a> </dd>
<dd>
<a class="el" href="class_phy_driver.html#ac12de1a0052912732c3e336a63813288" title="Finish write access.">registerWriteDone</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae716f1ad688df5d7ec51c21ac7455714"></a><!-- doxytag: member="StackMultiByte::registerReadWriteDone" ref="ae716f1ad688df5d7ec51c21ac7455714" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_phy_driver.html">PhyDriver</a>&lt; SpiSsHndlr &gt;::registerReadWriteDone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finish write access and return final PHY register value. </p>
<p>Reads final PHY register value and de-asserts SS/</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Ensure interrupts disabled before calling!</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PHY register value at previous address</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_phy_driver.html#acc92fa8676c28e9d37bb9829d097efcd" title="Start write operation to PHY registers.">registerWriteBegin</a> </dd>
<dd>
<a class="el" href="class_phy_driver.html#ab524d19f3140e0f85cf749455386d777" title="Write next PHY register value.">registerWriteNext</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acb69fbf8ceb40d008bf224d391e6d227"></a><!-- doxytag: member="StackMultiByte::registerReadWriteNext" ref="acb69fbf8ceb40d008bf224d391e6d227" args="(uint8_t data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_phy_driver.html">PhyDriver</a>&lt; SpiSsHndlr &gt;::registerReadWriteNext </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write/read next PHY register value. </p>
<p>Use <code>registerWriteDone</code> to finish the write operation.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Ensure interrupts disabled before calling!</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>PHY register value to write at next address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PHY register value at previous address</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_phy_driver.html#acc92fa8676c28e9d37bb9829d097efcd" title="Start write operation to PHY registers.">registerWriteBegin</a> </dd>
<dd>
<a class="el" href="class_phy_driver.html#ac12de1a0052912732c3e336a63813288" title="Finish write access.">registerWriteDone</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a398f7bbadcaaddf963e47620f68e1374"></a><!-- doxytag: member="StackMultiByte::registerWrite" ref="a398f7bbadcaaddf963e47620f68e1374" args="(Registers address, uint8_t data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_phy_driver.html">PhyDriver</a>&lt; SpiSsHndlr &gt;::registerWrite </td>
          <td>(</td>
          <td class="paramtype">Registers&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a single byte to a PHY register. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Ensure interrupts disabled before calling!</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>PHY register </td></tr>
    <tr><td class="paramname">data</td><td>Value to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PHY status register </dd></dl>

</div>
</div>
<a class="anchor" id="acc92fa8676c28e9d37bb9829d097efcd"></a><!-- doxytag: member="StackMultiByte::registerWriteBegin" ref="acc92fa8676c28e9d37bb9829d097efcd" args="(Registers address)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_phy_driver.html">PhyDriver</a>&lt; SpiSsHndlr &gt;::registerWriteBegin </td>
          <td>(</td>
          <td class="paramtype">Registers&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start write operation to PHY registers. </p>
<p>Asserts SS/ and starts writing to PHY register at specified address. This call must be followed by one or more calls to <code><a class="el" href="class_phy_driver.html#ab524d19f3140e0f85cf749455386d777" title="Write next PHY register value.">registerWriteNext()</a></code> and a final call to <a class="el" href="class_phy_driver.html#ac12de1a0052912732c3e336a63813288" title="Finish write access.">registerWriteDone()</a>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Ensure interrupts disabled before calling!</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>PHY register</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_phy_driver.html#ab524d19f3140e0f85cf749455386d777" title="Write next PHY register value.">registerWriteNext</a> </dd>
<dd>
<a class="el" href="class_phy_driver.html#ac12de1a0052912732c3e336a63813288" title="Finish write access.">registerWriteDone</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae07a77c1480a60438716fc6817ce3c3e"></a><!-- doxytag: member="StackMultiByte::registerWriteBegin" ref="ae07a77c1480a60438716fc6817ce3c3e" args="(Registers address, uint8_t data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_phy_driver.html">PhyDriver</a>&lt; SpiSsHndlr &gt;::registerWriteBegin </td>
          <td>(</td>
          <td class="paramtype">Registers&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start write operation to PHY registers. </p>
<p>Asserts SS/ and starts writing to PHY register at specified address. This call must be followed by zero or more calls to <code><a class="el" href="class_phy_driver.html#ab524d19f3140e0f85cf749455386d777" title="Write next PHY register value.">registerWriteNext()</a></code> and a final call to <a class="el" href="class_phy_driver.html#ac12de1a0052912732c3e336a63813288" title="Finish write access.">registerWriteDone()</a>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Ensure interrupts disabled before calling!</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>PHY register </td></tr>
    <tr><td class="paramname">data</td><td>PHY register value to write at address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PHY status register value</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_phy_driver.html#ab524d19f3140e0f85cf749455386d777" title="Write next PHY register value.">registerWriteNext</a> </dd>
<dd>
<a class="el" href="class_phy_driver.html#ac12de1a0052912732c3e336a63813288" title="Finish write access.">registerWriteDone</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac12de1a0052912732c3e336a63813288"></a><!-- doxytag: member="StackMultiByte::registerWriteDone" ref="ac12de1a0052912732c3e336a63813288" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_phy_driver.html">PhyDriver</a>&lt; SpiSsHndlr &gt;::registerWriteDone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finish write access. </p>
<p>Waits for SPI communication to complete and de-asserts SS/</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Ensure interrupts disabled before calling!</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_phy_driver.html#acc92fa8676c28e9d37bb9829d097efcd" title="Start write operation to PHY registers.">registerWriteBegin</a> </dd>
<dd>
<a class="el" href="class_phy_driver.html#ab524d19f3140e0f85cf749455386d777" title="Write next PHY register value.">registerWriteNext</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab524d19f3140e0f85cf749455386d777"></a><!-- doxytag: member="StackMultiByte::registerWriteNext" ref="ab524d19f3140e0f85cf749455386d777" args="(uint8_t data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_phy_driver.html">PhyDriver</a>&lt; SpiSsHndlr &gt;::registerWriteNext </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write next PHY register value. </p>
<p>Use <code>registerWriteDone</code> to finish the write operation.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Ensure interrupts disabled before calling!</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>PHY register value to write at next address</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_phy_driver.html#acc92fa8676c28e9d37bb9829d097efcd" title="Start write operation to PHY registers.">registerWriteBegin</a> </dd>
<dd>
<a class="el" href="class_phy_driver.html#ac12de1a0052912732c3e336a63813288" title="Finish write access.">registerWriteDone</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aca369861be996ee1bd185a6b0c5faa54"></a><!-- doxytag: member="StackMultiByte::setIoLinkListen" ref="aca369861be996ee1bd185a6b0c5faa54" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int PDI, int PDO, class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::setIoLinkListen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Put PHY in IO-Link-Listen mode. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>PHY status register </dd></dl>

<p>Reimplemented in <a class="el" href="class_stack_transparent.html#a5a20c9427807329aac286b459da32885">StackTransparent</a>.</p>

</div>
</div>
<a class="anchor" id="a3886bb7a9e5f77ff948c858ce000810c"></a><!-- doxytag: member="StackMultiByte::setLedLevel" ref="a3886bb7a9e5f77ff948c858ce000810c" args="(Led led, typename Phy::LedLevel level)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int PDI, int PDO, class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::setLedLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_stack_base.html#aba03e68229de6848aa8dbcbebb0b8fa1">Led</a>&#160;</td>
          <td class="paramname"><em>led</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="class_phy_driver.html#ae290b3f020b5a79f2dc8461c096fb928">Phy::LedLevel</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set LED level. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">led</td><td>Selected LED </td></tr>
    <tr><td class="paramname">level</td><td>Desired level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd27d8ef43303f31ddd5a83b8b65c0b0"></a><!-- doxytag: member="StackMultiByte::setSioActive" ref="afd27d8ef43303f31ddd5a83b8b65c0b0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int PDI, int PDO, class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::setSioActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Put PHY in SIO-Active state. </p>
<p>The CQ line is driven according to the setting of the HS and LS bits, as specified by <a class="el" href="class_stack_multi_byte.html#a6243166470d7f7fe9fde2e0ef5f33674" title="PHY drive mode to use in SIO mode.">Stack::SIO_DRIVE_MODE</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>PHY status register </dd></dl>

<p>Reimplemented in <a class="el" href="class_stack_transparent.html#a19b94c4fe339b42c2392beca4b137309">StackTransparent</a>.</p>

</div>
</div>
<a class="anchor" id="a5f37283c0dd6c22c9aad37ae4f9ba41d"></a><!-- doxytag: member="StackMultiByte::setSioLevel" ref="a5f37283c0dd6c22c9aad37ae4f9ba41d" args="(bool active)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int PDI, int PDO, class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::setSioLevel </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify the level of the CQ line in SIO mode (STACK_MODE_SIO) state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">active</td><td>If <a class="el" href="class_stack_multi_byte.html#a6243166470d7f7fe9fde2e0ef5f33674" title="PHY drive mode to use in SIO mode.">Stack::SIO_DRIVE_MODE</a> is <a class="el" href="class_stack_base.html#a3dcf9e80a57e04850e9d352314ab3d1faf61e899e8cb745fae418ea0ba7448784" title="HS only used.">Stack::DRIVE_MODE_PNP</a> or <a class="el" href="class_stack_base.html#a3dcf9e80a57e04850e9d352314ab3d1fafad837a4257fb2e2da156eee102574c5" title="LS only used.">Stack::DRIVE_MODE_NPN</a> the relevant switch is activated if <code>active</code> == true. In <a class="el" href="class_stack_base.html#a3dcf9e80a57e04850e9d352314ab3d1fa75f3754813a2ebfc35f1444723fdfaf2" title="Push-pull, HS and LS active.">Stack::DRIVE_MODE_PUSH_PULL</a> (push-pull) CQ is driven high (<code>active</code> == true) or low (<code>active</code> == false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a62338b4ed70e09a471a2d5771a3b48"></a><!-- doxytag: member="StackMultiByte::setSioListen" ref="a5a62338b4ed70e09a471a2d5771a3b48" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int PDI, int PDO, class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::setSioListen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Put PHY in SIO-Listen mode. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>PHY status register </dd></dl>

<p>Reimplemented in <a class="el" href="class_stack_transparent.html#ad4340b6bdcc9735dca174e2084863bca">StackTransparent</a>.</p>

</div>
</div>
<a class="anchor" id="ad4c95c8a70f95822c7dc388df674f758"></a><!-- doxytag: member="StackMultiByte::stack" ref="ad4c95c8a70f95822c7dc388df674f758" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int PDI, int PDO, class SpiSsHndlr = DefaultSsHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_stack_base.html#aacc069c5ddb782702ed3410369f3e833">StackT</a>&amp; <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::stack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function returning derived stack specialization. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Derived stack instance </dd></dl>

</div>
</div>
<a class="anchor" id="a19460c2295fea1889af3f24b854a0be3"></a><!-- doxytag: member="StackMultiByte::stackMode" ref="a19460c2295fea1889af3f24b854a0be3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int PDI, int PDO, class SpiSsHndlr = DefaultSsHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_stack_base.html#a6db4d23904347b9a9a4843a1a4dd3625">StackMode</a> <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::stackMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get current stack mode. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>STACK_MODE_SIO or STACK_MODE_IOLINK </dd></dl>

</div>
</div>
<a class="anchor" id="aaa8c60e19125424e7d78063182485ece"></a><!-- doxytag: member="StackMultiByte::startCallbackTimer" ref="aaa8c60e19125424e7d78063182485ece" args="(uint8_t delay=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int PDI, int PDO, class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::startCallbackTimer </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>delay</em> = <code>0</code></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start / synchronize user-callback timer. </p>
<p>Starts a timer which ensures that the user call-back will be called on a regular basis, even if no master message has been received</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>Delay until first call to user callback (in 1/10ms units) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1158c426af1489d6599aa902dc9f7cf"></a><!-- doxytag: member="StackMultiByte::temperature" ref="af1158c426af1489d6599aa902dc9f7cf" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int PDI, int PDO, class SpiSsHndlr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::temperature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get current measured temperature value. </p>
<p>In order to convert the returned value to a Celsius reading, the following formula should be applied:</p>
<p>Temperature [Celsius] = (80 - temp) * 2.70</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current temperature value </dd></dl>

</div>
</div>
<a class="anchor" id="a496c084e0accd0e1850bd38c33b54cdf"></a><!-- doxytag: member="StackMultiByte::validateFrameType" ref="a496c084e0accd0e1850bd38c33b54cdf" args="(uint8_t ckt)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int PDI, int PDO, class SpiSsHndlr &gt; </div>
<div class="memtemplate">
template&lt;IoLink::DeviceDLMode DDL_MODE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::validateFrameType </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ckt</em></td><td>)</td>
          <td><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate frame type. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">DDL_MODE</td><td>Applicable DDL mode (see <a class="el" href="class_io_link.html#ad6edfa5d119210ab07d3cfdecb82621f" title="Device DL-mode.">IoLink::DeviceDLMode</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ckt</td><td>Received CKT frame octet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if frame type valid, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a8edcb86567e271faaa365c9294b4c975"></a><!-- doxytag: member="StackMultiByte::void::TIMER0_COMPB_vect" ref="a8edcb86567e271faaa365c9294b4c975" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int PDI, int PDO, class SpiSsHndlr = DefaultSsHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_stack_base.html">StackBase</a>&lt; T, PDI, PDO, SpiSsHndlr &gt;::void::TIMER0_COMPB_vect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The ISR function can access the stack state, and is declared here as a friend. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a5ebd01fd0a680fa8a9e26dbdcb5981cb"></a><!-- doxytag: member="StackMultiByte::MSEQ_CAPABILITY" ref="a5ebd01fd0a680fa8a9e26dbdcb5981cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t <a class="el" href="class_stack_multi_byte.html#a5ebd01fd0a680fa8a9e26dbdcb5981cb">StackMultiByte::MSEQ_CAPABILITY</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">  IoLink::MSEQCAP_ISDU_NOT_SUPPORTED | 
                                            IoLink::MSEQCAP_OP_CODE_0 | 
                                            IoLink::MSEQCAP_PREOP_CODE_0
</pre></div>
<p>M-sequence Capability (Direct Parameter 0x03) </p>

</div>
</div>
<a class="anchor" id="a4de9e504f38e60ca8d25d39a0e833490"></a><!-- doxytag: member="StackMultiByte::PHY_CFG" ref="a4de9e504f38e60ca8d25d39a0e833490" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t <a class="el" href="class_stack_multi_byte.html#a4de9e504f38e60ca8d25d39a0e833490">StackMultiByte::PHY_CFG</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">          CFG_UVT_16_3V | CFG_RF_ABS | CFG_S5V_3_3V
                                 | (<a class="code" href="class_stack_multi_byte.html#a0afe2483a3d59140ddd04090a336406d" title="Communication speed (must be either 38400 or 230400)">BAUD_RATE</a> == 38400 ? <a class="code" href="class_phy_driver.html#ade7686aea200c2dbe07c1ade2a4756b1aa76bc8384e8ecfa639e67f80525e6131" title="COM2.">CFG_BD_38400</a> : <a class="code" href="class_phy_driver.html#ade7686aea200c2dbe07c1ade2a4756b1a4390ee12dbd6a30b61149d39f29de0a2" title="COM3.">CFG_BD_230400</a>)
</pre></div>
<p>PHY configuration. </p>

</div>
</div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 28 2014 10:20:15 for HMT Mini-Stack software by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
